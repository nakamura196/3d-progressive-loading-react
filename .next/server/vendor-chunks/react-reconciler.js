"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler";
exports.ids = ["vendor-chunks/react-reconciler"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  ((exports.ConcurrentRoot = 1),\n  (exports.ContinuousEventPriority = 8),\n  (exports.DefaultEventPriority = 32),\n  (exports.DiscreteEventPriority = 2),\n  (exports.IdleEventPriority = 268435456),\n  (exports.LegacyRoot = 0),\n  (exports.NoEventPriority = 0));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsS0FBcUM7QUFDckMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRywrQkFBK0I7QUFDbEMsR0FBRyw0QkFBNEI7QUFDL0IsR0FBRyw2QkFBNkI7QUFDaEMsR0FBRyx5QkFBeUI7QUFDNUIsR0FBRyxrQkFBa0I7QUFDckIsR0FBRyx1QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYWthbXVyYS9naXQvM2Qvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuICAoKGV4cG9ydHMuQ29uY3VycmVudFJvb3QgPSAxKSxcbiAgKGV4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSA4KSxcbiAgKGV4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSAzMiksXG4gIChleHBvcnRzLkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IDIpLFxuICAoZXhwb3J0cy5JZGxlRXZlbnRQcmlvcml0eSA9IDI2ODQzNTQ1NiksXG4gIChleHBvcnRzLkxlZ2FjeVJvb3QgPSAwKSxcbiAgKGV4cG9ydHMuTm9FdmVudFByaW9yaXR5ID0gMCkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \n true && (module.exports = function($$$config) {\n    function findHook(fiber, id) {\n        for(fiber = fiber.memoizedState; null !== fiber && 0 < id;)fiber = fiber.next, id--;\n        return fiber;\n    }\n    function copyWithSetImpl(obj, path, index, value) {\n        if (index >= path.length) return value;\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n        return updated;\n    }\n    function copyWithRename(obj, oldPath, newPath) {\n        if (oldPath.length !== newPath.length) console.warn(\"copyWithRename() expects paths of the same length\");\n        else {\n            for(var i = 0; i < newPath.length - 1; i++)if (oldPath[i] !== newPath[i]) {\n                console.warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                return;\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n        }\n    }\n    function copyWithRenameImpl(obj, oldPath, newPath, index) {\n        var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n        return updated;\n    }\n    function copyWithDeleteImpl(obj, path, index) {\n        var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);\n        if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;\n        updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n        return updated;\n    }\n    function shouldSuspendImpl() {\n        return !1;\n    }\n    function shouldErrorImpl() {\n        return null;\n    }\n    function createFiber(tag, pendingProps, key, mode) {\n        return new FiberNode(tag, pendingProps, key, mode);\n    }\n    function scheduleRoot(root, element) {\n        root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork());\n    }\n    function scheduleRefresh(root, update) {\n        if (null !== resolveFamily) {\n            var staleFamilies = update.staleFamilies;\n            update = update.updatedFamilies;\n            flushPassiveEffects();\n            scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);\n            flushSyncWork();\n        }\n    }\n    function setRefreshHandler(handler) {\n        resolveFamily = handler;\n    }\n    function warnInvalidHookAccess() {\n        console.error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks\");\n    }\n    function warnInvalidContextAccess() {\n        console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n    }\n    function noop() {}\n    function warnForMissingKey() {}\n    function setToSortedString(set) {\n        var array = [];\n        set.forEach(function(value) {\n            array.push(value);\n        });\n        return array.sort().join(\", \");\n    }\n    function getIteratorFn(maybeIterable) {\n        if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[\"@@iterator\"];\n        return \"function\" === typeof maybeIterable ? maybeIterable : null;\n    }\n    function getComponentNameFromType(type) {\n        if (null == type) return null;\n        if (\"function\" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;\n        if (\"string\" === typeof type) return type;\n        switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n                return \"Portal\";\n            case REACT_PROFILER_TYPE:\n                return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n                return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n                return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n                return \"SuspenseList\";\n        }\n        if (\"object\" === typeof type) switch(\"number\" === typeof type.tag && console.error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), type.$$typeof){\n            case REACT_CONTEXT_TYPE:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case REACT_CONSUMER_TYPE:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case REACT_FORWARD_REF_TYPE:\n                var innerType = type.render;\n                type = type.displayName;\n                type || (type = innerType.displayName || innerType.name || \"\", type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\");\n                return type;\n            case REACT_MEMO_TYPE:\n                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE:\n                innerType = type._payload;\n                type = type._init;\n                try {\n                    return getComponentNameFromType(type(innerType));\n                } catch (x) {}\n        }\n        return null;\n    }\n    function getComponentNameFromFiber(fiber) {\n        var type = fiber.type;\n        switch(fiber.tag){\n            case 24:\n                return \"Cache\";\n            case 9:\n                return (type._context.displayName || \"Context\") + \".Consumer\";\n            case 10:\n                return (type.displayName || \"Context\") + \".Provider\";\n            case 18:\n                return \"DehydratedFragment\";\n            case 11:\n                return fiber = type.render, fiber = fiber.displayName || fiber.name || \"\", type.displayName || (\"\" !== fiber ? \"ForwardRef(\" + fiber + \")\" : \"ForwardRef\");\n            case 7:\n                return \"Fragment\";\n            case 26:\n            case 27:\n            case 5:\n                return type;\n            case 4:\n                return \"Portal\";\n            case 3:\n                return \"Root\";\n            case 6:\n                return \"Text\";\n            case 16:\n                return getComponentNameFromType(type);\n            case 8:\n                return type === REACT_STRICT_MODE_TYPE ? \"StrictMode\" : \"Mode\";\n            case 22:\n                return \"Offscreen\";\n            case 12:\n                return \"Profiler\";\n            case 21:\n                return \"Scope\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 25:\n                return \"TracingMarker\";\n            case 1:\n            case 0:\n            case 14:\n            case 15:\n                if (\"function\" === typeof type) return type.displayName || type.name || null;\n                if (\"string\" === typeof type) return type;\n                break;\n            case 29:\n                type = fiber._debugInfo;\n                if (null != type) {\n                    for(var i = type.length - 1; 0 <= i; i--)if (\"string\" === typeof type[i].name) return type[i].name;\n                }\n                if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);\n        }\n        return null;\n    }\n    function disabledLog() {}\n    function disableLogs() {\n        if (0 === disabledDepth) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                value: disabledLog,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n            });\n        }\n        disabledDepth++;\n    }\n    function reenableLogs() {\n        disabledDepth--;\n        if (0 === disabledDepth) {\n            var props = {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0\n            };\n            Object.defineProperties(console, {\n                log: assign({}, props, {\n                    value: prevLog\n                }),\n                info: assign({}, props, {\n                    value: prevInfo\n                }),\n                warn: assign({}, props, {\n                    value: prevWarn\n                }),\n                error: assign({}, props, {\n                    value: prevError\n                }),\n                group: assign({}, props, {\n                    value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                    value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                    value: prevGroupEnd\n                })\n            });\n        }\n        0 > disabledDepth && console.error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n    }\n    function describeBuiltInComponentFrame(name) {\n        if (void 0 === prefix) try {\n            throw Error();\n        } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || \"\";\n            suffix = -1 < x.stack.indexOf(\"\\n    at\") ? \" (<anonymous>)\" : -1 < x.stack.indexOf(\"@\") ? \"@unknown:0:0\" : \"\";\n        }\n        return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) return \"\";\n        var frame = componentFrameCache.get(fn);\n        if (void 0 !== frame) return frame;\n        reentry = !0;\n        frame = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher = null;\n        previousDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = null;\n        disableLogs();\n        try {\n            var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    try {\n                        if (construct) {\n                            var Fake = function() {\n                                throw Error();\n                            };\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    throw Error();\n                                }\n                            });\n                            if (\"object\" === typeof Reflect && Reflect.construct) {\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    var control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x$0) {\n                                    control = x$0;\n                                }\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x$1) {\n                                control = x$1;\n                            }\n                            (Fake = fn()) && \"function\" === typeof Fake.catch && Fake.catch(function() {});\n                        }\n                    } catch (sample) {\n                        if (sample && control && \"string\" === typeof sample.stack) return [\n                            sample.stack,\n                            control.stack\n                        ];\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            };\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\");\n            namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, \"name\", {\n                value: \"DetermineComponentFrameRoot\"\n            });\n            var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n            if (sampleStack && controlStack) {\n                var sampleLines = sampleStack.split(\"\\n\"), controlLines = controlStack.split(\"\\n\");\n                for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(\"DetermineComponentFrameRoot\");)namePropDescriptor++;\n                for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(\"DetermineComponentFrameRoot\");)_RunInRootFrame$Deter++;\n                if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;\n                for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                    if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                        do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {\n                            var _frame = \"\\n\" + sampleLines[namePropDescriptor].replace(\" at new \", \" at \");\n                            fn.displayName && _frame.includes(\"<anonymous>\") && (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                            \"function\" === typeof fn && componentFrameCache.set(fn, _frame);\n                            return _frame;\n                        }\n                        while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n                    }\n                    break;\n                }\n            }\n        } finally{\n            reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;\n        }\n        sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\") ? describeBuiltInComponentFrame(sampleLines) : \"\";\n        \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n        return sampleLines;\n    }\n    function describeFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return describeBuiltInComponentFrame(fiber.type);\n            case 16:\n                return describeBuiltInComponentFrame(\"Lazy\");\n            case 13:\n                return describeBuiltInComponentFrame(\"Suspense\");\n            case 19:\n                return describeBuiltInComponentFrame(\"SuspenseList\");\n            case 0:\n            case 15:\n                return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;\n            case 11:\n                return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;\n            case 1:\n                return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;\n            default:\n                return \"\";\n        }\n    }\n    function getStackByFiberInDevAndProd(workInProgress) {\n        try {\n            var info = \"\";\n            do {\n                info += describeFiber(workInProgress);\n                var debugInfo = workInProgress._debugInfo;\n                if (debugInfo) for(var i = debugInfo.length - 1; 0 <= i; i--){\n                    var entry = debugInfo[i];\n                    if (\"string\" === typeof entry.name) {\n                        var JSCompiler_temp_const = info, env = entry.env;\n                        var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? \" [\" + env + \"]\" : \"\"));\n                        info = JSCompiler_temp_const + JSCompiler_inline_result;\n                    }\n                }\n                workInProgress = workInProgress.return;\n            }while (workInProgress);\n            return info;\n        } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n        }\n    }\n    function getCurrentFiberStackInDev() {\n        return null === current ? \"\" : getStackByFiberInDevAndProd(current);\n    }\n    function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {\n        var previousFiber = current;\n        ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;\n        isRendering = !1;\n        current = fiber;\n        try {\n            return callback(arg0, arg1, arg2, arg3, arg4);\n        } finally{\n            current = previousFiber;\n        }\n        throw Error(\"runWithFiberInDEV should never be called in production. This is a bug in React.\");\n    }\n    function getNearestMountedFiber(fiber) {\n        var node = fiber, nearestMounted = fiber;\n        if (fiber.alternate) for(; node.return;)node = node.return;\n        else {\n            fiber = node;\n            do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;\n            while (fiber);\n        }\n        return 3 === node.tag ? nearestMounted : null;\n    }\n    function assertIsMounted(fiber) {\n        if (getNearestMountedFiber(fiber) !== fiber) throw Error(\"Unable to find node on an unmounted component.\");\n    }\n    function findCurrentFiberUsingSlowPath(fiber) {\n        var alternate = fiber.alternate;\n        if (!alternate) {\n            alternate = getNearestMountedFiber(fiber);\n            if (null === alternate) throw Error(\"Unable to find node on an unmounted component.\");\n            return alternate !== fiber ? null : fiber;\n        }\n        for(var a = fiber, b = alternate;;){\n            var parentA = a.return;\n            if (null === parentA) break;\n            var parentB = parentA.alternate;\n            if (null === parentB) {\n                b = parentA.return;\n                if (null !== b) {\n                    a = b;\n                    continue;\n                }\n                break;\n            }\n            if (parentA.child === parentB.child) {\n                for(parentB = parentA.child; parentB;){\n                    if (parentB === a) return assertIsMounted(parentA), fiber;\n                    if (parentB === b) return assertIsMounted(parentA), alternate;\n                    parentB = parentB.sibling;\n                }\n                throw Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) a = parentA, b = parentB;\n            else {\n                for(var didFindChild = !1, _child = parentA.child; _child;){\n                    if (_child === a) {\n                        didFindChild = !0;\n                        a = parentA;\n                        b = parentB;\n                        break;\n                    }\n                    if (_child === b) {\n                        didFindChild = !0;\n                        b = parentA;\n                        a = parentB;\n                        break;\n                    }\n                    _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                    for(_child = parentB.child; _child;){\n                        if (_child === a) {\n                            didFindChild = !0;\n                            a = parentB;\n                            b = parentA;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = !0;\n                            b = parentB;\n                            a = parentA;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) throw Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n            }\n            if (a.alternate !== b) throw Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        if (3 !== a.tag) throw Error(\"Unable to find node on an unmounted component.\");\n        return a.stateNode.current === a ? fiber : alternate;\n    }\n    function findCurrentHostFiber(parent) {\n        parent = findCurrentFiberUsingSlowPath(parent);\n        return null !== parent ? findCurrentHostFiberImpl(parent) : null;\n    }\n    function findCurrentHostFiberImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            tag = findCurrentHostFiberImpl(node);\n            if (null !== tag) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function findCurrentHostFiberWithNoPortalsImpl(node) {\n        var tag = node.tag;\n        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n        for(node = node.child; null !== node;){\n            if (4 !== node.tag && (tag = findCurrentHostFiberWithNoPortalsImpl(node), null !== tag)) return tag;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function createCursor(defaultValue) {\n        return {\n            current: defaultValue\n        };\n    }\n    function pop(cursor, fiber) {\n        0 > index$jscomp$0 ? console.error(\"Unexpected pop.\") : (fiber !== fiberStack[index$jscomp$0] && console.error(\"Unexpected Fiber popped.\"), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);\n    }\n    function push(cursor, value, fiber) {\n        index$jscomp$0++;\n        valueStack[index$jscomp$0] = cursor.current;\n        fiberStack[index$jscomp$0] = fiber;\n        cursor.current = value;\n    }\n    function clz32Fallback(x) {\n        x >>>= 0;\n        return 0 === x ? 32 : 31 - (log$1(x) / LN2 | 0) | 0;\n    }\n    function getLabelForLane(lane) {\n        if (lane & 1) return \"SyncHydrationLane\";\n        if (lane & 2) return \"Sync\";\n        if (lane & 4) return \"InputContinuousHydration\";\n        if (lane & 8) return \"InputContinuous\";\n        if (lane & 16) return \"DefaultHydration\";\n        if (lane & 32) return \"Default\";\n        if (lane & 64) return \"TransitionHydration\";\n        if (lane & 4194176) return \"Transition\";\n        if (lane & 62914560) return \"Retry\";\n        if (lane & 67108864) return \"SelectiveHydration\";\n        if (lane & 134217728) return \"IdleHydration\";\n        if (lane & 268435456) return \"Idle\";\n        if (lane & 536870912) return \"Offscreen\";\n        if (lane & 1073741824) return \"Deferred\";\n    }\n    function getHighestPriorityLanes(lanes) {\n        var pendingSyncLanes = lanes & 42;\n        if (0 !== pendingSyncLanes) return pendingSyncLanes;\n        switch(lanes & -lanes){\n            case 1:\n                return 1;\n            case 2:\n                return 2;\n            case 4:\n                return 4;\n            case 8:\n                return 8;\n            case 16:\n                return 16;\n            case 32:\n                return 32;\n            case 64:\n                return 64;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return lanes & 4194176;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return lanes & 62914560;\n            case 67108864:\n                return 67108864;\n            case 134217728:\n                return 134217728;\n            case 268435456:\n                return 268435456;\n            case 536870912:\n                return 536870912;\n            case 1073741824:\n                return 0;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), lanes;\n        }\n    }\n    function getNextLanes(root, wipLanes) {\n        var pendingLanes = root.pendingLanes;\n        if (0 === pendingLanes) return 0;\n        var nextLanes = 0, suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, warmLanes = root.warmLanes;\n        root = 0 !== root.finishedLanes;\n        var nonIdlePendingLanes = pendingLanes & 134217727;\n        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));\n        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;\n    }\n    function checkIfRootIsPrerendering(root, renderLanes) {\n        return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);\n    }\n    function computeExpirationTime(lane, currentTime) {\n        switch(lane){\n            case 1:\n            case 2:\n            case 4:\n            case 8:\n                return currentTime + 250;\n            case 16:\n            case 32:\n            case 64:\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n                return currentTime + 5e3;\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n                return -1;\n            case 67108864:\n            case 134217728:\n            case 268435456:\n            case 536870912:\n            case 1073741824:\n                return -1;\n            default:\n                return console.error(\"Should have found matching lanes. This is a bug in React.\"), -1;\n        }\n    }\n    function claimNextTransitionLane() {\n        var lane = nextTransitionLane;\n        nextTransitionLane <<= 1;\n        0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n        return lane;\n    }\n    function claimNextRetryLane() {\n        var lane = nextRetryLane;\n        nextRetryLane <<= 1;\n        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n        return lane;\n    }\n    function createLaneMap(initial) {\n        for(var laneMap = [], i = 0; 31 > i; i++)laneMap.push(initial);\n        return laneMap;\n    }\n    function markRootUpdated$1(root, updateLane) {\n        root.pendingLanes |= updateLane;\n        268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);\n    }\n    function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        var previouslyPendingLanes = root.pendingLanes;\n        root.pendingLanes = remainingLanes;\n        root.suspendedLanes = 0;\n        root.pingedLanes = 0;\n        root.warmLanes = 0;\n        root.expiredLanes &= remainingLanes;\n        root.entangledLanes &= remainingLanes;\n        root.errorRecoveryDisabledLanes &= remainingLanes;\n        root.shellSuspendCounter = 0;\n        var entanglements = root.entanglements, expirationTimes = root.expirationTimes, hiddenUpdates = root.hiddenUpdates;\n        for(remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;){\n            var index = 31 - clz32(remainingLanes), lane = 1 << index;\n            entanglements[index] = 0;\n            expirationTimes[index] = -1;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (null !== hiddenUpdatesForLane) for(hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++){\n                var update = hiddenUpdatesForLane[index];\n                null !== update && (update.lane &= -536870913);\n            }\n            remainingLanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n    }\n    function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n        root.pendingLanes |= spawnedLane;\n        root.suspendedLanes &= ~spawnedLane;\n        var spawnedLaneIndex = 31 - clz32(spawnedLane);\n        root.entangledLanes |= spawnedLane;\n        root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;\n    }\n    function markRootEntangled(root, entangledLanes) {\n        var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n        for(root = root.entanglements; rootEntangledLanes;){\n            var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;\n            lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);\n            rootEntangledLanes &= ~lane;\n        }\n    }\n    function addFiberToLanesMap(root, fiber, lanes) {\n        if (isDevToolsPresent) for(root = root.pendingUpdatersLaneMap; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            root[index].add(fiber);\n            lanes &= ~lane;\n        }\n    }\n    function movePendingFibersToMemoized(root, lanes) {\n        if (isDevToolsPresent) for(var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;){\n            var index = 31 - clz32(lanes);\n            root = 1 << index;\n            index = pendingUpdatersLaneMap[index];\n            0 < index.size && (index.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);\n            }), index.clear());\n            lanes &= ~root;\n        }\n    }\n    function lanesToEventPriority(lanes) {\n        lanes &= -lanes;\n        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;\n    }\n    function injectInternals(internals) {\n        if (\"undefined\" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;\n        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n        if (hook.isDisabled) return !0;\n        if (!hook.supportsFiber) return console.error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools\"), !0;\n        try {\n            rendererID = hook.inject(internals), injectedHook = hook;\n        } catch (err) {\n            console.error(\"React instrumentation encountered an error: %s.\", err);\n        }\n        return hook.checkDCE ? !0 : !1;\n    }\n    function onCommitRoot$1(root, eventPriority) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot) try {\n            var didError = 128 === (root.current.flags & 128);\n            switch(eventPriority){\n                case 2:\n                    var schedulerPriority = ImmediatePriority;\n                    break;\n                case 8:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                case 32:\n                    schedulerPriority = NormalPriority$1;\n                    break;\n                case 268435456:\n                    schedulerPriority = IdlePriority;\n                    break;\n                default:\n                    schedulerPriority = NormalPriority$1;\n            }\n            injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function setIsStrictModeForDevtools(newIsStrictMode) {\n        \"function\" === typeof log && unstable_setDisableYieldValue(newIsStrictMode);\n        if (injectedHook && \"function\" === typeof injectedHook.setStrictMode) try {\n            injectedHook.setStrictMode(rendererID, newIsStrictMode);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n    }\n    function injectProfilingHooks(profilingHooks) {\n        injectedProfilingHooks = profilingHooks;\n    }\n    function markCommitStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();\n    }\n    function markComponentRenderStarted(fiber) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n    function markComponentRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();\n    }\n    function markRenderStarted(lanes) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);\n    }\n    function markRenderStopped() {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();\n    }\n    function markStateUpdateScheduled(fiber, lane) {\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n    function is(x, y) {\n        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;\n    }\n    function createCapturedValueAtFiber(value, source) {\n        if (\"object\" === typeof value && null !== value) {\n            var existing = CapturedStacks.get(value);\n            if (void 0 !== existing) return existing;\n            source = {\n                value: value,\n                source: source,\n                stack: getStackByFiberInDevAndProd(source)\n            };\n            CapturedStacks.set(value, source);\n            return source;\n        }\n        return {\n            value: value,\n            source: source,\n            stack: getStackByFiberInDevAndProd(source)\n        };\n    }\n    function pushTreeFork(workInProgress, totalChildren) {\n        warnIfNotHydrating();\n        forkStack[forkStackIndex++] = treeForkCount;\n        forkStack[forkStackIndex++] = treeForkProvider;\n        treeForkProvider = workInProgress;\n        treeForkCount = totalChildren;\n    }\n    function pushTreeId(workInProgress, totalChildren, index) {\n        warnIfNotHydrating();\n        idStack[idStackIndex++] = treeContextId;\n        idStack[idStackIndex++] = treeContextOverflow;\n        idStack[idStackIndex++] = treeContextProvider;\n        treeContextProvider = workInProgress;\n        var baseIdWithLeadingBit = treeContextId;\n        workInProgress = treeContextOverflow;\n        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n        baseIdWithLeadingBit &= ~(1 << baseLength);\n        index += 1;\n        var length = 32 - clz32(totalChildren) + baseLength;\n        if (30 < length) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);\n            baseIdWithLeadingBit >>= numberOfOverflowBits;\n            baseLength -= numberOfOverflowBits;\n            treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;\n            treeContextOverflow = length + workInProgress;\n        } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;\n    }\n    function pushMaterializedTreeId(workInProgress) {\n        warnIfNotHydrating();\n        null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n    }\n    function popTreeContext(workInProgress) {\n        for(; workInProgress === treeForkProvider;)treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;\n        for(; workInProgress === treeContextProvider;)treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;\n    }\n    function warnIfNotHydrating() {\n        isHydrating || console.error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n    }\n    function requiredContext(c) {\n        null === c && console.error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n        return c;\n    }\n    function pushHostContainer(fiber, nextRootInstance) {\n        push(rootInstanceStackCursor, nextRootInstance, fiber);\n        push(contextFiberStackCursor, fiber, fiber);\n        push(contextStackCursor, null, fiber);\n        nextRootInstance = getRootHostContext(nextRootInstance);\n        pop(contextStackCursor, fiber);\n        push(contextStackCursor, nextRootInstance, fiber);\n    }\n    function popHostContainer(fiber) {\n        pop(contextStackCursor, fiber);\n        pop(contextFiberStackCursor, fiber);\n        pop(rootInstanceStackCursor, fiber);\n    }\n    function getHostContext() {\n        return requiredContext(contextStackCursor.current);\n    }\n    function pushHostContext(fiber) {\n        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);\n        var context = requiredContext(contextStackCursor.current), nextContext = getChildHostContext(context, fiber.type);\n        context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));\n    }\n    function popHostContext(fiber) {\n        contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));\n        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), isPrimaryRenderer ? HostTransitionContext._currentValue = NotPendingTransition : HostTransitionContext._currentValue2 = NotPendingTransition);\n    }\n    function findNotableNode(node, indent) {\n        return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;\n    }\n    function indentation(indent) {\n        return \"  \" + \"  \".repeat(indent);\n    }\n    function added(indent) {\n        return \"+ \" + \"  \".repeat(indent);\n    }\n    function removed(indent) {\n        return \"- \" + \"  \".repeat(indent);\n    }\n    function describeFiberType(fiber) {\n        switch(fiber.tag){\n            case 26:\n            case 27:\n            case 5:\n                return fiber.type;\n            case 16:\n                return \"Lazy\";\n            case 13:\n                return \"Suspense\";\n            case 19:\n                return \"SuspenseList\";\n            case 0:\n            case 15:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            case 11:\n                return fiber = fiber.type.render, fiber.displayName || fiber.name || null;\n            case 1:\n                return fiber = fiber.type, fiber.displayName || fiber.name || null;\n            default:\n                return null;\n        }\n    }\n    function describeTextNode(content, maxLength) {\n        return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{\"...\"}' : \"{\" + content.slice(0, maxLength - 7) + '...\"}' : \"{\" + content + \"}\") : content.length > maxLength ? 5 > maxLength ? '{\"...\"}' : content.slice(0, maxLength - 3) + \"...\" : content;\n    }\n    function describeTextDiff(clientText, serverProps, indent) {\n        var maxLength = 120 - 2 * indent;\n        if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n        if (\"string\" === typeof serverProps) {\n            for(var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);\n            firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = \"...\" + clientText.slice(firstDiff - 8), serverProps = \"...\" + serverProps.slice(firstDiff - 8));\n            return added(indent) + describeTextNode(clientText, maxLength) + \"\\n\" + removed(indent) + describeTextNode(serverProps, maxLength) + \"\\n\";\n        }\n        return indentation(indent) + describeTextNode(clientText, maxLength) + \"\\n\";\n    }\n    function objectName(object) {\n        return Object.prototype.toString.call(object).replace(/^\\[object (.*)\\]$/, function(m, p0) {\n            return p0;\n        });\n    }\n    function describeValue(value, maxLength) {\n        switch(typeof value){\n            case \"string\":\n                return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '\"...\"' : value.slice(0, maxLength - 4) + '...\"' : value;\n            case \"object\":\n                if (null === value) return \"null\";\n                if (isArrayImpl(value)) return \"[...]\";\n                if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? \"<\" + maxLength + \">\" : \"<...>\";\n                var name = objectName(value);\n                if (\"Object\" === name) {\n                    name = \"\";\n                    maxLength -= 2;\n                    for(var propName in value)if (value.hasOwnProperty(propName)) {\n                        var jsonPropName = JSON.stringify(propName);\n                        jsonPropName !== '\"' + propName + '\"' && (propName = jsonPropName);\n                        maxLength -= propName.length - 2;\n                        jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);\n                        maxLength -= jsonPropName.length;\n                        if (0 > maxLength) {\n                            name += \"\" === name ? \"...\" : \", ...\";\n                            break;\n                        }\n                        name += (\"\" === name ? \"\" : \",\") + propName + \":\" + jsonPropName;\n                    }\n                    return \"{\" + name + \"}\";\n                }\n                return name;\n            case \"function\":\n                return (maxLength = value.displayName || value.name) ? \"function \" + maxLength : \"function\";\n            default:\n                return String(value);\n        }\n    }\n    function describePropValue(value, maxLength) {\n        return \"string\" !== typeof value || needsEscaping.test(value) ? \"{\" + describeValue(value, maxLength - 2) + \"}\" : value.length > maxLength - 2 ? 5 > maxLength ? '\"...\"' : '\"' + value.slice(0, maxLength - 5) + '...\"' : '\"' + value + '\"';\n    }\n    function describeExpandedElement(type, props, rowPrefix) {\n        var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;\n        for(propName in props)if (props.hasOwnProperty(propName) && \"children\" !== propName) {\n            var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);\n            remainingRowLength -= propName.length + propValue.length + 2;\n            properties.push(propName + \"=\" + propValue);\n        }\n        return 0 === properties.length ? rowPrefix + \"<\" + type + \">\\n\" : 0 < remainingRowLength ? rowPrefix + \"<\" + type + \" \" + properties.join(\" \") + \">\\n\" : rowPrefix + \"<\" + type + \"\\n\" + rowPrefix + \"  \" + properties.join(\"\\n\" + rowPrefix + \"  \") + \"\\n\" + rowPrefix + \">\\n\";\n    }\n    function describePropertiesDiff(clientObject, serverObject, indent) {\n        var properties = \"\", remainingServerProperties = assign({}, serverObject), propName;\n        for(propName in clientObject)if (clientObject.hasOwnProperty(propName)) {\n            delete remainingServerProperties[propName];\n            var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);\n            serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\", properties += removed(indent) + propName + \": \" + maxLength + \"\\n\") : properties += added(indent) + propName + \": \" + clientPropValue + \"\\n\";\n        }\n        for(var _propName in remainingServerProperties)remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + \": \" + clientObject + \"\\n\");\n        return properties;\n    }\n    function describeElementDiff(type, clientProps, serverProps, indent) {\n        var content = \"\", serverPropNames = new Map();\n        for(propName$jscomp$0 in serverProps)serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);\n        if (1 === serverPropNames.size && serverPropNames.has(\"children\")) content += describeExpandedElement(type, clientProps, indentation(indent));\n        else {\n            for(var _propName2 in clientProps)if (clientProps.hasOwnProperty(_propName2) && \"children\" !== _propName2) {\n                var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                if (void 0 !== serverPropName) {\n                    serverPropNames.delete(_propName2.toLowerCase());\n                    var propName$jscomp$0 = clientProps[_propName2];\n                    serverPropName = serverProps[serverPropName];\n                    var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);\n                    maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);\n                    \"object\" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && \"object\" === typeof serverPropName && null !== serverPropName && \"Object\" === objectName(propName$jscomp$0) && \"Object\" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf(\"...\") || -1 < maxLength$jscomp$0.indexOf(\"...\")) ? content += indentation(indent + 1) + _propName2 + \"={{\\n\" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + \"}}\\n\" : (content += added(indent + 1) + _propName2 + \"=\" + clientPropValue + \"\\n\", content += removed(indent + 1) + _propName2 + \"=\" + maxLength$jscomp$0 + \"\\n\");\n                } else content += indentation(indent + 1) + _propName2 + \"=\" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + \"\\n\";\n            }\n            serverPropNames.forEach(function(propName) {\n                if (\"children\" !== propName) {\n                    var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;\n                    content += removed(indent + 1) + propName + \"=\" + describePropValue(serverProps[propName], maxLength) + \"\\n\";\n                }\n            });\n            content = \"\" === content ? indentation(indent) + \"<\" + type + \">\\n\" : indentation(indent) + \"<\" + type + \"\\n\" + content + indentation(indent) + \">\\n\";\n        }\n        type = serverProps.children;\n        clientProps = clientProps.children;\n        if (\"string\" === typeof type || \"number\" === typeof type || \"bigint\" === typeof type) {\n            serverPropNames = \"\";\n            if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) serverPropNames = \"\" + clientProps;\n            content += describeTextDiff(serverPropNames, \"\" + type, indent + 1);\n        } else if (\"string\" === typeof clientProps || \"number\" === typeof clientProps || \"bigint\" === typeof clientProps) content = null == type ? content + describeTextDiff(\"\" + clientProps, null, indent + 1) : content + describeTextDiff(\"\" + clientProps, void 0, indent + 1);\n        return content;\n    }\n    function describeSiblingFiber(fiber, indent) {\n        var type = describeFiberType(fiber);\n        if (null === type) {\n            type = \"\";\n            for(fiber = fiber.child; fiber;)type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;\n            return type;\n        }\n        return indentation(indent) + \"<\" + type + \">\\n\";\n    }\n    function describeNode(node, indent) {\n        var skipToNode = findNotableNode(node, indent);\n        if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + \"...\\n\" + describeNode(skipToNode, indent + 1);\n        skipToNode = \"\";\n        var debugInfo = node.fiber._debugInfo;\n        if (debugInfo) for(var i = 0; i < debugInfo.length; i++){\n            var serverComponentName = debugInfo[i].name;\n            \"string\" === typeof serverComponentName && (skipToNode += indentation(indent) + \"<\" + serverComponentName + \">\\n\", indent++);\n        }\n        debugInfo = \"\";\n        i = node.fiber.pendingProps;\n        if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;\n        else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {\n            debugInfo = indent;\n            var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = \"\";\n            for(propName in i)if (i.hasOwnProperty(propName) && \"children\" !== propName) {\n                var propValue = describePropValue(i[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (0 > maxLength) {\n                    content += \" ...\";\n                    break;\n                }\n                content += \" \" + propName + \"=\" + propValue;\n            }\n            debugInfo = indentation(debugInfo) + \"<\" + serverComponentName + content + \">\\n\";\n            indent++;\n        } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : \"string\" === typeof node.serverProps ? console.error(\"Should not have matched a non HostText fiber to a Text node. This is a bug in React.\") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);\n        var propName = \"\";\n        i = node.fiber.child;\n        for(serverComponentName = 0; i && serverComponentName < node.children.length;)maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;\n        i && 0 < node.children.length && (propName += indentation(indent) + \"...\\n\");\n        i = node.serverTail;\n        null === node.serverProps && indent--;\n        for(node = 0; node < i.length; node++)serverComponentName = i[node], propName = \"string\" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + \"\\n\") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));\n        return skipToNode + debugInfo + propName;\n    }\n    function describeDiff(rootNode) {\n        try {\n            return \"\\n\\n\" + describeNode(rootNode, 0);\n        } catch (x) {\n            return \"\";\n        }\n    }\n    function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n        if (null === fiber.return) {\n            if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {\n                fiber: fiber,\n                children: [],\n                serverProps: void 0,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            else {\n                if (hydrationDiffRootDEV.fiber !== fiber) throw Error(\"Saw multiple hydration diff roots in a pass. This is a bug in React.\");\n                hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);\n            }\n            return hydrationDiffRootDEV;\n        }\n        var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;\n        if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;\n        distanceFromLeaf = {\n            fiber: fiber,\n            children: [],\n            serverProps: void 0,\n            serverTail: [],\n            distanceFromLeaf: distanceFromLeaf\n        };\n        siblings.push(distanceFromLeaf);\n        return distanceFromLeaf;\n    }\n    function warnNonHydratedInstance(fiber, rejectedCandidate) {\n        didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));\n    }\n    function throwOnHydrationMismatch(fiber) {\n        var diff = \"\", diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));\n        queueHydrationError(createCapturedValueAtFiber(Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\nhttps://react.dev/link/hydration-mismatch\" + diff), fiber));\n        throw HydrationMismatchException;\n    }\n    function prepareToHydrateHostInstance(fiber, hostContext) {\n        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n        hydrateInstance(fiber.stateNode, fiber.type, fiber.memoizedProps, hostContext, fiber) || throwOnHydrationMismatch(fiber);\n    }\n    function popToNextHostParent(fiber) {\n        for(hydrationParentFiber = fiber.return; hydrationParentFiber;)switch(hydrationParentFiber.tag){\n            case 3:\n            case 27:\n                rootOrSingletonContext = !0;\n                return;\n            case 5:\n            case 13:\n                rootOrSingletonContext = !1;\n                return;\n            default:\n                hydrationParentFiber = hydrationParentFiber.return;\n        }\n    }\n    function popHydrationState(fiber) {\n        if (!supportsHydration || fiber !== hydrationParentFiber) return !1;\n        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;\n        var shouldClear = !1;\n        supportsSingletons ? 3 !== fiber.tag && 27 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0) : 3 !== fiber.tag && (5 !== fiber.tag || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps)) && (shouldClear = !0);\n        if (shouldClear && nextHydratableInstance) {\n            for(shouldClear = nextHydratableInstance; shouldClear;){\n                var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(shouldClear);\n                diffNode.serverTail.push(description);\n                shouldClear = \"Suspense\" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratableSibling(shouldClear);\n            }\n            throwOnHydrationMismatch(fiber);\n        }\n        popToNextHostParent(fiber);\n        if (13 === fiber.tag) {\n            if (!supportsHydration) throw Error(\"Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n            fiber = fiber.memoizedState;\n            fiber = null !== fiber ? fiber.dehydrated : null;\n            if (!fiber) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n            nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);\n        } else nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return !0;\n    }\n    function resetHydrationState() {\n        supportsHydration && (nextHydratableInstance = hydrationParentFiber = null, didSuspendOrErrorDEV = isHydrating = !1);\n    }\n    function queueHydrationError(error) {\n        null === hydrationErrors ? hydrationErrors = [\n            error\n        ] : hydrationErrors.push(error);\n    }\n    function emitPendingHydrationWarnings() {\n        var diffRoot = hydrationDiffRootDEV;\n        null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\\n\\n- A server/client branch `if (typeof window !== 'undefined')`.\\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n- Date formatting in a user's locale which doesn't match the server.\\n- External changing data without sending a snapshot of it along with the HTML.\\n- Invalid HTML tag nesting.\\n\\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n\\n%s%s\", \"https://react.dev/link/hydration-mismatch\", diffRoot));\n    }\n    function finishQueueingConcurrentUpdates() {\n        for(var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;){\n            var fiber = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var queue = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var update = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            var lane = concurrentQueues[i];\n            concurrentQueues[i++] = null;\n            if (null !== queue && null !== update) {\n                var pending = queue.pending;\n                null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n                queue.pending = update;\n            }\n            0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n        }\n    }\n    function enqueueUpdate$1(fiber, queue, update, lane) {\n        concurrentQueues[concurrentQueuesIndex++] = fiber;\n        concurrentQueues[concurrentQueuesIndex++] = queue;\n        concurrentQueues[concurrentQueuesIndex++] = update;\n        concurrentQueues[concurrentQueuesIndex++] = lane;\n        concurrentlyUpdatedLanes |= lane;\n        fiber.lanes |= lane;\n        fiber = fiber.alternate;\n        null !== fiber && (fiber.lanes |= lane);\n    }\n    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n        enqueueUpdate$1(fiber, queue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function enqueueConcurrentRenderForLane(fiber, lane) {\n        enqueueUpdate$1(fiber, null, null, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n        sourceFiber.lanes |= lane;\n        var alternate = sourceFiber.alternate;\n        null !== alternate && (alternate.lanes |= lane);\n        for(var isHidden = !1, parent = sourceFiber.return; null !== parent;)parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)), sourceFiber = parent, parent = parent.return;\n        isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [\n            update\n        ] : sourceFiber.push(update), update.lane = lane | 536870912);\n    }\n    function getRootForUpdatedFiber(sourceFiber) {\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n        nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\"));\n        null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        for(var node = sourceFiber, parent = node.return; null !== parent;)null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;\n        return 3 === node.tag ? node.stateNode : null;\n    }\n    function pushNestedEffectDurations() {\n        var prevEffectDuration = profilerEffectDuration;\n        profilerEffectDuration = 0;\n        return prevEffectDuration;\n    }\n    function popNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration = prevEffectDuration;\n        return elapsedTime;\n    }\n    function bubbleNestedEffectDurations(prevEffectDuration) {\n        var elapsedTime = profilerEffectDuration;\n        profilerEffectDuration += prevEffectDuration;\n        return elapsedTime;\n    }\n    function startProfilerTimer(fiber) {\n        profilerStartTime = now();\n        0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);\n    }\n    function stopProfilerTimerIfRunningAndRecordDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            fiber.selfBaseDuration = elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            profilerStartTime = -1;\n        }\n    }\n    function recordEffectDuration() {\n        if (0 <= profilerStartTime) {\n            var elapsedTime = now() - profilerStartTime;\n            profilerStartTime = -1;\n            profilerEffectDuration += elapsedTime;\n        }\n    }\n    function startEffectTimer() {\n        profilerStartTime = now();\n    }\n    function transferActualDuration(fiber) {\n        for(var child = fiber.child; child;)fiber.actualDuration += child.actualDuration, child = child.sibling;\n    }\n    function ensureRootIsScheduled(root) {\n        root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);\n        mightHavePendingSyncWork = !0;\n        null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));\n    }\n    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n        if (!isFlushingWork && mightHavePendingSyncWork) {\n            isFlushingWork = !0;\n            do {\n                var didPerformSomeWork = !1;\n                for(var root = firstScheduledRoot; null !== root;){\n                    if (!onlyLegacy) if (0 !== syncTransitionLanes) {\n                        var pendingLanes = root.pendingLanes;\n                        if (0 === pendingLanes) var nextLanes = 0;\n                        else {\n                            var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes;\n                            nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;\n                            nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);\n                            nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;\n                        }\n                        0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = !1;\n        }\n    }\n    function processRootScheduleInMicrotask() {\n        mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;\n        var syncTransitionLanes = 0;\n        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);\n        for(var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;){\n            var next = root.next, nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n            if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);\n            else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;\n            root = next;\n        }\n        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n    }\n    function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n        for(var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];\n            if (-1 === expirationTime) {\n                if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);\n            } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n            lanes &= ~lane;\n        }\n        currentTime = workInProgressRoot;\n        suspendedLanes = workInProgressRootRenderLanes;\n        suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);\n        pingedLanes = root.callbackNode;\n        if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;\n        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {\n            currentTime = suspendedLanes & -suspendedLanes;\n            if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode$1) cancelCallback(pingedLanes);\n            else return currentTime;\n            switch(lanesToEventPriority(suspendedLanes)){\n                case 2:\n                case 8:\n                    suspendedLanes = UserBlockingPriority;\n                    break;\n                case 32:\n                    suspendedLanes = NormalPriority$1;\n                    break;\n                case 268435456:\n                    suspendedLanes = IdlePriority;\n                    break;\n                default:\n                    suspendedLanes = NormalPriority$1;\n            }\n            pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n            null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode$1) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n            root.callbackPriority = currentTime;\n            root.callbackNode = suspendedLanes;\n            return currentTime;\n        }\n        null !== pingedLanes && cancelCallback(pingedLanes);\n        root.callbackPriority = 2;\n        root.callbackNode = null;\n        return 2;\n    }\n    function performWorkOnRootViaSchedulerTask(root, didTimeout) {\n        nestedUpdateScheduled = currentUpdateIsNested = !1;\n        var originalCallbackNode = root.callbackNode;\n        if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;\n        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);\n        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n        performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n        scheduleTaskForRootDuringMicrotask(root, now$1());\n        return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;\n    }\n    function performSyncWorkOnRoot(root, lanes) {\n        if (flushPassiveEffects()) return null;\n        currentUpdateIsNested = nestedUpdateScheduled;\n        nestedUpdateScheduled = !1;\n        performWorkOnRoot(root, lanes, !0);\n    }\n    function cancelCallback(callbackNode) {\n        callbackNode !== fakeActCallbackNode$1 && null !== callbackNode && cancelCallback$1(callbackNode);\n    }\n    function scheduleImmediateTask(cb) {\n        null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {\n            cb();\n            return null;\n        });\n        supportsMicrotasks ? scheduleMicrotask(function() {\n            (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();\n        }) : scheduleCallback$3(ImmediatePriority, cb);\n    }\n    function requestTransitionLane() {\n        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());\n        return currentEventTransitionLane;\n    }\n    function entangleAsyncAction(transition, thenable) {\n        if (null === currentEntangledListeners) {\n            var entangledListeners = currentEntangledListeners = [];\n            currentEntangledPendingCount = 0;\n            currentEntangledLane = requestTransitionLane();\n            currentEntangledActionThenable = {\n                status: \"pending\",\n                value: void 0,\n                then: function(resolve) {\n                    entangledListeners.push(resolve);\n                }\n            };\n        }\n        currentEntangledPendingCount++;\n        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n        return thenable;\n    }\n    function pingEngtangledActionScope() {\n        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {\n            null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = \"fulfilled\");\n            var listeners = currentEntangledListeners;\n            currentEntangledListeners = null;\n            currentEntangledLane = 0;\n            currentEntangledActionThenable = null;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])();\n        }\n    }\n    function chainThenableValue(thenable, result) {\n        var listeners = [], thenableWithOverride = {\n            status: \"pending\",\n            value: null,\n            reason: null,\n            then: function(resolve) {\n                listeners.push(resolve);\n            }\n        };\n        thenable.then(function() {\n            thenableWithOverride.status = \"fulfilled\";\n            thenableWithOverride.value = result;\n            for(var i = 0; i < listeners.length; i++)(0, listeners[i])(result);\n        }, function(error) {\n            thenableWithOverride.status = \"rejected\";\n            thenableWithOverride.reason = error;\n            for(error = 0; error < listeners.length; error++)(0, listeners[error])(void 0);\n        });\n        return thenableWithOverride;\n    }\n    function initializeUpdateQueue(fiber) {\n        fiber.updateQueue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n                pending: null,\n                lanes: 0,\n                hiddenCallbacks: null\n            },\n            callbacks: null\n        };\n    }\n    function cloneUpdateQueue(current, workInProgress) {\n        current = current.updateQueue;\n        workInProgress.updateQueue === current && (workInProgress.updateQueue = {\n            baseState: current.baseState,\n            firstBaseUpdate: current.firstBaseUpdate,\n            lastBaseUpdate: current.lastBaseUpdate,\n            shared: current.shared,\n            callbacks: null\n        });\n    }\n    function createUpdate(lane) {\n        return {\n            lane: lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n        };\n    }\n    function enqueueUpdate(fiber, update, lane) {\n        var updateQueue = fiber.updateQueue;\n        if (null === updateQueue) return null;\n        updateQueue = updateQueue.shared;\n        if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {\n            var componentName = getComponentNameFromFiber(fiber);\n            console.error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\\n\\nPlease update the following component: %s\", componentName);\n            didWarnUpdateInsideUpdate = !0;\n        }\n        if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;\n        enqueueUpdate$1(fiber, updateQueue, update, lane);\n        return getRootForUpdatedFiber(fiber);\n    }\n    function entangleTransitions(root, fiber, lane) {\n        fiber = fiber.updateQueue;\n        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {\n            var queueLanes = fiber.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            fiber.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n        var queue = workInProgress.updateQueue, current = workInProgress.alternate;\n        if (null !== current && (current = current.updateQueue, queue === current)) {\n            var newFirst = null, newLast = null;\n            queue = queue.firstBaseUpdate;\n            if (null !== queue) {\n                do {\n                    var clone = {\n                        lane: queue.lane,\n                        tag: queue.tag,\n                        payload: queue.payload,\n                        callback: null,\n                        next: null\n                    };\n                    null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;\n                    queue = queue.next;\n                }while (null !== queue);\n                null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;\n            } else newFirst = newLast = capturedUpdate;\n            queue = {\n                baseState: current.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: current.shared,\n                callbacks: current.callbacks\n            };\n            workInProgress.updateQueue = queue;\n            return;\n        }\n        workInProgress = queue.lastBaseUpdate;\n        null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;\n        queue.lastBaseUpdate = capturedUpdate;\n    }\n    function suspendIfUpdateReadFromEntangledAsyncAction() {\n        if (didReadFromEntangledAsyncAction) {\n            var entangledActionThenable = currentEntangledActionThenable;\n            if (null !== entangledActionThenable) throw entangledActionThenable;\n        }\n    }\n    function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {\n        didReadFromEntangledAsyncAction = !1;\n        var queue = workInProgress.updateQueue;\n        hasForceUpdate = !1;\n        currentlyProcessingQueue = queue.shared;\n        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;\n        if (null !== pendingQueue) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;\n            lastBaseUpdate = lastPendingUpdate;\n            var current = workInProgress.alternate;\n            null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));\n        }\n        if (null !== firstBaseUpdate) {\n            var newState = queue.baseState;\n            lastBaseUpdate = 0;\n            current = firstPendingUpdate = lastPendingUpdate = null;\n            pendingQueue = firstBaseUpdate;\n            do {\n                var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;\n                if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    null !== current && (current = current.next = {\n                        lane: 0,\n                        tag: pendingQueue.tag,\n                        payload: pendingQueue.payload,\n                        callback: null,\n                        next: null\n                    });\n                    a: {\n                        updateLane = workInProgress;\n                        var partialState = pendingQueue;\n                        var nextProps = props, instance = instance$jscomp$0;\n                        switch(partialState.tag){\n                            case ReplaceState:\n                                partialState = partialState.payload;\n                                if (\"function\" === typeof partialState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    var nextState = partialState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            partialState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                    newState = nextState;\n                                    break a;\n                                }\n                                newState = partialState;\n                                break a;\n                            case CaptureUpdate:\n                                updateLane.flags = updateLane.flags & -65537 | 128;\n                            case UpdateState:\n                                nextState = partialState.payload;\n                                if (\"function\" === typeof nextState) {\n                                    isDisallowedContextReadInDEV = !0;\n                                    partialState = nextState.call(instance, newState, nextProps);\n                                    if (updateLane.mode & 8) {\n                                        setIsStrictModeForDevtools(!0);\n                                        try {\n                                            nextState.call(instance, newState, nextProps);\n                                        } finally{\n                                            setIsStrictModeForDevtools(!1);\n                                        }\n                                    }\n                                    isDisallowedContextReadInDEV = !1;\n                                } else partialState = nextState;\n                                if (null === partialState || void 0 === partialState) break a;\n                                newState = assign({}, newState, partialState);\n                                break a;\n                            case ForceUpdate:\n                                hasForceUpdate = !0;\n                        }\n                    }\n                    updateLane = pendingQueue.callback;\n                    null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [\n                        updateLane\n                    ] : isHiddenUpdate.push(updateLane));\n                } else isHiddenUpdate = {\n                    lane: updateLane,\n                    tag: pendingQueue.tag,\n                    payload: pendingQueue.payload,\n                    callback: pendingQueue.callback,\n                    next: null\n                }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;\n                pendingQueue = pendingQueue.next;\n                if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;\n                else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;\n            }while (1);\n            null === current && (lastPendingUpdate = newState);\n            queue.baseState = lastPendingUpdate;\n            queue.firstBaseUpdate = firstPendingUpdate;\n            queue.lastBaseUpdate = current;\n            null === firstBaseUpdate && (queue.shared.lanes = 0);\n            workInProgressRootSkippedLanes |= lastBaseUpdate;\n            workInProgress.lanes = lastBaseUpdate;\n            workInProgress.memoizedState = newState;\n        }\n        currentlyProcessingQueue = null;\n    }\n    function callCallback(callback, context) {\n        if (\"function\" !== typeof callback) throw Error(\"Invalid argument passed as callback. Expected a function. Instead received: \" + callback);\n        callback.call(context);\n    }\n    function commitHiddenCallbacks(updateQueue, context) {\n        var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n        if (null !== hiddenCallbacks) for(updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)callCallback(hiddenCallbacks[updateQueue], context);\n    }\n    function commitCallbacks(updateQueue, context) {\n        var callbacks = updateQueue.callbacks;\n        if (null !== callbacks) for(updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)callCallback(callbacks[updateQueue], context);\n    }\n    function shallowEqual(objA, objB) {\n        if (objectIs(objA, objB)) return !0;\n        if (\"object\" !== typeof objA || null === objA || \"object\" !== typeof objB || null === objB) return !1;\n        var keysA = Object.keys(objA), keysB = Object.keys(objB);\n        if (keysA.length !== keysB.length) return !1;\n        for(keysB = 0; keysB < keysA.length; keysB++){\n            var currentKey = keysA[keysB];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;\n        }\n        return !0;\n    }\n    function createThenableState() {\n        return {\n            didWarnAboutUncachedPromise: !1,\n            thenables: []\n        };\n    }\n    function isThenableResolved(thenable) {\n        thenable = thenable.status;\n        return \"fulfilled\" === thenable || \"rejected\" === thenable;\n    }\n    function noop$1() {}\n    function trackUsedThenable(thenableState, thenable, index) {\n        null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);\n        var trackedThenables = thenableState.thenables;\n        index = trackedThenables[index];\n        void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error(\"A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.\")), thenable.then(noop$1, noop$1), thenable = index);\n        switch(thenable.status){\n            case \"fulfilled\":\n                return thenable.value;\n            case \"rejected\":\n                throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n            default:\n                if (\"string\" === typeof thenable.status) thenable.then(noop$1, noop$1);\n                else {\n                    thenableState = workInProgressRoot;\n                    if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n                    thenableState = thenable;\n                    thenableState.status = \"pending\";\n                    thenableState.then(function(fulfilledValue) {\n                        if (\"pending\" === thenable.status) {\n                            var fulfilledThenable = thenable;\n                            fulfilledThenable.status = \"fulfilled\";\n                            fulfilledThenable.value = fulfilledValue;\n                        }\n                    }, function(error) {\n                        if (\"pending\" === thenable.status) {\n                            var rejectedThenable = thenable;\n                            rejectedThenable.status = \"rejected\";\n                            rejectedThenable.reason = error;\n                        }\n                    });\n                }\n                switch(thenable.status){\n                    case \"fulfilled\":\n                        return thenable.value;\n                    case \"rejected\":\n                        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;\n                }\n                suspendedThenable = thenable;\n                needsToResetSuspendedThenableDEV = !0;\n                throw SuspenseException;\n        }\n    }\n    function getSuspendedThenable() {\n        if (null === suspendedThenable) throw Error(\"Expected a suspended thenable. This is a bug in React. Please file an issue.\");\n        var thenable = suspendedThenable;\n        suspendedThenable = null;\n        needsToResetSuspendedThenableDEV = !1;\n        return thenable;\n    }\n    function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n        if (rejectedReason === SuspenseException) throw Error(\"Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\");\n    }\n    function pushDebugInfo(debugInfo) {\n        var previousDebugInfo = currentDebugInfo;\n        null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));\n        return previousDebugInfo;\n    }\n    function validateFragmentProps(element, fiber, returnFiber) {\n        for(var keys = Object.keys(element.props), i = 0; i < keys.length; i++){\n            var key = keys[i];\n            if (\"children\" !== key && \"key\" !== key) {\n                null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);\n                runWithFiberInDEV(fiber, function(erroredKey) {\n                    console.error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", erroredKey);\n                }, key);\n                break;\n            }\n        }\n    }\n    function unwrapThenable(thenable) {\n        var index = thenableIndexCounter$1;\n        thenableIndexCounter$1 += 1;\n        null === thenableState$1 && (thenableState$1 = createThenableState());\n        return trackUsedThenable(thenableState$1, thenable, index);\n    }\n    function coerceRef(workInProgress, element) {\n        element = element.props.ref;\n        workInProgress.ref = void 0 !== element ? element : null;\n    }\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\\n- Multiple copies of the \"react\" package is used.\\n- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n- A compiler tries to \"inline\" JSX instead of using the runtime.');\n        returnFiber = Object.prototype.toString.call(newChild);\n        throw Error(\"Objects are not valid as a React child (found: \" + (\"[object Object]\" === returnFiber ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : returnFiber) + \"). If you meant to render a collection of children, use an array instead.\");\n    }\n    function warnOnFunctionType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || \"Component\", 3 === returnFiber.tag ? console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  root.render(%s)\", invalidChild, invalidChild, invalidChild) : console.error(\"Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\\n  <%s>{%s}</%s>\", invalidChild, invalidChild, parentName, invalidChild, parentName));\n    }\n    function warnOnSymbolType(returnFiber, invalidChild) {\n        var parentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n        ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(\"Symbols are not valid as a React child.\\n  root.render(%s)\", invalidChild) : console.error(\"Symbols are not valid as a React child.\\n  <%s>%s</%s>\", parentName, invalidChild, parentName));\n    }\n    function createChildReconciler(shouldTrackSideEffects) {\n        function deleteChild(returnFiber, childToDelete) {\n            if (shouldTrackSideEffects) {\n                var deletions = returnFiber.deletions;\n                null === deletions ? (returnFiber.deletions = [\n                    childToDelete\n                ], returnFiber.flags |= 16) : deletions.push(childToDelete);\n            }\n        }\n        function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) return null;\n            for(; null !== currentFirstChild;)deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return null;\n        }\n        function mapRemainingChildren(currentFirstChild) {\n            for(var existingChildren = new Map(); null !== currentFirstChild;)null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;\n            return existingChildren;\n        }\n        function useFiber(fiber, pendingProps) {\n            fiber = createWorkInProgress(fiber, pendingProps);\n            fiber.index = 0;\n            fiber.sibling = null;\n            return fiber;\n        }\n        function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;\n            newIndex = newFiber.alternate;\n            if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;\n            newFiber.flags |= 33554434;\n            return lastPlacedIndex;\n        }\n        function placeSingleChild(newFiber) {\n            shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);\n            return newFiber;\n        }\n        function updateTextNode(returnFiber, current, textContent, lanes) {\n            if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, textContent);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateElement(returnFiber, current, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;\n            if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || \"object\" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;\n            current = createFiberFromElement(element, returnFiber.mode, lanes);\n            coerceRef(current, element);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updatePortal(returnFiber, current, portal, lanes) {\n            if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, portal.children || []);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function updateFragment(returnFiber, current, fragment, lanes, key) {\n            if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;\n            current = useFiber(current, fragment);\n            current.return = returnFiber;\n            current._debugInfo = currentDebugInfo;\n            return current;\n        }\n        function createChild(returnFiber, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return newChild = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                    case REACT_PORTAL_TYPE:\n                        return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = createChild(returnFiber, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = null !== oldFiber ? oldFiber.key : null;\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;\n                    case REACT_PORTAL_TYPE:\n                        return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;\n                    case REACT_LAZY_TYPE:\n                        return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) {\n                    if (null !== key) return null;\n                    key = pushDebugInfo(newChild._debugInfo);\n                    returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n                    currentDebugInfo = key;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);\n                    case REACT_LAZY_TYPE:\n                        var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);\n                        newChild = callLazyInitInDEV(newChild);\n                        returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);\n                        currentDebugInfo = _prevDebugInfo7;\n                        return returnFiber;\n                }\n                if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;\n                if (\"function\" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return null;\n        }\n        function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {\n            if (\"object\" !== typeof child || null === child) return knownKeys;\n            switch(child.$$typeof){\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                    warnForMissingKey(returnFiber, workInProgress, child);\n                    var key = child.key;\n                    if (\"string\" !== typeof key) break;\n                    if (null === knownKeys) {\n                        knownKeys = new Set();\n                        knownKeys.add(key);\n                        break;\n                    }\n                    if (!knownKeys.has(key)) {\n                        knownKeys.add(key);\n                        break;\n                    }\n                    runWithFiberInDEV(workInProgress, function() {\n                        console.error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \\u2014 the behavior is unsupported and could change in a future version.\", key);\n                    });\n                    break;\n                case REACT_LAZY_TYPE:\n                    child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);\n            }\n            return knownKeys;\n        }\n        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            for(var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; newIdx < newChildren.length; newIdx++)oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {\n            if (null == newChildren) throw Error(\"An iterable object provided no iterator.\");\n            for(var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()){\n                oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;\n                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n                if (null === newFiber) {\n                    null === oldFiber && (oldFiber = nextOldFiber);\n                    break;\n                }\n                knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);\n                shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);\n                currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n                null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;\n                previousNewFiber = newFiber;\n                oldFiber = nextOldFiber;\n            }\n            if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;\n            if (null === oldFiber) {\n                for(; !step.done; newIdx++, step = newChildren.next())oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);\n                isHydrating && pushTreeFork(returnFiber, newIdx);\n                return resultingFirstChild;\n            }\n            for(oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);\n            shouldTrackSideEffects && oldFiber.forEach(function(child) {\n                return deleteChild(returnFiber, child);\n            });\n            isHydrating && pushTreeFork(returnFiber, newIdx);\n            return resultingFirstChild;\n        }\n        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {\n            \"object\" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);\n            if (\"object\" === typeof newChild && null !== newChild) {\n                switch(newChild.$$typeof){\n                    case REACT_ELEMENT_TYPE:\n                        var prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                        a: {\n                            for(var key = newChild.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === key) {\n                                    key = newChild.type;\n                                    if (key === REACT_FRAGMENT_TYPE) {\n                                        if (7 === currentFirstChild.tag) {\n                                            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                            lanes = useFiber(currentFirstChild, newChild.props.children);\n                                            lanes.return = returnFiber;\n                                            lanes._debugOwner = newChild._owner;\n                                            lanes._debugInfo = currentDebugInfo;\n                                            validateFragmentProps(newChild, lanes, returnFiber);\n                                            returnFiber = lanes;\n                                            break a;\n                                        }\n                                    } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || \"object\" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {\n                                        deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                        lanes = useFiber(currentFirstChild, newChild.props);\n                                        coerceRef(lanes, newChild);\n                                        lanes.return = returnFiber;\n                                        lanes._debugOwner = newChild._owner;\n                                        lanes._debugInfo = currentDebugInfo;\n                                        returnFiber = lanes;\n                                        break a;\n                                    }\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                } else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);\n                        }\n                        returnFiber = placeSingleChild(returnFiber);\n                        currentDebugInfo = prevDebugInfo;\n                        return returnFiber;\n                    case REACT_PORTAL_TYPE:\n                        a: {\n                            prevDebugInfo = newChild;\n                            for(newChild = prevDebugInfo.key; null !== currentFirstChild;){\n                                if (currentFirstChild.key === newChild) if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);\n                                    lanes.return = returnFiber;\n                                    returnFiber = lanes;\n                                    break a;\n                                } else {\n                                    deleteRemainingChildren(returnFiber, currentFirstChild);\n                                    break;\n                                }\n                                else deleteChild(returnFiber, currentFirstChild);\n                                currentFirstChild = currentFirstChild.sibling;\n                            }\n                            lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);\n                            lanes.return = returnFiber;\n                            returnFiber = lanes;\n                        }\n                        return placeSingleChild(returnFiber);\n                    case REACT_LAZY_TYPE:\n                        return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                }\n                if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (getIteratorFn(newChild)) {\n                    prevDebugInfo = pushDebugInfo(newChild._debugInfo);\n                    key = getIteratorFn(newChild);\n                    if (\"function\" !== typeof key) throw Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n                    var newChildren = key.call(newChild);\n                    if (newChildren === newChild) {\n                        if (0 !== returnFiber.tag || \"[object GeneratorFunction]\" !== Object.prototype.toString.call(returnFiber.type) || \"[object Generator]\" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error(\"Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items.\"), didWarnAboutGenerators = !0;\n                    } else newChild.entries !== key || didWarnAboutMaps || (console.error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\"), didWarnAboutMaps = !0);\n                    returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);\n                    currentDebugInfo = prevDebugInfo;\n                    return returnFiber;\n                }\n                if (\"function\" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;\n                if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);\n                throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (\"string\" === typeof newChild && \"\" !== newChild || \"number\" === typeof newChild || \"bigint\" === typeof newChild) return prevDebugInfo = \"\" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);\n            \"function\" === typeof newChild && warnOnFunctionType(returnFiber, newChild);\n            \"symbol\" === typeof newChild && warnOnSymbolType(returnFiber, newChild);\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n        }\n        return function(returnFiber, currentFirstChild, newChild, lanes) {\n            var prevDebugInfo = currentDebugInfo;\n            currentDebugInfo = null;\n            try {\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);\n                thenableState$1 = null;\n                return firstChildFiber;\n            } catch (x) {\n                if (x === SuspenseException) throw x;\n                var fiber = createFiber(29, x, null, returnFiber.mode);\n                fiber.lanes = lanes;\n                fiber.return = returnFiber;\n                var debugInfo = fiber._debugInfo = currentDebugInfo;\n                fiber._debugOwner = returnFiber._debugOwner;\n                if (null != debugInfo) {\n                    for(var i = debugInfo.length - 1; 0 <= i; i--)if (\"string\" === typeof debugInfo[i].stack) {\n                        fiber._debugOwner = debugInfo[i];\n                        break;\n                    }\n                }\n                return fiber;\n            } finally{\n                currentDebugInfo = prevDebugInfo;\n            }\n        };\n    }\n    function pushHiddenContext(fiber, context) {\n        var prevEntangledRenderLanes = entangledRenderLanes;\n        push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, context, fiber);\n        entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;\n    }\n    function reuseHiddenContextOnStack(fiber) {\n        push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);\n        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n    }\n    function popHiddenContext(fiber) {\n        entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n        pop(currentTreeHiddenStackCursor, fiber);\n        pop(prevEntangledRenderLanesCursor, fiber);\n    }\n    function pushPrimaryTreeSuspenseHandler(handler) {\n        var current = handler.alternate;\n        push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);\n        push(suspenseHandlerStackCursor, handler, handler);\n        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));\n    }\n    function pushOffscreenSuspenseHandler(fiber) {\n        if (22 === fiber.tag) {\n            if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {\n                var current = fiber.alternate;\n                null !== current && null !== current.memoizedState && (shellBoundary = fiber);\n            }\n        } else reuseSuspenseHandlerOnStack(fiber);\n    }\n    function reuseSuspenseHandlerOnStack(fiber) {\n        push(suspenseStackCursor, suspenseStackCursor.current, fiber);\n        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);\n    }\n    function popSuspenseHandler(fiber) {\n        pop(suspenseHandlerStackCursor, fiber);\n        shellBoundary === fiber && (shellBoundary = null);\n        pop(suspenseStackCursor, fiber);\n    }\n    function findFirstSuspended(row) {\n        for(var node = row; null !== node;){\n            if (13 === node.tag) {\n                var state = node.memoizedState;\n                if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state))) return node;\n            } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n                if (0 !== (node.flags & 128)) return node;\n            } else if (null !== node.child) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n            }\n            if (node === row) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === row) return null;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n        return null;\n    }\n    function mountHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        null === hookTypesDev ? hookTypesDev = [\n            hookName\n        ] : hookTypesDev.push(hookName);\n    }\n    function updateHookTypesDev() {\n        var hookName = currentHookNameInDev;\n        if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {\n                for(var table = \"\", i = 0; i <= hookTypesUpdateIndexDev; i++){\n                    var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;\n                    for(oldHookName = i + 1 + \". \" + oldHookName; 30 > oldHookName.length;)oldHookName += \" \";\n                    oldHookName += newHookName + \"\\n\";\n                    table += oldHookName;\n                }\n                console.error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n            }\n        }\n    }\n    function checkDepsAreArrayDev(deps) {\n        void 0 === deps || null === deps || isArrayImpl(deps) || console.error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n    }\n    function warnOnUseFormStateInDev() {\n        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n        didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error(\"ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.\", componentName));\n    }\n    function throwInvalidHookError() {\n        throw Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n    }\n    function areHookInputsEqual(nextDeps, prevDeps) {\n        if (ignorePreviousDependencies) return !1;\n        if (null === prevDeps) return console.error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev), !1;\n        nextDeps.length !== prevDeps.length && console.error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n        for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++)if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n        return !0;\n    }\n    function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n        renderLanes = nextRenderLanes;\n        currentlyRenderingFiber$1 = workInProgress;\n        hookTypesDev = null !== current ? current._debugHookTypes : null;\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        if (\"[object AsyncFunction]\" === Object.prototype.toString.call(Component) || \"[object AsyncGeneratorFunction]\" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(\"async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.\"));\n        workInProgress.memoizedState = null;\n        workInProgress.updateQueue = null;\n        workInProgress.lanes = 0;\n        ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;\n        shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & 8) !== NoMode;\n        var children = callComponentInDEV(Component, props, secondArg);\n        shouldDoubleInvokeUserFnsInHooksDEV = !1;\n        didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));\n        if (nextRenderLanes) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        finishRenderingHooks(current, workInProgress);\n        return children;\n    }\n    function finishRenderingHooks(current, workInProgress) {\n        workInProgress._debugHookTypes = hookTypesDev;\n        null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {\n            lanes: 0,\n            firstContext: null,\n            _debugThenableState: thenableState\n        }) : workInProgress.dependencies._debugThenableState = thenableState;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n        renderLanes = 0;\n        hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n        didScheduleRenderPhaseUpdate = !1;\n        thenableIndexCounter = 0;\n        thenableState = null;\n        if (didRenderTooFewHooks) throw Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));\n        needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;\n        current && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Unknown\", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error(\"`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.\")));\n    }\n    function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n        currentlyRenderingFiber$1 = workInProgress;\n        var numberOfReRenders = 0;\n        do {\n            didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n            thenableIndexCounter = 0;\n            didScheduleRenderPhaseUpdateDuringThisPass = !1;\n            if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n            numberOfReRenders += 1;\n            ignorePreviousDependencies = !1;\n            workInProgressHook = currentHook = null;\n            if (null != workInProgress.updateQueue) {\n                var children = workInProgress.updateQueue;\n                children.lastEffect = null;\n                children.events = null;\n                children.stores = null;\n                null != children.memoCache && (children.memoCache.index = 0);\n            }\n            hookTypesUpdateIndexDev = -1;\n            ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n            children = callComponentInDEV(Component, props, secondArg);\n        }while (didScheduleRenderPhaseUpdateDuringThisPass);\n        return children;\n    }\n    function TransitionAwareHostComponent() {\n        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];\n        maybeThenable = \"function\" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;\n        dispatcher = dispatcher.useState()[0];\n        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);\n        return maybeThenable;\n    }\n    function checkDidRenderIdHook() {\n        var didRenderIdHook = 0 !== localIdCounter;\n        localIdCounter = 0;\n        return didRenderIdHook;\n    }\n    function bailoutHooks(current, workInProgress, lanes) {\n        workInProgress.updateQueue = current.updateQueue;\n        workInProgress.flags = (workInProgress.mode & 16) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;\n        current.lanes &= ~lanes;\n    }\n    function resetHooksOnUnwind(workInProgress) {\n        if (didScheduleRenderPhaseUpdate) {\n            for(workInProgress = workInProgress.memoizedState; null !== workInProgress;){\n                var queue = workInProgress.queue;\n                null !== queue && (queue.pending = null);\n                workInProgress = workInProgress.next;\n            }\n            didScheduleRenderPhaseUpdate = !1;\n        }\n        renderLanes = 0;\n        hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n        hookTypesUpdateIndexDev = -1;\n        currentHookNameInDev = null;\n        didScheduleRenderPhaseUpdateDuringThisPass = !1;\n        thenableIndexCounter = localIdCounter = 0;\n        thenableState = null;\n    }\n    function mountWorkInProgressHook() {\n        var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n        };\n        null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;\n        return workInProgressHook;\n    }\n    function updateWorkInProgressHook() {\n        if (null === currentHook) {\n            var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n            nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n        } else nextCurrentHook = currentHook.next;\n        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;\n        if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;\n        else {\n            if (null === nextCurrentHook) {\n                if (null === currentlyRenderingFiber$1.alternate) throw Error(\"Update hook called on initial render. This is likely a bug in React. Please file an issue.\");\n                throw Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            nextCurrentHook = {\n                memoizedState: currentHook.memoizedState,\n                baseState: currentHook.baseState,\n                baseQueue: currentHook.baseQueue,\n                queue: currentHook.queue,\n                next: null\n            };\n            null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;\n        }\n        return workInProgressHook;\n    }\n    function useThenable(thenable) {\n        var index = thenableIndexCounter;\n        thenableIndexCounter += 1;\n        null === thenableState && (thenableState = createThenableState());\n        thenable = trackUsedThenable(thenableState, thenable, index);\n        index = currentlyRenderingFiber$1;\n        null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);\n        return thenable;\n    }\n    function use(usable) {\n        if (null !== usable && \"object\" === typeof usable) {\n            if (\"function\" === typeof usable.then) return useThenable(usable);\n            if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n        }\n        throw Error(\"An unsupported type was passed to use(): \" + String(usable));\n    }\n    function useMemoCache(size) {\n        var memoCache = null, updateQueue = currentlyRenderingFiber$1.updateQueue;\n        null !== updateQueue && (memoCache = updateQueue.memoCache);\n        if (null == memoCache) {\n            var current = currentlyRenderingFiber$1.alternate;\n            null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {\n                data: current.data.map(function(array) {\n                    return array.slice();\n                }),\n                index: 0\n            })));\n        }\n        null == memoCache && (memoCache = {\n            data: [],\n            index: 0\n        });\n        null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);\n        updateQueue.memoCache = memoCache;\n        updateQueue = memoCache.data[memoCache.index];\n        if (void 0 === updateQueue || ignorePreviousDependencies) for(updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n        else updateQueue.length !== size && console.error(\"Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.\", updateQueue.length, size);\n        memoCache.index++;\n        return updateQueue;\n    }\n    function basicStateReducer(state, action) {\n        return \"function\" === typeof action ? action(state) : action;\n    }\n    function mountReducer(reducer, initialArg, init) {\n        var hook = mountWorkInProgressHook();\n        if (void 0 !== init) {\n            var initialState = init(initialArg);\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    init(initialArg);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        } else initialState = initialArg;\n        hook.memoizedState = hook.baseState = initialState;\n        reducer = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n        };\n        hook.queue = reducer;\n        reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);\n        return [\n            hook.memoizedState,\n            reducer\n        ];\n    }\n    function updateReducer(reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateReducerImpl(hook, currentHook, reducer);\n    }\n    function updateReducerImpl(hook, current, reducer) {\n        var queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;\n        if (null !== pendingQueue) {\n            if (null !== baseQueue) {\n                var baseFirst = baseQueue.next;\n                baseQueue.next = pendingQueue.next;\n                pendingQueue.next = baseFirst;\n            }\n            current.baseQueue !== baseQueue && console.error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n            current.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n        }\n        pendingQueue = hook.baseState;\n        if (null === baseQueue) hook.memoizedState = pendingQueue;\n        else {\n            current = baseQueue.next;\n            var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction = !1;\n            do {\n                var updateLane = update.lane & -536870913;\n                if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {\n                    var revertLane = update.revertLane;\n                    if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {\n                        lane: 0,\n                        revertLane: 0,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                    else if ((renderLanes & revertLane) === revertLane) {\n                        update = update.next;\n                        revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);\n                        continue;\n                    } else updateLane = {\n                        lane: 0,\n                        revertLane: update.revertLane,\n                        action: update.action,\n                        hasEagerState: update.hasEagerState,\n                        eagerState: update.eagerState,\n                        next: null\n                    }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;\n                    updateLane = update.action;\n                    shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);\n                    pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);\n                } else revertLane = {\n                    lane: updateLane,\n                    revertLane: update.revertLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;\n                update = update.next;\n            }while (null !== update && update !== current);\n            null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;\n            if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;\n            hook.memoizedState = pendingQueue;\n            hook.baseState = baseFirst;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = pendingQueue;\n        }\n        null === baseQueue && (queue.lanes = 0);\n        return [\n            hook.memoizedState,\n            queue.dispatch\n        ];\n    }\n    function rerenderReducer(reducer) {\n        var hook = updateWorkInProgressHook(), queue = hook.queue;\n        if (null === queue) throw Error(\"Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)\");\n        queue.lastRenderedReducer = reducer;\n        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;\n        if (null !== lastRenderPhaseUpdate) {\n            queue.pending = null;\n            var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            do newState = reducer(newState, update.action), update = update.next;\n            while (update !== lastRenderPhaseUpdate);\n            objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n            hook.memoizedState = newState;\n            null === hook.baseQueue && (hook.baseState = newState);\n            queue.lastRenderedState = newState;\n        }\n        return [\n            newState,\n            dispatch\n        ];\n    }\n    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook();\n        if (isHydrating) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            var nextSnapshot = getServerSnapshot();\n            didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        } else {\n            nextSnapshot = getSnapshot();\n            didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0));\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n        }\n        hook.memoizedState = nextSnapshot;\n        getServerSnapshot = {\n            value: nextSnapshot,\n            getSnapshot: getSnapshot\n        };\n        hook.queue = getServerSnapshot;\n        mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [\n            subscribe\n        ]);\n        fiber.flags |= 2048;\n        pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {\n            destroy: void 0\n        }, null);\n        return nextSnapshot;\n    }\n    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n        var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;\n        if (isHydrating$jscomp$0) {\n            if (void 0 === getServerSnapshot) throw Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            getServerSnapshot = getServerSnapshot();\n        } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {\n            var cachedSnapshot = getSnapshot();\n            objectIs(getServerSnapshot, cachedSnapshot) || (console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\"), didWarnUncachedGetSnapshot = !0);\n        }\n        if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;\n        hook = hook.queue;\n        var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n        updateEffectImpl(2048, Passive, create, [\n            subscribe\n        ]);\n        if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= 2048;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {\n                destroy: void 0\n            }, null);\n            if (null === workInProgressRoot) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n        }\n        return getServerSnapshot;\n    }\n    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n        fiber.flags |= 16384;\n        fiber = {\n            getSnapshot: getSnapshot,\n            value: renderedSnapshot\n        };\n        getSnapshot = currentlyRenderingFiber$1.updateQueue;\n        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [\n            fiber\n        ]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [\n            fiber\n        ] : renderedSnapshot.push(fiber));\n    }\n    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n        inst.value = nextSnapshot;\n        inst.getSnapshot = getSnapshot;\n        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n    }\n    function subscribeToStore(fiber, inst, subscribe) {\n        return subscribe(function() {\n            checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n        });\n    }\n    function checkIfSnapshotChanged(inst) {\n        var latestGetSnapshot = inst.getSnapshot;\n        inst = inst.value;\n        try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(inst, nextValue);\n        } catch (error) {\n            return !0;\n        }\n    }\n    function forceStoreRerender(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    }\n    function mountStateImpl(initialState) {\n        var hook = mountWorkInProgressHook();\n        if (\"function\" === typeof initialState) {\n            var initialStateInitializer = initialState;\n            initialState = initialStateInitializer();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    initialStateInitializer();\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n        }\n        hook.memoizedState = hook.baseState = initialState;\n        hook.queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n        };\n        return hook;\n    }\n    function mountState(initialState) {\n        initialState = mountStateImpl(initialState);\n        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n        queue.dispatch = dispatch;\n        return [\n            initialState.memoizedState,\n            dispatch\n        ];\n    }\n    function mountOptimistic(passthrough) {\n        var hook = mountWorkInProgressHook();\n        hook.memoizedState = hook.baseState = passthrough;\n        var queue = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: null,\n            lastRenderedState: null\n        };\n        hook.queue = queue;\n        hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);\n        queue.dispatch = hook;\n        return [\n            passthrough,\n            hook\n        ];\n    }\n    function updateOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    }\n    function updateOptimisticImpl(hook, current, passthrough, reducer) {\n        hook.baseState = passthrough;\n        return updateReducerImpl(hook, currentHook, \"function\" === typeof reducer ? reducer : basicStateReducer);\n    }\n    function rerenderOptimistic(passthrough, reducer) {\n        var hook = updateWorkInProgressHook();\n        if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        hook.baseState = passthrough;\n        return [\n            passthrough,\n            hook.queue.dispatch\n        ];\n    }\n    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n        if (isRenderPhaseUpdate(fiber)) throw Error(\"Cannot update form state while rendering.\");\n        fiber = actionQueue.action;\n        if (null !== fiber) {\n            var actionNode = {\n                payload: payload,\n                action: fiber,\n                next: null,\n                isTransition: !0,\n                status: \"pending\",\n                value: null,\n                reason: null,\n                listeners: [],\n                then: function(listener) {\n                    actionNode.listeners.push(listener);\n                }\n            };\n            null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;\n            setState(actionNode);\n            setPendingState = actionQueue.pending;\n            null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);\n        }\n    }\n    function runActionStateAction(actionQueue, node) {\n        var action = node.action, payload = node.payload, prevState = actionQueue.state;\n        if (node.isTransition) {\n            var prevTransition = ReactSharedInternals.T, currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            ReactSharedInternals.T._updatedFibers = new Set();\n            try {\n                var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;\n                null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n                handleActionReturnValue(actionQueue, node, returnValue);\n            } catch (error) {\n                onActionError(actionQueue, node, error);\n            } finally{\n                ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n            }\n        } else try {\n            currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);\n        } catch (error$2) {\n            onActionError(actionQueue, node, error$2);\n        }\n    }\n    function handleActionReturnValue(actionQueue, node, returnValue) {\n        null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then ? (returnValue.then(function(nextState) {\n            onActionSuccess(actionQueue, node, nextState);\n        }, function(error) {\n            return onActionError(actionQueue, node, error);\n        }), node.isTransition || console.error(\"An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`\")) : onActionSuccess(actionQueue, node, returnValue);\n    }\n    function onActionSuccess(actionQueue, actionNode, nextState) {\n        actionNode.status = \"fulfilled\";\n        actionNode.value = nextState;\n        notifyActionListeners(actionNode);\n        actionQueue.state = nextState;\n        actionNode = actionQueue.pending;\n        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));\n    }\n    function onActionError(actionQueue, actionNode, error) {\n        var last = actionQueue.pending;\n        actionQueue.pending = null;\n        if (null !== last) {\n            last = last.next;\n            do actionNode.status = \"rejected\", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;\n            while (actionNode !== last);\n        }\n        actionQueue.action = null;\n    }\n    function notifyActionListeners(actionNode) {\n        actionNode = actionNode.listeners;\n        for(var i = 0; i < actionNode.length; i++)(0, actionNode[i])();\n    }\n    function actionStateReducer(oldState, newState) {\n        return newState;\n    }\n    function mountActionState(action, initialStateProp) {\n        if (isHydrating) {\n            var ssrFormState = workInProgressRoot.formState;\n            if (null !== ssrFormState) {\n                a: {\n                    var isMatching = currentlyRenderingFiber$1;\n                    if (isHydrating) {\n                        if (nextHydratableInstance) {\n                            var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                            if (markerInstance) {\n                                nextHydratableInstance = getNextHydratableSibling(markerInstance);\n                                isMatching = isFormStateMarkerMatching(markerInstance);\n                                break a;\n                            }\n                        }\n                        throwOnHydrationMismatch(isMatching);\n                    }\n                    isMatching = !1;\n                }\n                isMatching && (initialStateProp = ssrFormState[0]);\n            }\n        }\n        ssrFormState = mountWorkInProgressHook();\n        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n        isMatching = {\n            pending: null,\n            lanes: 0,\n            dispatch: null,\n            lastRenderedReducer: actionStateReducer,\n            lastRenderedState: initialStateProp\n        };\n        ssrFormState.queue = isMatching;\n        ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);\n        isMatching.dispatch = ssrFormState;\n        isMatching = mountStateImpl(!1);\n        var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);\n        isMatching = mountWorkInProgressHook();\n        markerInstance = {\n            state: initialStateProp,\n            dispatch: null,\n            action: action,\n            pending: null\n        };\n        isMatching.queue = markerInstance;\n        ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, setPendingState, ssrFormState);\n        markerInstance.dispatch = ssrFormState;\n        isMatching.memoizedState = action;\n        return [\n            initialStateProp,\n            ssrFormState,\n            !1\n        ];\n    }\n    function updateActionState(action) {\n        var stateHook = updateWorkInProgressHook();\n        return updateActionStateImpl(stateHook, currentHook, action);\n    }\n    function updateActionStateImpl(stateHook, currentStateHook, action) {\n        currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];\n        stateHook = updateReducer(basicStateReducer)[0];\n        currentStateHook = \"object\" === typeof currentStateHook && null !== currentStateHook && \"function\" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;\n        var actionQueueHook = updateWorkInProgressHook(), actionQueue = actionQueueHook.queue, dispatch = actionQueue.dispatch;\n        action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {\n            destroy: void 0\n        }, null));\n        return [\n            currentStateHook,\n            dispatch,\n            stateHook\n        ];\n    }\n    function actionStateActionEffect(actionQueue, action) {\n        actionQueue.action = action;\n    }\n    function rerenderActionState(action) {\n        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;\n        if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);\n        updateWorkInProgressHook();\n        stateHook = stateHook.memoizedState;\n        currentStateHook = updateWorkInProgressHook();\n        var dispatch = currentStateHook.queue.dispatch;\n        currentStateHook.memoizedState = action;\n        return [\n            stateHook,\n            dispatch,\n            !1\n        ];\n    }\n    function pushEffect(tag, create, inst, deps) {\n        tag = {\n            tag: tag,\n            create: create,\n            inst: inst,\n            deps: deps,\n            next: null\n        };\n        create = currentlyRenderingFiber$1.updateQueue;\n        null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);\n        inst = create.lastEffect;\n        null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);\n        return tag;\n    }\n    function mountRef(initialValue) {\n        var hook = mountWorkInProgressHook();\n        initialValue = {\n            current: initialValue\n        };\n        return hook.memoizedState = initialValue;\n    }\n    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = mountWorkInProgressHook();\n        currentlyRenderingFiber$1.flags |= fiberFlags;\n        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {\n            destroy: void 0\n        }, void 0 === deps ? null : deps);\n    }\n    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var inst = hook.memoizedState.inst;\n        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));\n    }\n    function mountEffect(create, deps) {\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (currentlyRenderingFiber$1.mode & 64) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);\n    }\n    function mountLayoutEffect(create, deps) {\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        return mountEffectImpl(fiberFlags, Layout, create, deps);\n    }\n    function imperativeHandleEffect(create, ref) {\n        if (\"function\" === typeof ref) {\n            create = create();\n            var refCleanup = ref(create);\n            return function() {\n                \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n            };\n        }\n        if (null !== ref && void 0 !== ref) return ref.hasOwnProperty(\"current\") || console.error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(ref).join(\", \") + \"}\"), create = create(), ref.current = create, function() {\n            ref.current = null;\n        };\n    }\n    function mountImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        var fiberFlags = 4194308;\n        (currentlyRenderingFiber$1.mode & 16) !== NoMode && (fiberFlags |= 67108864);\n        mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function updateImperativeHandle(ref, create, deps) {\n        \"function\" !== typeof create && console.error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", null !== create ? typeof create : \"null\");\n        deps = null !== deps && void 0 !== deps ? deps.concat([\n            ref\n        ]) : null;\n        updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);\n    }\n    function mountCallback(callback, deps) {\n        mountWorkInProgressHook().memoizedState = [\n            callback,\n            void 0 === deps ? null : deps\n        ];\n        return callback;\n    }\n    function updateCallback(callback, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        hook.memoizedState = [\n            callback,\n            deps\n        ];\n        return callback;\n    }\n    function mountMemo(nextCreate, deps) {\n        var hook = mountWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var nextValue = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            nextValue,\n            deps\n        ];\n        return nextValue;\n    }\n    function updateMemo(nextCreate, deps) {\n        var hook = updateWorkInProgressHook();\n        deps = void 0 === deps ? null : deps;\n        var prevState = hook.memoizedState;\n        if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];\n        prevState = nextCreate();\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                nextCreate();\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        hook.memoizedState = [\n            prevState,\n            deps\n        ];\n        return prevState;\n    }\n    function mountDeferredValue(value, initialValue) {\n        var hook = mountWorkInProgressHook();\n        return mountDeferredValueImpl(hook, value, initialValue);\n    }\n    function updateDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function rerenderDeferredValue(value, initialValue) {\n        var hook = updateWorkInProgressHook();\n        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);\n    }\n    function mountDeferredValueImpl(hook, value, initialValue) {\n        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;\n        hook.memoizedState = initialValue;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return initialValue;\n    }\n    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n        if (objectIs(value, prevValue)) return value;\n        if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;\n        if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;\n        hook = requestDeferredLane();\n        currentlyRenderingFiber$1.lanes |= hook;\n        workInProgressRootSkippedLanes |= hook;\n        return prevValue;\n    }\n    function startTransition(fiber, queue, pendingState, finishedState, callback) {\n        var previousPriority = getCurrentUpdatePriority();\n        setCurrentUpdatePriority(0 !== previousPriority && 8 > previousPriority ? previousPriority : 8);\n        var prevTransition = ReactSharedInternals.T, currentTransition = {};\n        ReactSharedInternals.T = currentTransition;\n        dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n        currentTransition._updatedFibers = new Set();\n        try {\n            var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;\n            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);\n            if (null !== returnValue && \"object\" === typeof returnValue && \"function\" === typeof returnValue.then) {\n                var thenableForFinishedState = chainThenableValue(returnValue, finishedState);\n                dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));\n            } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));\n        } catch (error) {\n            dispatchSetStateInternal(fiber, queue, {\n                then: function() {},\n                status: \"rejected\",\n                reason: error\n            }, requestUpdateLane(fiber));\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\"));\n        }\n    }\n    function ensureFormComponentIsStateful(formFiber) {\n        var existingStateHook = formFiber.memoizedState;\n        if (null !== existingStateHook) return existingStateHook;\n        existingStateHook = {\n            memoizedState: NotPendingTransition,\n            baseState: NotPendingTransition,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            },\n            next: null\n        };\n        var initialResetState = {};\n        existingStateHook.next = {\n            memoizedState: initialResetState,\n            baseState: initialResetState,\n            baseQueue: null,\n            queue: {\n                pending: null,\n                lanes: 0,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            },\n            next: null\n        };\n        formFiber.memoizedState = existingStateHook;\n        formFiber = formFiber.alternate;\n        null !== formFiber && (formFiber.memoizedState = existingStateHook);\n        return existingStateHook;\n    }\n    function mountTransition() {\n        var stateHook = mountStateImpl(!1);\n        stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);\n        mountWorkInProgressHook().memoizedState = stateHook;\n        return [\n            !1,\n            stateHook\n        ];\n    }\n    function updateTransition() {\n        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function rerenderTransition() {\n        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;\n        return [\n            \"boolean\" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),\n            start\n        ];\n    }\n    function useHostTransitionStatus() {\n        return readContext(HostTransitionContext);\n    }\n    function mountId() {\n        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;\n        if (isHydrating) {\n            var treeId = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;\n            identifierPrefix = \":\" + identifierPrefix + \"R\" + treeId;\n            treeId = localIdCounter++;\n            0 < treeId && (identifierPrefix += \"H\" + treeId.toString(32));\n            identifierPrefix += \":\";\n        } else treeId = globalClientIdCounter++, identifierPrefix = \":\" + identifierPrefix + \"r\" + treeId.toString(32) + \":\";\n        return hook.memoizedState = identifierPrefix;\n    }\n    function mountRefresh() {\n        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n    }\n    function refreshCache(fiber, seedKey) {\n        for(var provider = fiber.return; null !== provider;){\n            switch(provider.tag){\n                case 24:\n                case 3:\n                    var lane = requestUpdateLane(provider);\n                    fiber = createUpdate(lane);\n                    var root = enqueueUpdate(provider, fiber, lane);\n                    null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));\n                    provider = createCache();\n                    null !== seedKey && void 0 !== seedKey && null !== root && console.error(\"The seed argument is not enabled outside experimental channels.\");\n                    fiber.payload = {\n                        cache: provider\n                    };\n                    return;\n            }\n            provider = provider.return;\n        }\n    }\n    function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);\n        action = {\n            lane: JSCompiler_OptimizeArgumentsArray_p0,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);\n    }\n    function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {\n        \"function\" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n        JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);\n        dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);\n        markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);\n    }\n    function dispatchSetStateInternal(fiber, queue, action, lane) {\n        var update = {\n            lane: lane,\n            revertLane: 0,\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n        else {\n            var alternate = fiber.alternate;\n            if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {\n                var prevDispatcher = ReactSharedInternals.H;\n                ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                try {\n                    var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);\n                    update.hasEagerState = !0;\n                    update.eagerState = eagerState;\n                    if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;\n                } catch (error) {} finally{\n                    ReactSharedInternals.H = prevDispatcher;\n                }\n            }\n            action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;\n        }\n        return !1;\n    }\n    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n        null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(\"An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.\");\n        action = {\n            lane: 2,\n            revertLane: requestTransitionLane(),\n            action: action,\n            hasEagerState: !1,\n            eagerState: null,\n            next: null\n        };\n        if (isRenderPhaseUpdate(fiber)) {\n            if (throwIfDuringRender) throw Error(\"Cannot update optimistic state while rendering.\");\n            console.error(\"Cannot call startTransition while rendering.\");\n        } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n        markStateUpdateScheduled(fiber, 2);\n    }\n    function isRenderPhaseUpdate(fiber) {\n        var alternate = fiber.alternate;\n        return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;\n    }\n    function enqueueRenderPhaseUpdate(queue, update) {\n        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;\n        var pending = queue.pending;\n        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);\n        queue.pending = update;\n    }\n    function entangleTransitionUpdate(root, queue, lane) {\n        if (0 !== (lane & 4194176)) {\n            var queueLanes = queue.lanes;\n            queueLanes &= root.pendingLanes;\n            lane |= queueLanes;\n            queue.lanes = lane;\n            markRootEntangled(root, lane);\n        }\n    }\n    function warnOnInvalidCallback(callback) {\n        if (null !== callback && \"function\" !== typeof callback) {\n            var key = String(callback);\n            didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback));\n        }\n    }\n    function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n        var prevState = workInProgress.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);\n        if (workInProgress.mode & 8) {\n            setIsStrictModeForDevtools(!0);\n            try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n            } finally{\n                setIsStrictModeForDevtools(!1);\n            }\n        }\n        void 0 === partialState && (ctor = getComponentNameFromType(ctor) || \"Component\", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", ctor)));\n        prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);\n        workInProgress.memoizedState = prevState;\n        0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);\n    }\n    function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n        var instance = workInProgress.stateNode;\n        if (\"function\" === typeof instance.shouldComponentUpdate) {\n            oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            void 0 === oldProps && console.error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n            return oldProps;\n        }\n        return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;\n    }\n    function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n        var oldState = instance.state;\n        \"function\" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);\n        \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n        instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || \"Component\", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));\n    }\n    function resolveClassComponentProps(Component, baseProps) {\n        var newProps = baseProps;\n        if (\"ref\" in baseProps) {\n            newProps = {};\n            for(var propName in baseProps)\"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n        }\n        if (Component = Component.defaultProps) {\n            newProps === baseProps && (newProps = assign({}, newProps));\n            for(var _propName in Component)void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);\n        }\n        return newProps;\n    }\n    function logUncaughtError(root, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = null;\n            var error = errorInfo.value;\n            if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);\n            else {\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            }\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function logCaughtError(root, boundary, errorInfo) {\n        try {\n            componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n            errorBoundaryName = getComponentNameFromFiber(boundary);\n            var onCaughtError = root.onCaughtError;\n            onCaughtError(errorInfo.value, {\n                componentStack: errorInfo.stack,\n                errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n            });\n        } catch (e) {\n            setTimeout(function() {\n                throw e;\n            });\n        }\n    }\n    function createRootErrorUpdate(root, errorInfo, lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        lane.payload = {\n            element: null\n        };\n        lane.callback = function() {\n            runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);\n        };\n        return lane;\n    }\n    function createClassErrorUpdate(lane) {\n        lane = createUpdate(lane);\n        lane.tag = CaptureUpdate;\n        return lane;\n    }\n    function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n        if (\"function\" === typeof getDerivedStateFromError) {\n            var error = errorInfo.value;\n            update.payload = function() {\n                return getDerivedStateFromError(error);\n            };\n            update.callback = function() {\n                markFailedErrorBoundaryForHotReloading(fiber);\n                runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            };\n        }\n        var inst = fiber.stateNode;\n        null !== inst && \"function\" === typeof inst.componentDidCatch && (update.callback = function() {\n            markFailedErrorBoundaryForHotReloading(fiber);\n            runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);\n            \"function\" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([\n                this\n            ]) : legacyErrorBoundariesThatAlreadyFailed.add(this));\n            callComponentDidCatchInDEV(this, errorInfo);\n            \"function\" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n        });\n    }\n    function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n        sourceFiber.flags |= 32768;\n        isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);\n        if (null !== value && \"object\" === typeof value && \"function\" === typeof value.then) {\n            returnFiber = sourceFiber.alternate;\n            null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);\n            isHydrating && (didSuspendOrErrorDEV = !0);\n            sourceFiber = suspenseHandlerStackCursor.current;\n            if (null !== sourceFiber) {\n                switch(sourceFiber.tag){\n                    case 13:\n                        return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([\n                            value\n                        ]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;\n                    case 22:\n                        return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {\n                            transitions: null,\n                            markerInstances: null,\n                            retryQueue: new Set([\n                                value\n                            ])\n                        }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([\n                            value\n                        ]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;\n                }\n                throw Error(\"Unexpected Suspense handler tag (\" + sourceFiber.tag + \"). This is a bug in React.\");\n            }\n            attachPingListener(root, value, rootRenderLanes);\n            renderDidSuspendDelayIfPossible();\n            return !1;\n        }\n        if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.\", {\n            cause: value\n        }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error(\"There was an error while hydrating but React was able to recover by instead client rendering the entire root.\", {\n            cause: value\n        }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;\n        var error = createCapturedValueAtFiber(Error(\"There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.\", {\n            cause: value\n        }), sourceFiber);\n        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [\n            error\n        ] : workInProgressRootConcurrentErrors.push(error);\n        workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);\n        if (null === returnFiber) return !0;\n        value = createCapturedValueAtFiber(value, sourceFiber);\n        sourceFiber = returnFiber;\n        do {\n            switch(sourceFiber.tag){\n                case 3:\n                    return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;\n                case 1:\n                    if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && (\"function\" === typeof returnFiber.getDerivedStateFromError || null !== error && \"function\" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;\n            }\n            sourceFiber = sourceFiber.return;\n        }while (null !== sourceFiber);\n        return !1;\n    }\n    function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n        workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n    }\n    function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n        Component = Component.render;\n        var ref = workInProgress.ref;\n        if (\"ref\" in nextProps) {\n            var propsWithoutRef = {};\n            for(var key in nextProps)\"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n        } else propsWithoutRef = nextProps;\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);\n        key = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && key && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null === current) {\n            var type = Component.type;\n            if (\"function\" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);\n            current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n            current.ref = workInProgress.ref;\n            current.return = workInProgress;\n            return workInProgress.child = current;\n        }\n        type = current.child;\n        if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n            var prevProps = type.memoizedProps;\n            Component = Component.compare;\n            Component = null !== Component ? Component : shallowEqual;\n            if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        workInProgress.flags |= 1;\n        current = createWorkInProgress(type, nextProps);\n        current.ref = workInProgress.ref;\n        current.return = workInProgress;\n        return workInProgress.child = current;\n    }\n    function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (null !== current) {\n            var prevProps = current.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n            else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n    }\n    function updateOffscreenComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, nextChildren = nextProps.children, nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2), prevState = null !== current ? current.memoizedState : null;\n        markRef(current, workInProgress);\n        if (\"hidden\" === nextProps.mode || nextIsDetached) {\n            if (0 !== (workInProgress.flags & 128)) {\n                nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n                if (null !== current) {\n                    nextChildren = workInProgress.child = current.child;\n                    for(nextIsDetached = 0; null !== nextChildren;)nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;\n                    workInProgress.childLanes = nextIsDetached & ~nextProps;\n                } else workInProgress.childLanes = 0, workInProgress.child = null;\n                return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);\n            }\n            if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {\n                baseLanes: 0,\n                cachePool: null\n            }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);\n            else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);\n        } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n        var JSCompiler_inline_result = peekCacheFromPool();\n        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: JSCompiler_inline_result\n        };\n        workInProgress.memoizedState = {\n            baseLanes: nextBaseLanes,\n            cachePool: JSCompiler_inline_result\n        };\n        null !== current && pushTransition(workInProgress, null);\n        reuseHiddenContextOnStack(workInProgress);\n        pushOffscreenSuspenseHandler(workInProgress);\n        null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n        return null;\n    }\n    function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n        if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);\n        else {\n            if (\"function\" !== typeof ref && \"object\" !== typeof ref) throw Error(\"Expected ref to be a function, an object returned by React.createRef(), or undefined/null.\");\n            if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;\n        }\n    }\n    function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n        if (Component.prototype && \"function\" === typeof Component.prototype.render) {\n            var componentName = getComponentNameFromType(Component) || \"Unknown\";\n            didWarnAboutBadClass[componentName] || (console.error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName), didWarnAboutBadClass[componentName] = !0);\n        }\n        workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n        null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)\", componentName))));\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);\n        nextProps = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, Component, renderLanes);\n        return workInProgress.child;\n    }\n    function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n        prepareToReadContext(workInProgress);\n        markComponentRenderStarted(workInProgress);\n        hookTypesUpdateIndexDev = -1;\n        ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;\n        workInProgress.updateQueue = null;\n        nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);\n        finishRenderingHooks(current, workInProgress);\n        Component = checkDidRenderIdHook();\n        markComponentRenderStopped();\n        if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        isHydrating && Component && pushMaterializedTreeId(workInProgress);\n        workInProgress.flags |= 1;\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        return workInProgress.child;\n    }\n    function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {\n        switch(shouldErrorImpl(workInProgress)){\n            case !1:\n                var _instance = workInProgress.stateNode, state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n            case !0:\n                workInProgress.flags |= 128;\n                workInProgress.flags |= 65536;\n                _instance = Error(\"Simulated error coming from DevTools\");\n                var lane = renderLanes & -renderLanes;\n                workInProgress.lanes |= lane;\n                state = workInProgressRoot;\n                if (null === state) throw Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n                lane = createClassErrorUpdate(lane);\n                initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));\n                enqueueCapturedUpdate(workInProgress, lane);\n        }\n        prepareToReadContext(workInProgress);\n        if (null === workInProgress.stateNode) {\n            state = emptyContextObject;\n            _instance = Component.contextType;\n            \"contextType\" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\" : \"object\" !== typeof _instance ? \" However, it is set to a \" + typeof _instance + \".\" : _instance.$$typeof === REACT_CONSUMER_TYPE ? \" Did you accidentally pass the Context.Consumer instead?\" : \" However, it is set to an object with keys {\" + Object.keys(_instance).join(\", \") + \"}.\", console.error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(Component) || \"Component\", lane));\n            \"object\" === typeof _instance && null !== _instance && (state = readContext(_instance));\n            _instance = new Component(nextProps, state);\n            if (workInProgress.mode & 8) {\n                setIsStrictModeForDevtools(!0);\n                try {\n                    _instance = new Component(nextProps, state);\n                } finally{\n                    setIsStrictModeForDevtools(!1);\n                }\n            }\n            state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;\n            _instance.updater = classComponentUpdater;\n            workInProgress.stateNode = _instance;\n            _instance._reactInternals = workInProgress;\n            _instance._reactInternalInstance = fakeInternalInstance;\n            \"function\" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", state, null === _instance.state ? \"null\" : \"undefined\", state)));\n            if (\"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) {\n                var foundWillUpdateName = lane = state = null;\n                \"function\" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = \"componentWillMount\" : \"function\" === typeof _instance.UNSAFE_componentWillMount && (state = \"UNSAFE_componentWillMount\");\n                \"function\" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = \"componentWillReceiveProps\" : \"function\" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = \"UNSAFE_componentWillReceiveProps\");\n                \"function\" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = \"componentWillUpdate\" : \"function\" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = \"UNSAFE_componentWillUpdate\");\n                if (null !== state || null !== lane || null !== foundWillUpdateName) {\n                    _instance = getComponentNameFromType(Component) || \"Component\";\n                    var newApiName = \"function\" === typeof Component.getDerivedStateFromProps ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                    didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://react.dev/link/unsafe-component-lifecycles\", _instance, newApiName, null !== state ? \"\\n  \" + state : \"\", null !== lane ? \"\\n  \" + lane : \"\", null !== foundWillUpdateName ? \"\\n  \" + foundWillUpdateName : \"\"));\n                }\n            }\n            _instance = workInProgress.stateNode;\n            state = getComponentNameFromType(Component) || \"Component\";\n            _instance.render || (Component.prototype && \"function\" === typeof Component.prototype.render ? console.error(\"No `render` method found on the %s instance: did you accidentally return an object from the constructor?\", state) : console.error(\"No `render` method found on the %s instance: you may have forgotten to define `render`.\", state));\n            !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", state);\n            _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", state);\n            _instance.contextType && console.error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", state);\n            Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(\"%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)\", state));\n            Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(\"%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)\", state));\n            \"function\" === typeof _instance.componentShouldUpdate && console.error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", state);\n            Component.prototype && Component.prototype.isPureReactComponent && \"undefined\" !== typeof _instance.shouldComponentUpdate && console.error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(Component) || \"A pure component\");\n            \"function\" === typeof _instance.componentDidUnmount && console.error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", state);\n            \"function\" === typeof _instance.componentDidReceiveProps && console.error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", state);\n            \"function\" === typeof _instance.componentWillRecieveProps && console.error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", state);\n            \"function\" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", state);\n            lane = _instance.props !== nextProps;\n            void 0 !== _instance.props && lane && console.error(\"When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", state);\n            _instance.defaultProps && console.error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", state, state);\n            \"function\" !== typeof _instance.getSnapshotBeforeUpdate || \"function\" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(Component)));\n            \"function\" === typeof _instance.getDerivedStateFromProps && console.error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof _instance.getDerivedStateFromError && console.error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", state);\n            \"function\" === typeof Component.getSnapshotBeforeUpdate && console.error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", state);\n            (lane = _instance.state) && (\"object\" !== typeof lane || isArrayImpl(lane)) && console.error(\"%s.state: must be set to an object or null\", state);\n            \"function\" === typeof _instance.getChildContext && \"object\" !== typeof Component.childContextTypes && console.error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", state);\n            _instance = workInProgress.stateNode;\n            _instance.props = nextProps;\n            _instance.state = workInProgress.memoizedState;\n            _instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            state = Component.contextType;\n            _instance.context = \"object\" === typeof state && null !== state ? readContext(state) : emptyContextObject;\n            _instance.state === nextProps && (state = getComponentNameFromType(Component) || \"Component\", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", state)));\n            workInProgress.mode & 8 && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);\n            _instance.state = workInProgress.memoizedState;\n            state = Component.getDerivedStateFromProps;\n            \"function\" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof Component.getDerivedStateFromProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (state = _instance.state, \"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress) || \"Component\"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);\n            \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);\n            (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864);\n            _instance = !0;\n        } else if (null === current$jscomp$0) {\n            _instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            lane = resolveClassComponentProps(Component, unresolvedOldProps);\n            _instance.props = lane;\n            var oldContext = _instance.context;\n            foundWillUpdateName = Component.contextType;\n            state = emptyContextObject;\n            \"object\" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));\n            newApiName = Component.getDerivedStateFromProps;\n            foundWillUpdateName = \"function\" === typeof newApiName || \"function\" === typeof _instance.getSnapshotBeforeUpdate;\n            unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n            foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);\n            hasForceUpdate = !1;\n            var oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            oldContext = workInProgress.memoizedState;\n            unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? (\"function\" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || \"function\" !== typeof _instance.UNSAFE_componentWillMount && \"function\" !== typeof _instance.componentWillMount || (\"function\" === typeof _instance.componentWillMount && _instance.componentWillMount(), \"function\" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), \"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864)) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : (\"function\" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & 16) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);\n        } else {\n            _instance = workInProgress.stateNode;\n            cloneUpdateQueue(current$jscomp$0, workInProgress);\n            state = workInProgress.memoizedProps;\n            foundWillUpdateName = resolveClassComponentProps(Component, state);\n            _instance.props = foundWillUpdateName;\n            newApiName = workInProgress.pendingProps;\n            oldState = _instance.context;\n            oldContext = Component.contextType;\n            lane = emptyContextObject;\n            \"object\" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));\n            unresolvedOldProps = Component.getDerivedStateFromProps;\n            (oldContext = \"function\" === typeof unresolvedOldProps || \"function\" === typeof _instance.getSnapshotBeforeUpdate) || \"function\" !== typeof _instance.UNSAFE_componentWillReceiveProps && \"function\" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);\n            hasForceUpdate = !1;\n            oldState = workInProgress.memoizedState;\n            _instance.state = oldState;\n            processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            var newState = workInProgress.memoizedState;\n            state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? (\"function\" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || \"function\" !== typeof _instance.UNSAFE_componentWillUpdate && \"function\" !== typeof _instance.componentWillUpdate || (\"function\" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), \"function\" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), \"function\" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), \"function\" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : (\"function\" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), \"function\" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);\n        }\n        lane = _instance;\n        markRef(current$jscomp$0, workInProgress);\n        state = 0 !== (workInProgress.flags & 128);\n        if (lane || state) {\n            lane = workInProgress.stateNode;\n            ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;\n            isRendering = !1;\n            current = workInProgress;\n            if (state && \"function\" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;\n            else {\n                markComponentRenderStarted(workInProgress);\n                Component = callRenderInDEV(lane);\n                if (workInProgress.mode & 8) {\n                    setIsStrictModeForDevtools(!0);\n                    try {\n                        callRenderInDEV(lane);\n                    } finally{\n                        setIsStrictModeForDevtools(!1);\n                    }\n                }\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= 1;\n            null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);\n            workInProgress.memoizedState = lane.state;\n            current$jscomp$0 = workInProgress.child;\n        } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);\n        renderLanes = workInProgress.stateNode;\n        _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress) || \"a component\"), didWarnAboutReassigningProps = !0);\n        return current$jscomp$0;\n    }\n    function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n        resetHydrationState();\n        workInProgress.flags |= 256;\n        reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n        return workInProgress.child;\n    }\n    function validateFunctionComponentInDev(workInProgress, Component) {\n        Component && Component.childContextTypes && console.error(\"childContextTypes cannot be defined on a function component.\\n  %s.childContextTypes = ...\", Component.displayName || Component.name || \"Component\");\n        \"function\" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error(\"%s: Function components do not support getDerivedStateFromProps.\", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));\n        \"object\" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || \"Unknown\", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(\"%s: Function components do not support contextType.\", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));\n    }\n    function mountSuspenseOffscreenState(renderLanes) {\n        return {\n            baseLanes: renderLanes,\n            cachePool: getSuspendedCache()\n        };\n    }\n    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n        current = null !== current ? current.childLanes & ~renderLanes : 0;\n        primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n        return current;\n    }\n    function updateSuspenseComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps;\n        shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);\n        var showFallback = !1, didSuspend = 0 !== (workInProgress.flags & 128), JSCompiler_temp;\n        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));\n        JSCompiler_temp && (showFallback = !0, workInProgress.flags &= -129);\n        JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n        workInProgress.flags &= -33;\n        if (null === current) {\n            if (isHydrating) {\n                showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);\n                if (isHydrating) {\n                    var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;\n                    (JSCompiler_temp$jscomp$0 = !nextInstance) || (JSCompiler_temp$jscomp$0 = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext), null !== JSCompiler_temp$jscomp$0 ? (warnIfNotHydrating(), workInProgress.memoizedState = {\n                        dehydrated: JSCompiler_temp$jscomp$0,\n                        treeContext: null !== treeContextProvider ? {\n                            id: treeContextId,\n                            overflow: treeContextOverflow\n                        } : null,\n                        retryLane: 536870912\n                    }, didSuspend = createFiber(18, null, null, NoMode), didSuspend.stateNode = JSCompiler_temp$jscomp$0, didSuspend.return = workInProgress, workInProgress.child = didSuspend, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = !0) : JSCompiler_temp$jscomp$0 = !1, JSCompiler_temp$jscomp$0 = !JSCompiler_temp$jscomp$0);\n                    JSCompiler_temp$jscomp$0 && (warnNonHydratedInstance(workInProgress, nextInstance), throwOnHydrationMismatch(workInProgress));\n                }\n                nextInstance = workInProgress.memoizedState;\n                if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance)) return isSuspenseInstanceFallback(nextInstance) ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;\n                popSuspenseHandler(workInProgress);\n            }\n            nextInstance = nextProps.children;\n            nextProps = nextProps.fallback;\n            if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = workInProgress.mode, nextInstance = mountWorkInProgressOffscreenFiber({\n                mode: \"hidden\",\n                children: nextInstance\n            }, showFallback), nextProps = createFiberFromFragment(nextProps, showFallback, renderLanes, null), nextInstance.return = workInProgress, nextProps.return = workInProgress, nextInstance.sibling = nextProps, workInProgress.child = nextInstance, showFallback = workInProgress.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes), showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n            pushPrimaryTreeSuspenseHandler(workInProgress);\n            return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n        }\n        JSCompiler_temp$jscomp$0 = current.memoizedState;\n        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {\n            if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, nextProps = mountWorkInProgressOffscreenFiber({\n                mode: \"visible\",\n                children: nextProps.children\n            }, nextInstance), showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2, nextProps.return = workInProgress, showFallback.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, reconcileChildFibers(workInProgress, current.child, null, renderLanes), nextProps = workInProgress.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes), nextProps.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = showFallback);\n            else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\"), isSuspenseInstanceFallback(nextInstance)) nextInstance = getSuspenseInstanceFallbackErrorDetails(nextInstance), JSCompiler_temp = nextInstance.digest, showFallback = nextInstance.message, nextProps = nextInstance.stack, nextInstance = nextInstance.componentStack, showFallback = showFallback ? Error(showFallback) : Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\"), showFallback.stack = nextProps || \"\", showFallback.digest = JSCompiler_temp, JSCompiler_temp = void 0 === nextInstance ? null : nextInstance, nextProps = {\n                value: showFallback,\n                source: null,\n                stack: JSCompiler_temp\n            }, \"string\" === typeof JSCompiler_temp && CapturedStacks.set(showFallback, nextProps), queueHydrationError(nextProps), workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_temp = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_temp) {\n                JSCompiler_temp = workInProgressRoot;\n                if (null !== JSCompiler_temp) {\n                    nextProps = renderLanes & -renderLanes;\n                    if (0 !== (nextProps & 42)) nextProps = 1;\n                    else switch(nextProps){\n                        case 2:\n                            nextProps = 1;\n                            break;\n                        case 8:\n                            nextProps = 4;\n                            break;\n                        case 32:\n                            nextProps = 16;\n                            break;\n                        case 128:\n                        case 256:\n                        case 512:\n                        case 1024:\n                        case 2048:\n                        case 4096:\n                        case 8192:\n                        case 16384:\n                        case 32768:\n                        case 65536:\n                        case 131072:\n                        case 262144:\n                        case 524288:\n                        case 1048576:\n                        case 2097152:\n                        case 4194304:\n                        case 8388608:\n                        case 16777216:\n                        case 33554432:\n                            nextProps = 64;\n                            break;\n                        case 268435456:\n                            nextProps = 134217728;\n                            break;\n                        default:\n                            nextProps = 0;\n                    }\n                    nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes)) ? 0 : nextProps;\n                    if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane) throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;\n                }\n                isSuspenseInstancePending(nextInstance) || renderDidSuspendDelayIfPossible();\n                workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n            } else isSuspenseInstancePending(nextInstance) ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), registerSuspenseInstanceRetry(nextInstance, workInProgress), workInProgress = null) : (current = JSCompiler_temp$jscomp$0.treeContext, supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(nextInstance), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress)), workInProgress = mountSuspensePrimaryChildren(workInProgress, nextProps.children), workInProgress.flags |= 4096);\n            return workInProgress;\n        }\n        if (showFallback) return reuseSuspenseHandlerOnStack(workInProgress), showFallback = nextProps.fallback, nextInstance = workInProgress.mode, JSCompiler_temp$jscomp$0 = current.child, didSuspend = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n            mode: \"hidden\",\n            children: nextProps.children\n        }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 31457280, null !== didSuspend ? showFallback = createWorkInProgress(didSuspend, showFallback) : (showFallback = createFiberFromFragment(showFallback, nextInstance, renderLanes, null), showFallback.flags |= 2), showFallback.return = workInProgress, nextProps.return = workInProgress, nextProps.sibling = showFallback, workInProgress.child = nextProps, nextProps = showFallback, showFallback = workInProgress.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (didSuspend = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== didSuspend ? {\n            parent: didSuspend,\n            pool: didSuspend\n        } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n        }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_temp, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, nextProps;\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        renderLanes = current.child;\n        current = renderLanes.sibling;\n        renderLanes = createWorkInProgress(renderLanes, {\n            mode: \"visible\",\n            children: nextProps.children\n        });\n        renderLanes.return = workInProgress;\n        renderLanes.sibling = null;\n        null !== current && (JSCompiler_temp = workInProgress.deletions, null === JSCompiler_temp ? (workInProgress.deletions = [\n            current\n        ], workInProgress.flags |= 16) : JSCompiler_temp.push(current));\n        workInProgress.child = renderLanes;\n        workInProgress.memoizedState = null;\n        return renderLanes;\n    }\n    function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n        primaryChildren = mountWorkInProgressOffscreenFiber({\n            mode: \"visible\",\n            children: primaryChildren\n        }, workInProgress.mode);\n        primaryChildren.return = workInProgress;\n        return workInProgress.child = primaryChildren;\n    }\n    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n        return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n    }\n    function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n        reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n        current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);\n        current.flags |= 2;\n        workInProgress.memoizedState = null;\n        return current;\n    }\n    function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n        fiber.lanes |= renderLanes;\n        var alternate = fiber.alternate;\n        null !== alternate && (alternate.lanes |= renderLanes);\n        scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n    }\n    function validateSuspenseListNestedChild(childSlot, index) {\n        var isAnArray = isArrayImpl(childSlot);\n        childSlot = !isAnArray && \"function\" === typeof getIteratorFn(childSlot);\n        return isAnArray || childSlot ? (isAnArray = isAnArray ? \"array\" : \"iterable\", console.error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", isAnArray, index, isAnArray), !1) : !0;\n    }\n    function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n        var renderState = workInProgress.memoizedState;\n        null === renderState ? workInProgress.memoizedState = {\n            isBackwards: isBackwards,\n            rendering: null,\n            renderingStartTime: 0,\n            last: lastContentRow,\n            tail: tail,\n            tailMode: tailMode\n        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);\n    }\n    function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n        var nextProps = workInProgress.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;\n        nextProps = nextProps.children;\n        if (void 0 !== revealOrder && \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && \"together\" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, \"string\" === typeof revealOrder) switch(revealOrder.toLowerCase()){\n            case \"together\":\n            case \"forwards\":\n            case \"backwards\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            case \"forward\":\n            case \"backward\":\n                console.error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                break;\n            default:\n                console.error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        }\n        else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n        void 0 === tailMode || didWarnAboutTailOptions[tailMode] || (\"collapsed\" !== tailMode && \"hidden\" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode)) : \"forwards\" !== revealOrder && \"backwards\" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode)));\n        a: if ((\"forwards\" === revealOrder || \"backwards\" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for(var i = 0; i < nextProps.length; i++){\n            if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;\n        }\n        else if (i = getIteratorFn(nextProps), \"function\" === typeof i) {\n            if (i = i.call(nextProps)) for(var step = i.next(), _i = 0; !step.done; step = i.next()){\n                if (!validateSuspenseListNestedChild(step.value, _i)) break a;\n                _i++;\n            }\n        } else console.error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        nextProps = suspenseStackCursor.current;\n        if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;\n        else {\n            if (null !== current && 0 !== (current.flags & 128)) a: for(current = workInProgress.child; null !== current;){\n                if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n                else if (null !== current.child) {\n                    current.child.return = current;\n                    current = current.child;\n                    continue;\n                }\n                if (current === workInProgress) break a;\n                for(; null === current.sibling;){\n                    if (null === current.return || current.return === workInProgress) break a;\n                    current = current.return;\n                }\n                current.sibling.return = current.return;\n                current = current.sibling;\n            }\n            nextProps &= SubtreeSuspenseContextMask;\n        }\n        push(suspenseStackCursor, nextProps, workInProgress);\n        switch(revealOrder){\n            case \"forwards\":\n                renderLanes = workInProgress.child;\n                for(revealOrder = null; null !== renderLanes;)current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;\n                renderLanes = revealOrder;\n                null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);\n                initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);\n                break;\n            case \"backwards\":\n                renderLanes = null;\n                revealOrder = workInProgress.child;\n                for(workInProgress.child = null; null !== revealOrder;){\n                    current = revealOrder.alternate;\n                    if (null !== current && null === findFirstSuspended(current)) {\n                        workInProgress.child = revealOrder;\n                        break;\n                    }\n                    current = revealOrder.sibling;\n                    revealOrder.sibling = renderLanes;\n                    renderLanes = revealOrder;\n                    revealOrder = current;\n                }\n                initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);\n                break;\n            case \"together\":\n                initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n                break;\n            default:\n                workInProgress.memoizedState = null;\n        }\n        return workInProgress.child;\n    }\n    function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n        null !== current && (workInProgress.dependencies = current.dependencies);\n        profilerStartTime = -1;\n        workInProgressRootSkippedLanes |= workInProgress.lanes;\n        if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {\n            if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;\n        } else return null;\n        if (null !== current && workInProgress.child !== current.child) throw Error(\"Resuming work not yet implemented.\");\n        if (null !== workInProgress.child) {\n            current = workInProgress.child;\n            renderLanes = createWorkInProgress(current, current.pendingProps);\n            workInProgress.child = renderLanes;\n            for(renderLanes.return = workInProgress; null !== current.sibling;)current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;\n            renderLanes.sibling = null;\n        }\n        return workInProgress.child;\n    }\n    function checkScheduledUpdateOrContext(current, renderLanes) {\n        if (0 !== (current.lanes & renderLanes)) return !0;\n        current = current.dependencies;\n        return null !== current && checkIfContextChanged(current) ? !0 : !1;\n    }\n    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n        switch(workInProgress.tag){\n            case 3:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n                resetHydrationState();\n                break;\n            case 27:\n            case 5:\n                pushHostContext(workInProgress);\n                break;\n            case 4:\n                pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                break;\n            case 10:\n                pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);\n                break;\n            case 12:\n                0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);\n                workInProgress.flags |= 2048;\n                var stateNode = workInProgress.stateNode;\n                stateNode.effectDuration = -0;\n                stateNode.passiveEffectDuration = -0;\n                break;\n            case 13:\n                stateNode = workInProgress.memoizedState;\n                if (null !== stateNode) {\n                    if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;\n                    if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    return null !== current ? current.sibling : null;\n                }\n                pushPrimaryTreeSuspenseHandler(workInProgress);\n                break;\n            case 19:\n                var didSuspendBefore = 0 !== (current.flags & 128);\n                stateNode = 0 !== (renderLanes & workInProgress.childLanes);\n                stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));\n                if (didSuspendBefore) {\n                    if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    workInProgress.flags |= 128;\n                }\n                didSuspendBefore = workInProgress.memoizedState;\n                null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);\n                push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);\n                if (stateNode) break;\n                else return null;\n            case 22:\n            case 23:\n                return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n        }\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n    function beginWork(current, workInProgress, renderLanes) {\n        if (workInProgress._debugNeedsRemount && null !== current) {\n            renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);\n            var returnFiber = workInProgress.return;\n            if (null === returnFiber) throw Error(\"Cannot swap the root fiber.\");\n            current.alternate = null;\n            workInProgress.alternate = null;\n            renderLanes.index = workInProgress.index;\n            renderLanes.sibling = workInProgress.sibling;\n            renderLanes.return = workInProgress.return;\n            renderLanes.ref = workInProgress.ref;\n            renderLanes._debugInfo = workInProgress._debugInfo;\n            if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;\n            else {\n                var prevSibling = returnFiber.child;\n                if (null === prevSibling) throw Error(\"Expected parent to have a child.\");\n                for(; prevSibling.sibling !== workInProgress;)if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error(\"Expected to find the previous sibling.\");\n                prevSibling.sibling = renderLanes;\n            }\n            workInProgress = returnFiber.deletions;\n            null === workInProgress ? (returnFiber.deletions = [\n                current\n            ], returnFiber.flags |= 16) : workInProgress.push(current);\n            renderLanes.flags |= 2;\n            return renderLanes;\n        }\n        if (null !== current) if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;\n        else {\n            if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n            didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n        }\n        else {\n            didReceiveUpdate = !1;\n            if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);\n            returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));\n        }\n        workInProgress.lanes = 0;\n        switch(workInProgress.tag){\n            case 16:\n                a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, \"function\" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));\n                else {\n                    if (void 0 !== current && null !== current) {\n                        if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {\n                            workInProgress.tag = 11;\n                            workInProgress.type = current = resolveForwardRefForHotReloading(current);\n                            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        } else if (prevSibling === REACT_MEMO_TYPE) {\n                            workInProgress.tag = 14;\n                            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);\n                            break a;\n                        }\n                    }\n                    workInProgress = \"\";\n                    null !== current && \"object\" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = \" Did you wrap a component in React.lazy() more than once?\");\n                    current = getComponentNameFromType(current) || current;\n                    throw Error(\"Element type is invalid. Received a promise that resolves to: \" + current + \". Lazy element type must resolve to a class or function.\" + workInProgress);\n                }\n                return workInProgress;\n            case 0:\n                return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 1:\n                return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);\n            case 3:\n                a: {\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    if (null === current) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                    var nextProps = workInProgress.pendingProps;\n                    prevSibling = workInProgress.memoizedState;\n                    returnFiber = prevSibling.element;\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n                    var nextState = workInProgress.memoizedState;\n                    nextProps = nextState.cache;\n                    pushProvider(workInProgress, CacheContext, nextProps);\n                    nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                        CacheContext\n                    ], renderLanes, !0);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                    nextProps = nextState.element;\n                    if (supportsHydration && prevSibling.isDehydrated) if (prevSibling = {\n                        element: nextProps,\n                        isDehydrated: !1,\n                        cache: nextState.cache\n                    }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else if (nextProps !== returnFiber) {\n                        returnFiber = createCapturedValueAtFiber(Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress);\n                        queueHydrationError(returnFiber);\n                        workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);\n                        break a;\n                    } else for(supportsHydration && (nextHydratableInstance = getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0), current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;)current.flags = current.flags & -3 | 4096, current = current.sibling;\n                    else {\n                        resetHydrationState();\n                        if (nextProps === returnFiber) {\n                            workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                            break a;\n                        }\n                        reconcileChildren(current, workInProgress, nextProps, renderLanes);\n                    }\n                    workInProgress = workInProgress.child;\n                }\n                return workInProgress;\n            case 26:\n                if (supportsResources) return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, requiredContext(rootInstanceStackCursor.current), workInProgress)) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;\n            case 27:\n                if (supportsSingletons) return pushHostContext(workInProgress), null === current && supportsSingletons && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedPropsForDevWarnings(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getFirstHydratableChild(prevSibling)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;\n            case 5:\n                return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateHydratableInstance(workInProgress.type, workInProgress.pendingProps, nextProps), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedPropsForDevWarnings(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getFirstHydratableChild(nextState), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), isPrimaryRenderer ? HostTransitionContext._currentValue = prevSibling : HostTransitionContext._currentValue2 = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 6:\n                return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext(), current = validateHydratableTextInstance(current, renderLanes), renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;\n            case 13:\n                return updateSuspenseComponent(current, workInProgress, renderLanes);\n            case 4:\n                return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 11:\n                return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 7:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;\n            case 8:\n                return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 12:\n                return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 10:\n                return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, \"value\" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;\n            case 9:\n                return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, \"function\" !== typeof returnFiber && console.error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\"), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;\n            case 14:\n                return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 15:\n                return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n            case 19:\n                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n            case 22:\n                return updateOffscreenComponent(current, workInProgress, renderLanes);\n            case 24:\n                return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {\n                    parent: returnFiber,\n                    cache: prevSibling\n                }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {\n                    parent: returnFiber,\n                    cache: returnFiber\n                }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [\n                    CacheContext\n                ], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;\n            case 29:\n                throw workInProgress.pendingProps;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function resetContextDependencies() {\n        lastContextDependency = currentlyRenderingFiber = null;\n        isDisallowedContextReadInDEV = !1;\n    }\n    function pushProvider(providerFiber, context, nextValue) {\n        isPrimaryRenderer ? (push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, push(rendererCursorDEV, context._currentRenderer, providerFiber), void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer = rendererSigil) : (push(valueCursor, context._currentValue2, providerFiber), context._currentValue2 = nextValue, push(renderer2CursorDEV, context._currentRenderer2, providerFiber), void 0 !== context._currentRenderer2 && null !== context._currentRenderer2 && context._currentRenderer2 !== rendererSigil && console.error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\"), context._currentRenderer2 = rendererSigil);\n    }\n    function popProvider(context, providerFiber) {\n        var currentValue = valueCursor.current;\n        isPrimaryRenderer ? (context._currentValue = currentValue, currentValue = rendererCursorDEV.current, pop(rendererCursorDEV, providerFiber), context._currentRenderer = currentValue) : (context._currentValue2 = currentValue, currentValue = renderer2CursorDEV.current, pop(renderer2CursorDEV, providerFiber), context._currentRenderer2 = currentValue);\n        pop(valueCursor, providerFiber);\n    }\n    function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n        for(; null !== parent;){\n            var alternate = parent.alternate;\n            (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);\n            if (parent === propagationRoot) break;\n            parent = parent.return;\n        }\n        parent !== propagationRoot && console.error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {\n        var fiber = workInProgress.child;\n        null !== fiber && (fiber.return = workInProgress);\n        for(; null !== fiber;){\n            var list = fiber.dependencies;\n            if (null !== list) {\n                var nextFiber = fiber.child;\n                list = list.firstContext;\n                a: for(; null !== list;){\n                    var dependency = list;\n                    list = fiber;\n                    for(var i = 0; i < contexts.length; i++)if (dependency.context === contexts[i]) {\n                        list.lanes |= renderLanes;\n                        dependency = list.alternate;\n                        null !== dependency && (dependency.lanes |= renderLanes);\n                        scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);\n                        forcePropagateEntireTree || (nextFiber = null);\n                        break a;\n                    }\n                    list = dependency.next;\n                }\n            } else if (18 === fiber.tag) {\n                nextFiber = fiber.return;\n                if (null === nextFiber) throw Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n                nextFiber.lanes |= renderLanes;\n                list = nextFiber.alternate;\n                null !== list && (list.lanes |= renderLanes);\n                scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n                nextFiber = null;\n            } else nextFiber = fiber.child;\n            if (null !== nextFiber) nextFiber.return = fiber;\n            else for(nextFiber = fiber; null !== nextFiber;){\n                if (nextFiber === workInProgress) {\n                    nextFiber = null;\n                    break;\n                }\n                fiber = nextFiber.sibling;\n                if (null !== fiber) {\n                    fiber.return = nextFiber.return;\n                    nextFiber = fiber;\n                    break;\n                }\n                nextFiber = nextFiber.return;\n            }\n            fiber = nextFiber;\n        }\n    }\n    function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {\n        current = null;\n        for(var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;){\n            if (!isInsidePropagationBailout) {\n                if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n                else if (0 !== (parent.flags & 262144)) break;\n            }\n            if (10 === parent.tag) {\n                var currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent = currentParent.memoizedProps;\n                if (null !== currentParent) {\n                    var context = parent.type;\n                    objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [\n                        context\n                    ]);\n                }\n            } else if (parent === hostTransitionProviderCursor.current) {\n                currentParent = parent.alternate;\n                if (null === currentParent) throw Error(\"Should have a current fiber. This is a bug in React.\");\n                currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [\n                    HostTransitionContext\n                ]);\n            }\n            parent = parent.return;\n        }\n        null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);\n        workInProgress.flags |= 262144;\n    }\n    function checkIfContextChanged(currentDependencies) {\n        for(currentDependencies = currentDependencies.firstContext; null !== currentDependencies;){\n            var context = currentDependencies.context;\n            if (!objectIs(isPrimaryRenderer ? context._currentValue : context._currentValue2, currentDependencies.memoizedValue)) return !0;\n            currentDependencies = currentDependencies.next;\n        }\n        return !1;\n    }\n    function prepareToReadContext(workInProgress) {\n        currentlyRenderingFiber = workInProgress;\n        lastContextDependency = null;\n        workInProgress = workInProgress.dependencies;\n        null !== workInProgress && (workInProgress.firstContext = null);\n    }\n    function readContext(context) {\n        isDisallowedContextReadInDEV && console.error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n        return readContextForConsumer(currentlyRenderingFiber, context);\n    }\n    function readContextDuringReconciliation(consumer, context) {\n        null === currentlyRenderingFiber && prepareToReadContext(consumer);\n        return readContextForConsumer(consumer, context);\n    }\n    function readContextForConsumer(consumer, context) {\n        var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n        context = {\n            context: context,\n            memoizedValue: value,\n            next: null\n        };\n        if (null === lastContextDependency) {\n            if (null === consumer) throw Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            lastContextDependency = context;\n            consumer.dependencies = {\n                lanes: 0,\n                firstContext: context,\n                _debugThenableState: null\n            };\n            consumer.flags |= 524288;\n        } else lastContextDependency = lastContextDependency.next = context;\n        return value;\n    }\n    function createCache() {\n        return {\n            controller: new AbortControllerLocal(),\n            data: new Map(),\n            refCount: 0\n        };\n    }\n    function retainCache(cache) {\n        cache.controller.signal.aborted && console.warn(\"A cache instance was retained after it was already freed. This likely indicates a bug in React.\");\n        cache.refCount++;\n    }\n    function releaseCache(cache) {\n        cache.refCount--;\n        0 > cache.refCount && console.warn(\"A cache instance was released after it was already freed. This likely indicates a bug in React.\");\n        0 === cache.refCount && scheduleCallback$1(NormalPriority, function() {\n            cache.controller.abort();\n        });\n    }\n    function peekCacheFromPool() {\n        var cacheResumedFromPreviousRender = resumedCache.current;\n        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;\n    }\n    function pushTransition(offscreenWorkInProgress, prevCachePool) {\n        null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n    }\n    function getSuspendedCache() {\n        var cacheFromPool = peekCacheFromPool();\n        return null === cacheFromPool ? null : {\n            parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n            pool: cacheFromPool\n        };\n    }\n    function markUpdate(workInProgress) {\n        workInProgress.flags |= 4;\n    }\n    function doesRequireClone(current, completedWork) {\n        if (null !== current && current.child === completedWork.child) return !1;\n        if (0 !== (completedWork.flags & 16)) return !0;\n        for(current = completedWork.child; null !== current;){\n            if (0 !== (current.flags & 13878) || 0 !== (current.subtreeFlags & 13878)) return !0;\n            current = current.sibling;\n        }\n        return !1;\n    }\n    function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsMutation) for(needsVisibilityToggle = workInProgress.child; null !== needsVisibilityToggle;){\n            if (5 === needsVisibilityToggle.tag || 6 === needsVisibilityToggle.tag) appendInitialChild(parent, needsVisibilityToggle.stateNode);\n            else if (!(4 === needsVisibilityToggle.tag || supportsSingletons && 27 === needsVisibilityToggle.tag) && null !== needsVisibilityToggle.child) {\n                needsVisibilityToggle.child.return = needsVisibilityToggle;\n                needsVisibilityToggle = needsVisibilityToggle.child;\n                continue;\n            }\n            if (needsVisibilityToggle === workInProgress) break;\n            for(; null === needsVisibilityToggle.sibling;){\n                if (null === needsVisibilityToggle.return || needsVisibilityToggle.return === workInProgress) return;\n                needsVisibilityToggle = needsVisibilityToggle.return;\n            }\n            needsVisibilityToggle.sibling.return = needsVisibilityToggle.return;\n            needsVisibilityToggle = needsVisibilityToggle.sibling;\n        }\n        else if (supportsPersistence) for(var _node = workInProgress.child; null !== _node;){\n            if (5 === _node.tag) {\n                var instance = _node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, _node.type, _node.memoizedProps));\n                appendInitialChild(parent, instance);\n            } else if (6 === _node.tag) instance = _node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, _node.memoizedProps)), appendInitialChild(parent, instance);\n            else if (4 !== _node.tag) {\n                if (22 === _node.tag && null !== _node.memoizedState) instance = _node.child, null !== instance && (instance.return = _node), appendAllChildren(parent, _node, !0, !0);\n                else if (null !== _node.child) {\n                    _node.child.return = _node;\n                    _node = _node.child;\n                    continue;\n                }\n            }\n            if (_node === workInProgress) break;\n            for(; null === _node.sibling;){\n                if (null === _node.return || _node.return === workInProgress) return;\n                _node = _node.return;\n            }\n            _node.sibling.return = _node.return;\n            _node = _node.sibling;\n        }\n    }\n    function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n        if (supportsPersistence) for(var node = workInProgress.child; null !== node;){\n            if (5 === node.tag) {\n                var instance = node.stateNode;\n                needsVisibilityToggle && isHidden && (instance = cloneHiddenInstance(instance, node.type, node.memoizedProps));\n                appendChildToContainerChildSet(containerChildSet, instance);\n            } else if (6 === node.tag) instance = node.stateNode, needsVisibilityToggle && isHidden && (instance = cloneHiddenTextInstance(instance, node.memoizedProps)), appendChildToContainerChildSet(containerChildSet, instance);\n            else if (4 !== node.tag) {\n                if (22 === node.tag && null !== node.memoizedState) instance = node.child, null !== instance && (instance.return = node), appendAllChildrenToContainer(containerChildSet, node, !(null !== node.memoizedProps && \"manual\" === node.memoizedProps.mode), !0);\n                else if (null !== node.child) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n            }\n            if (node === workInProgress) break;\n            for(; null === node.sibling;){\n                if (null === node.return || node.return === workInProgress) return;\n                node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n        }\n    }\n    function updateHostContainer(current, workInProgress) {\n        if (supportsPersistence && doesRequireClone(current, workInProgress)) {\n            current = workInProgress.stateNode;\n            var container = current.containerInfo, newChildSet = createContainerChildSet();\n            appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);\n            current.pendingChildren = newChildSet;\n            markUpdate(workInProgress);\n            finalizeContainerChildren(container, newChildSet);\n        }\n    }\n    function updateHostComponent(current, workInProgress, type, newProps) {\n        if (supportsMutation) current.memoizedProps !== newProps && markUpdate(workInProgress);\n        else if (supportsPersistence) {\n            var currentInstance = current.stateNode, _oldProps = current.memoizedProps;\n            if ((current = doesRequireClone(current, workInProgress)) || _oldProps !== newProps) {\n                var currentHostContext = getHostContext();\n                _oldProps = cloneInstance(currentInstance, type, _oldProps, newProps, !current, null);\n                _oldProps === currentInstance ? workInProgress.stateNode = currentInstance : (finalizeInitialChildren(_oldProps, type, newProps, currentHostContext) && markUpdate(workInProgress), workInProgress.stateNode = _oldProps, current ? appendAllChildren(_oldProps, workInProgress, !1, !1) : markUpdate(workInProgress));\n            } else workInProgress.stateNode = currentInstance;\n        }\n    }\n    function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props) {\n        if (maySuspendCommit(type, props)) {\n            if (workInProgress.flags |= 16777216, !preloadInstance(type, props)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n        if (mayResourceSuspendCommit(resource)) {\n            if (workInProgress.flags |= 16777216, !preloadResource(resource)) if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;\n            else throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;\n        } else workInProgress.flags &= -16777217;\n    }\n    function scheduleRetryEffect(workInProgress, retryQueue) {\n        null !== retryQueue && (workInProgress.flags |= 4);\n        workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);\n    }\n    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n        if (!isHydrating) switch(renderState.tailMode){\n            case \"hidden\":\n                hasRenderedATailFallback = renderState.tail;\n                for(var lastTailNode = null; null !== hasRenderedATailFallback;)null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;\n                null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;\n                break;\n            case \"collapsed\":\n                lastTailNode = renderState.tail;\n                for(var _lastTailNode = null; null !== lastTailNode;)null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;\n                null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;\n        }\n    }\n    function bubbleProperties(completedWork) {\n        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;\n        if (didBailout) if ((completedWork.mode & 2) !== NoMode) {\n            for(var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;)newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;\n            completedWork.treeBaseDuration = _treeBaseDuration;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        else if ((completedWork.mode & 2) !== NoMode) {\n            _treeBaseDuration = completedWork.actualDuration;\n            _child2 = completedWork.selfBaseDuration;\n            for(var child = completedWork.child; null !== child;)newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;\n            completedWork.actualDuration = _treeBaseDuration;\n            completedWork.treeBaseDuration = _child2;\n        } else for(_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;)newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;\n        completedWork.subtreeFlags |= subtreeFlags;\n        completedWork.childLanes = newChildLanes;\n        return didBailout;\n    }\n    function completeWork(current, workInProgress, renderLanes) {\n        var newProps = workInProgress.pendingProps;\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 16:\n            case 15:\n            case 0:\n            case 11:\n            case 7:\n            case 8:\n            case 12:\n            case 9:\n            case 14:\n                return bubbleProperties(workInProgress), null;\n            case 1:\n                return bubbleProperties(workInProgress), null;\n            case 3:\n                renderLanes = workInProgress.stateNode;\n                newProps = null;\n                null !== current && (newProps = current.memoizedState.cache);\n                workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048);\n                popProvider(CacheContext, workInProgress);\n                popHostContainer(workInProgress);\n                renderLanes.pendingContext && (renderLanes.context = renderLanes.pendingContext, renderLanes.pendingContext = null);\n                if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));\n                updateHostContainer(current, workInProgress);\n                bubbleProperties(workInProgress);\n                return null;\n            case 26:\n                if (supportsResources) {\n                    renderLanes = workInProgress.type;\n                    var nextResource = workInProgress.memoizedState;\n                    null === current ? (markUpdate(workInProgress), null !== nextResource ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, nextResource)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, renderLanes, newProps), bubbleProperties(workInProgress), preloadInstanceAndSuspendIfNeeded(workInProgress, renderLanes, newProps));\n                    return null;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    popHostContext(workInProgress);\n                    renderLanes = requiredContext(rootInstanceStackCursor.current);\n                    nextResource = workInProgress.type;\n                    if (null !== current && null != workInProgress.stateNode) supportsMutation ? current.memoizedProps !== newProps && markUpdate(workInProgress) : updateHostComponent(current, workInProgress, nextResource, newProps);\n                    else {\n                        if (!newProps) {\n                            if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        current = getHostContext();\n                        popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(nextResource, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                }\n            case 5:\n                popHostContext(workInProgress);\n                renderLanes = workInProgress.type;\n                if (null !== current && null != workInProgress.stateNode) updateHostComponent(current, workInProgress, renderLanes, newProps);\n                else {\n                    if (!newProps) {\n                        if (null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                    current = getHostContext();\n                    popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (nextResource = requiredContext(rootInstanceStackCursor.current), nextResource = createInstance(renderLanes, newProps, nextResource, current, workInProgress), appendAllChildren(nextResource, workInProgress, !1, !1), workInProgress.stateNode = nextResource, finalizeInitialChildren(nextResource, renderLanes, newProps, current) && markUpdate(workInProgress));\n                }\n                bubbleProperties(workInProgress);\n                preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                return null;\n            case 6:\n                if (current && null != workInProgress.stateNode) renderLanes = current.memoizedProps, supportsMutation ? renderLanes !== newProps && markUpdate(workInProgress) : supportsPersistence && (renderLanes !== newProps ? (current = requiredContext(rootInstanceStackCursor.current), renderLanes = getHostContext(), workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress), markUpdate(workInProgress)) : workInProgress.stateNode = current.stateNode);\n                else {\n                    if (\"string\" !== typeof newProps && null === workInProgress.stateNode) throw Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                    current = requiredContext(rootInstanceStackCursor.current);\n                    renderLanes = getHostContext();\n                    if (popHydrationState(workInProgress)) {\n                        if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                        current = workInProgress.stateNode;\n                        renderLanes = workInProgress.memoizedProps;\n                        nextResource = !didSuspendOrErrorDEV;\n                        newProps = null;\n                        var returnFiber = hydrationParentFiber;\n                        if (null !== returnFiber) switch(returnFiber.tag){\n                            case 3:\n                                nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                                break;\n                            case 27:\n                            case 5:\n                                newProps = returnFiber.memoizedProps, nextResource && (nextResource = diffHydratedTextForDevWarnings(current, renderLanes, newProps), null !== nextResource && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextResource));\n                        }\n                        hydrateTextInstance(current, renderLanes, workInProgress, newProps) || throwOnHydrationMismatch(workInProgress);\n                    } else workInProgress.stateNode = createTextInstance(newProps, current, renderLanes, workInProgress);\n                }\n                bubbleProperties(workInProgress);\n                return null;\n            case 13:\n                newProps = workInProgress.memoizedState;\n                if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {\n                    nextResource = popHydrationState(workInProgress);\n                    if (null !== newProps && null !== newProps.dehydrated) {\n                        if (null === current) {\n                            if (!nextResource) throw Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n                            if (!supportsHydration) throw Error(\"Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.\");\n                            nextResource = workInProgress.memoizedState;\n                            nextResource = null !== nextResource ? nextResource.dehydrated : null;\n                            if (!nextResource) throw Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n                            hydrateSuspenseInstance(nextResource, workInProgress);\n                            bubbleProperties(workInProgress);\n                            (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & 2) !== NoMode && null !== newProps && (nextResource = workInProgress.child, null !== nextResource && (workInProgress.treeBaseDuration -= nextResource.treeBaseDuration));\n                        nextResource = !1;\n                    } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), nextResource = !0;\n                    if (!nextResource) {\n                        if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;\n                        popSuspenseHandler(workInProgress);\n                        return null;\n                    }\n                }\n                popSuspenseHandler(workInProgress);\n                if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress;\n                renderLanes = null !== newProps;\n                current = null !== current && null !== current.memoizedState;\n                renderLanes && (newProps = workInProgress.child, nextResource = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (nextResource = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== nextResource && (newProps.flags |= 2048));\n                renderLanes !== current && renderLanes && (workInProgress.child.flags |= 8192);\n                scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n                bubbleProperties(workInProgress);\n                (workInProgress.mode & 2) !== NoMode && renderLanes && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));\n                return null;\n            case 4:\n                return popHostContainer(workInProgress), updateHostContainer(current, workInProgress), null === current && preparePortalMount(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;\n            case 19:\n                pop(suspenseStackCursor, workInProgress);\n                nextResource = workInProgress.memoizedState;\n                if (null === nextResource) return bubbleProperties(workInProgress), null;\n                newProps = 0 !== (workInProgress.flags & 128);\n                returnFiber = nextResource.rendering;\n                if (null === returnFiber) if (newProps) cutOffTailIfNeeded(nextResource, !1);\n                else {\n                    if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for(current = workInProgress.child; null !== current;){\n                        returnFiber = findFirstSuspended(current);\n                        if (null !== returnFiber) {\n                            workInProgress.flags |= 128;\n                            cutOffTailIfNeeded(nextResource, !1);\n                            current = returnFiber.updateQueue;\n                            workInProgress.updateQueue = current;\n                            scheduleRetryEffect(workInProgress, current);\n                            workInProgress.subtreeFlags = 0;\n                            current = renderLanes;\n                            for(renderLanes = workInProgress.child; null !== renderLanes;)resetWorkInProgress(renderLanes, current), renderLanes = renderLanes.sibling;\n                            push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);\n                            return workInProgress.child;\n                        }\n                        current = current.sibling;\n                    }\n                    null !== nextResource.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                }\n                else {\n                    if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {\n                        if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(nextResource, !0), null === nextResource.tail && \"hidden\" === nextResource.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;\n                    } else 2 * now$1() - nextResource.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(nextResource, !1), workInProgress.lanes = 4194304);\n                    nextResource.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = nextResource.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, nextResource.last = returnFiber);\n                }\n                if (null !== nextResource.tail) return current = nextResource.tail, nextResource.rendering = current, nextResource.tail = current.sibling, nextResource.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;\n                bubbleProperties(workInProgress);\n                return null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), renderLanes = workInProgress.updateQueue, null !== renderLanes && scheduleRetryEffect(workInProgress, renderLanes.retryQueue), renderLanes = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (newProps = workInProgress.memoizedState.cachePool.pool), newProps !== renderLanes && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;\n            case 24:\n                return renderLanes = null, null !== current && (renderLanes = current.memoizedState.cache), workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;\n            case 25:\n                return null;\n        }\n        throw Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n    }\n    function unwindWork(current, workInProgress) {\n        popTreeContext(workInProgress);\n        switch(workInProgress.tag){\n            case 1:\n                return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 3:\n                return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;\n            case 26:\n            case 27:\n            case 5:\n                return popHostContext(workInProgress), null;\n            case 13:\n                popSuspenseHandler(workInProgress);\n                current = workInProgress.memoizedState;\n                if (null !== current && null !== current.dehydrated) {\n                    if (null === workInProgress.alternate) throw Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                    resetHydrationState();\n                }\n                current = workInProgress.flags;\n                return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 19:\n                return pop(suspenseStackCursor, workInProgress), null;\n            case 4:\n                return popHostContainer(workInProgress), null;\n            case 10:\n                return popProvider(workInProgress.type, workInProgress), null;\n            case 22:\n            case 23:\n                return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & 2) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;\n            case 24:\n                return popProvider(CacheContext, workInProgress), null;\n            case 25:\n                return null;\n            default:\n                return null;\n        }\n    }\n    function unwindInterruptedWork(current, interruptedWork) {\n        popTreeContext(interruptedWork);\n        switch(interruptedWork.tag){\n            case 3:\n                popProvider(CacheContext, interruptedWork);\n                popHostContainer(interruptedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                popHostContext(interruptedWork);\n                break;\n            case 4:\n                popHostContainer(interruptedWork);\n                break;\n            case 13:\n                popSuspenseHandler(interruptedWork);\n                break;\n            case 19:\n                pop(suspenseStackCursor, interruptedWork);\n                break;\n            case 10:\n                popProvider(interruptedWork.type, interruptedWork);\n                break;\n            case 22:\n            case 23:\n                popSuspenseHandler(interruptedWork);\n                popHiddenContext(interruptedWork);\n                null !== current && pop(resumedCache, interruptedWork);\n                break;\n            case 24:\n                popProvider(CacheContext, interruptedWork);\n        }\n    }\n    function shouldProfile(current) {\n        return (current.mode & 2) !== NoMode;\n    }\n    function commitHookLayoutEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitHookEffectListMount(flags, finishedWork) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && \"function\" !== typeof lastEffect)) {\n                        var hookName = void 0;\n                        hookName = 0 !== (updateQueue.tag & Layout) ? \"useLayoutEffect\" : 0 !== (updateQueue.tag & Insertion) ? \"useInsertionEffect\" : \"useEffect\";\n                        var addendum = void 0;\n                        addendum = null === lastEffect ? \" You returned null. If your effect does not require clean up, return undefined (or nothing).\" : \"function\" === typeof lastEffect.then ? \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching\" : \" You returned: \" + lastEffect;\n                        runWithFiberInDEV(finishedWork, function(n, a) {\n                            console.error(\"%s must not return anything besides a function, which is used for clean-up.%s\", n, a);\n                        }, hookName, addendum);\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n        try {\n            var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n            if (null !== lastEffect) {\n                var firstEffect = lastEffect.next;\n                updateQueue = firstEffect;\n                do {\n                    if ((updateQueue.tag & flags) === flags) {\n                        var inst = updateQueue.inst, destroy = inst.destroy;\n                        void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());\n                    }\n                    updateQueue = updateQueue.next;\n                }while (updateQueue !== firstEffect);\n            }\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);\n    }\n    function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n        shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n    }\n    function commitClassCallbacks(finishedWork) {\n        var updateQueue = finishedWork.updateQueue;\n        if (null !== updateQueue) {\n            var instance = finishedWork.stateNode;\n            finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), instance.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n            try {\n                runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }\n    function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {\n        return instance.getSnapshotBeforeUpdate(prevProps, prevState);\n    }\n    function commitClassSnapshot(finishedWork, current) {\n        var prevProps = current.memoizedProps, prevState = current.memoizedState;\n        current = finishedWork.stateNode;\n        finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), current.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n        try {\n            var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);\n            var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);\n            prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;\n            void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {\n                console.error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n            }));\n            current.__reactInternalSnapshotBeforeUpdate = snapshot;\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n        instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n        instance.state = current.memoizedState;\n        shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);\n    }\n    function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n        if (null !== ref) {\n            var instance = finishedWork.stateNode;\n            switch(finishedWork.tag){\n                case 26:\n                case 27:\n                case 5:\n                    instance = getPublicInstance(instance);\n            }\n            if (\"function\" === typeof ref) if (shouldProfile(finishedWork)) try {\n                startEffectTimer(), finishedWork.refCleanup = ref(instance);\n            } finally{\n                recordEffectDuration();\n            }\n            else finishedWork.refCleanup = ref(instance);\n            else \"string\" === typeof ref ? console.error(\"String refs are no longer supported.\") : ref.hasOwnProperty(\"current\") || console.error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork)), ref.current = instance;\n        }\n    }\n    function safelyAttachRef(current, nearestMountedAncestor) {\n        try {\n            runWithFiberInDEV(current, commitAttachRef, current);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        }\n    }\n    function safelyDetachRef(current, nearestMountedAncestor) {\n        var ref = current.ref, refCleanup = current.refCleanup;\n        if (null !== ref) if (\"function\" === typeof refCleanup) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, refCleanup);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, refCleanup);\n        } catch (error) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error);\n        } finally{\n            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);\n        }\n        else if (\"function\" === typeof ref) try {\n            if (shouldProfile(current)) try {\n                startEffectTimer(), runWithFiberInDEV(current, ref, null);\n            } finally{\n                recordEffectDuration(current);\n            }\n            else runWithFiberInDEV(current, ref, null);\n        } catch (error$3) {\n            captureCommitPhaseError(current, nearestMountedAncestor, error$3);\n        }\n        else ref.current = null;\n    }\n    function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {\n        var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;\n        _finishedWork$memoize = _finishedWork$memoize.onRender;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);\n        \"function\" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);\n    }\n    function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {\n        var _finishedWork$memoize2 = finishedWork.memoizedProps;\n        finishedWork = _finishedWork$memoize2.id;\n        _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;\n        current = null === current ? \"mount\" : \"update\";\n        currentUpdateIsNested && (current = \"nested-update\");\n        \"function\" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);\n    }\n    function commitHostMount(finishedWork) {\n        var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;\n        try {\n            runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitHostUpdate(finishedWork, newProps, oldProps) {\n        try {\n            runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function isHostParent(fiber) {\n        return 5 === fiber.tag || 3 === fiber.tag || (supportsResources ? 26 === fiber.tag : !1) || (supportsSingletons ? 27 === fiber.tag : !1) || 4 === fiber.tag;\n    }\n    function getHostSibling(fiber) {\n        a: for(;;){\n            for(; null === fiber.sibling;){\n                if (null === fiber.return || isHostParent(fiber.return)) return null;\n                fiber = fiber.return;\n            }\n            fiber.sibling.return = fiber.return;\n            for(fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && (supportsSingletons ? 27 !== fiber.tag : 1) && 18 !== fiber.tag;){\n                if (fiber.flags & 2) continue a;\n                if (null === fiber.child || 4 === fiber.tag) continue a;\n                else fiber.child.return = fiber, fiber = fiber.child;\n            }\n            if (!(fiber.flags & 2)) return fiber.stateNode;\n        }\n    }\n    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertInContainerBefore(parent, node, before) : appendChildToContainer(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;\n    }\n    function insertOrAppendPlacementNode(node, before, parent) {\n        var tag = node.tag;\n        if (5 === tag || 6 === tag) node = node.stateNode, before ? insertBefore(parent, node, before) : appendChild(parent, node);\n        else if (!(4 === tag || supportsSingletons && 27 === tag) && (node = node.child, null !== node)) for(insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;)insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n    }\n    function commitPlacement(finishedWork) {\n        if (supportsMutation && (!supportsSingletons || 27 !== finishedWork.tag)) {\n            a: {\n                for(var parent = finishedWork.return; null !== parent;){\n                    if (isHostParent(parent)) {\n                        var parentFiber = parent;\n                        break a;\n                    }\n                    parent = parent.return;\n                }\n                throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            switch(parentFiber.tag){\n                case 27:\n                    if (supportsSingletons) {\n                        parent = parentFiber.stateNode;\n                        parentFiber = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                        break;\n                    }\n                case 5:\n                    parent = parentFiber.stateNode;\n                    parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNode(finishedWork, parentFiber, parent);\n                    break;\n                case 3:\n                case 4:\n                    parent = parentFiber.stateNode.containerInfo;\n                    parentFiber = getHostSibling(finishedWork);\n                    insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);\n                    break;\n                default:\n                    throw Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n        }\n    }\n    function commitHostPortalContainerChildren(portal, finishedWork, pendingChildren) {\n        portal = portal.containerInfo;\n        try {\n            runWithFiberInDEV(finishedWork, replaceContainerChildren, portal, pendingChildren);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function commitBeforeMutationEffects(root, firstChild) {\n        prepareForCommit(root.containerInfo);\n        for(nextEffect = firstChild; null !== nextEffect;)if (root = nextEffect, firstChild = root.child, 0 !== (root.subtreeFlags & 1028) && null !== firstChild) firstChild.return = root, nextEffect = firstChild;\n        else for(; null !== nextEffect;){\n            firstChild = root = nextEffect;\n            var current = firstChild.alternate, flags = firstChild.flags;\n            switch(firstChild.tag){\n                case 0:\n                    break;\n                case 11:\n                case 15:\n                    break;\n                case 1:\n                    0 !== (flags & 1024) && null !== current && commitClassSnapshot(firstChild, current);\n                    break;\n                case 3:\n                    0 !== (flags & 1024) && supportsMutation && clearContainer(firstChild.stateNode.containerInfo);\n                    break;\n                case 5:\n                case 26:\n                case 27:\n                case 6:\n                case 4:\n                case 17:\n                    break;\n                default:\n                    if (0 !== (flags & 1024)) throw Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            firstChild = root.sibling;\n            if (null !== firstChild) {\n                firstChild.return = root.return;\n                nextEffect = firstChild;\n                break;\n            }\n            nextEffect = root.return;\n        }\n        root = shouldFireAfterActiveInstanceBlur;\n        shouldFireAfterActiveInstanceBlur = !1;\n        return root;\n    }\n    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                break;\n            case 1:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);\n                else {\n                    var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                    current = current.memoizedState;\n                    finishedWork.type.defaultProps || \"ref\" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"), finishedRoot.state !== finishedWork.memoizedState && console.error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\"));\n                    shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);\n                }\n                flags & 64 && commitClassCallbacks(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 3:\n                current = pushNestedEffectDurations();\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {\n                    prevProps = null;\n                    if (null !== finishedWork.child) switch(finishedWork.child.tag){\n                        case 27:\n                        case 5:\n                            prevProps = getPublicInstance(finishedWork.child.stateNode);\n                            break;\n                        case 1:\n                            prevProps = finishedWork.child.stateNode;\n                    }\n                    try {\n                        runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                finishedRoot.effectDuration += popNestedEffectDurations(current);\n                break;\n            case 26:\n                if (supportsResources) {\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                    break;\n                }\n            case 27:\n            case 5:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                null === current && flags & 4 && commitHostMount(finishedWork);\n                flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                break;\n            case 13:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n                if (!prevProps) {\n                    current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;\n                    var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                    offscreenSubtreeIsHidden = prevProps;\n                    (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                    offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                    offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                }\n                flags & 512 && (\"manual\" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));\n                break;\n            default:\n                recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        }\n    }\n    function detachFiberAfterEffects(fiber) {\n        var alternate = fiber.alternate;\n        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));\n        fiber.child = null;\n        fiber.deletions = null;\n        fiber.sibling = null;\n        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));\n        fiber.stateNode = null;\n        fiber._debugOwner = null;\n        fiber.return = null;\n        fiber.dependencies = null;\n        fiber.memoizedProps = null;\n        fiber.memoizedState = null;\n        fiber.pendingProps = null;\n        fiber.stateNode = null;\n        fiber.updateQueue = null;\n    }\n    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n        for(parent = parent.child; null !== parent;)commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;\n    }\n    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n        if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount) try {\n            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        switch(deletedFiber.tag){\n            case 26:\n                if (supportsResources) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    deletedFiber.memoizedState ? releaseResource(deletedFiber.memoizedState) : deletedFiber.stateNode && unmountHoistable(deletedFiber.stateNode);\n                    break;\n                }\n            case 27:\n                if (supportsSingletons) {\n                    offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                    var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;\n                    hostParent = deletedFiber.stateNode;\n                    recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                    releaseSingletonInstance(deletedFiber.stateNode);\n                    hostParent = prevHostParent;\n                    hostParentIsContainer = prevHostParentIsContainer;\n                    break;\n                }\n            case 5:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n            case 6:\n                if (supportsMutation) {\n                    if (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, null !== hostParent) if (hostParentIsContainer) try {\n                        runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                    else try {\n                        runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);\n                    } catch (error) {\n                        captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);\n                    }\n                } else recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 18:\n                supportsMutation && null !== hostParent && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n                break;\n            case 4:\n                supportsMutation ? (prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer, hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer) : (supportsPersistence && commitHostPortalContainerChildren(deletedFiber.stateNode, deletedFiber, createContainerChildSet()), recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber));\n                break;\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 1:\n                offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, \"function\" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 21:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                break;\n            case 22:\n                offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevHostParent;\n                break;\n            default:\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n        }\n    }\n    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n        if (supportsHydration && null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {\n            runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);\n        } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n    }\n    function getRetryCache(finishedWork) {\n        switch(finishedWork.tag){\n            case 13:\n            case 19:\n                var retryCache = finishedWork.stateNode;\n                null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n                return retryCache;\n            case 22:\n                return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;\n            default:\n                throw Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a bug in React.\");\n        }\n    }\n    function attachSuspenseRetryListeners(finishedWork, wakeables) {\n        var retryCache = getRetryCache(finishedWork);\n        wakeables.forEach(function(wakeable) {\n            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n            if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                else throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                wakeable.then(retry, retry);\n            }\n        });\n    }\n    function commitMutationEffects(root, finishedWork, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitMutationEffectsOnFiber(finishedWork, root);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n            var root = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i];\n            if (supportsMutation) {\n                var parent = returnFiber;\n                a: for(; null !== parent;){\n                    switch(parent.tag){\n                        case 27:\n                        case 5:\n                            hostParent = parent.stateNode;\n                            hostParentIsContainer = !1;\n                            break a;\n                        case 3:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                        case 4:\n                            hostParent = parent.stateNode.containerInfo;\n                            hostParentIsContainer = !0;\n                            break a;\n                    }\n                    parent = parent.return;\n                }\n                if (null === hostParent) throw Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = !1;\n            } else commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            root = deletedFiber;\n            returnFiber = root.alternate;\n            null !== returnFiber && (returnFiber.return = null);\n            root.return = null;\n        }\n        if (parentFiber.subtreeFlags & 13878) for(parentFiber = parentFiber.child; null !== parentFiber;)commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;\n    }\n    function commitMutationEffectsOnFiber(finishedWork, root) {\n        var current = finishedWork.alternate, flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));\n                break;\n            case 1:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));\n                break;\n            case 26:\n                if (supportsResources) {\n                    var hoistableRoot = currentHoistableRoot;\n                    recursivelyTraverseMutationEffects(root, finishedWork);\n                    commitReconciliationEffects(finishedWork);\n                    flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                    flags & 4 && (flags = null !== current ? current.memoizedState : null, root = finishedWork.memoizedState, null === current ? null === root ? null === finishedWork.stateNode ? finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork) : mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : finishedWork.stateNode = acquireResource(hoistableRoot, root, finishedWork.memoizedProps) : flags !== root ? (null === flags ? null !== current.stateNode && unmountHoistable(current.stateNode) : releaseResource(flags), null === root ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, root, finishedWork.memoizedProps)) : null === root && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps));\n                    break;\n                }\n            case 27:\n                if (supportsSingletons && flags & 4 && null === finishedWork.alternate) {\n                    hoistableRoot = finishedWork.stateNode;\n                    var props = finishedWork.memoizedProps;\n                    try {\n                        clearSingleton(hoistableRoot), runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, props, hoistableRoot, finishedWork);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            case 5:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                if (supportsMutation) {\n                    if (finishedWork.flags & 32) {\n                        root = finishedWork.stateNode;\n                        try {\n                            runWithFiberInDEV(finishedWork, resetTextContent, root);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                    flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));\n                    flags & 1024 && (needsFormReset = !0, \"form\" !== finishedWork.type && console.error(\"Unexpected host component type. Expected a form. This is a bug in React.\"));\n                }\n                break;\n            case 6:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4 && supportsMutation) {\n                    if (null === finishedWork.stateNode) throw Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                    flags = finishedWork.memoizedProps;\n                    current = null !== current ? current.memoizedProps : flags;\n                    root = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                break;\n            case 3:\n                hoistableRoot = pushNestedEffectDurations();\n                supportsResources ? (prepareToCommitHoistables(), props = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(root.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), currentHoistableRoot = props) : recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                if (flags & 4) {\n                    if (supportsMutation && supportsHydration && null !== current && current.memoizedState.isDehydrated) try {\n                        runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    if (supportsPersistence) {\n                        flags = root.containerInfo;\n                        current = root.pendingChildren;\n                        try {\n                            runWithFiberInDEV(finishedWork, replaceContainerChildren, flags, current);\n                        } catch (error) {\n                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                        }\n                    }\n                }\n                needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));\n                root.effectDuration += popNestedEffectDurations(hoistableRoot);\n                break;\n            case 4:\n                supportsResources ? (current = currentHoistableRoot, currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo), recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork), currentHoistableRoot = current) : (recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork));\n                flags & 4 && supportsPersistence && commitHostPortalContainerChildren(finishedWork.stateNode, finishedWork, finishedWork.stateNode.pendingChildren);\n                break;\n            case 12:\n                flags = pushNestedEffectDurations();\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);\n                break;\n            case 13:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 22:\n                flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));\n                hoistableRoot = null !== finishedWork.memoizedState;\n                var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                commitReconciliationEffects(finishedWork);\n                root = finishedWork.stateNode;\n                root._current = finishedWork;\n                root._visibility &= -3;\n                root._visibility |= root._pendingVisibility & 2;\n                if (flags & 8192 && (root._visibility = hoistableRoot ? root._visibility & -2 : root._visibility | 1, hoistableRoot && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || wasHidden || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), supportsMutation && (null === finishedWork.memoizedProps || \"manual\" !== finishedWork.memoizedProps.mode))) {\n                    a: if (current = null, supportsMutation) for(root = finishedWork;;){\n                        if (5 === root.tag || supportsResources && 26 === root.tag || supportsSingletons && 27 === root.tag) {\n                            if (null === current) {\n                                wasHidden = current = root;\n                                try {\n                                    props = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, props) : runWithFiberInDEV(wasHidden, unhideInstance, wasHidden.stateNode, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if (6 === root.tag) {\n                            if (null === current) {\n                                wasHidden = root;\n                                try {\n                                    var instance = wasHidden.stateNode;\n                                    hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, instance) : runWithFiberInDEV(wasHidden, unhideTextInstance, instance, wasHidden.memoizedProps);\n                                } catch (error) {\n                                    captureCommitPhaseError(wasHidden, wasHidden.return, error);\n                                }\n                            }\n                        } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {\n                            root.child.return = root;\n                            root = root.child;\n                            continue;\n                        }\n                        if (root === finishedWork) break a;\n                        for(; null === root.sibling;){\n                            if (null === root.return || root.return === finishedWork) break a;\n                            current === root && (current = null);\n                            root = root.return;\n                        }\n                        current === root && (current = null);\n                        root.sibling.return = root.return;\n                        root = root.sibling;\n                    }\n                }\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));\n                break;\n            case 19:\n                recursivelyTraverseMutationEffects(root, finishedWork);\n                commitReconciliationEffects(finishedWork);\n                flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));\n                break;\n            case 21:\n                break;\n            default:\n                recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);\n        }\n    }\n    function commitReconciliationEffects(finishedWork) {\n        var flags = finishedWork.flags;\n        if (flags & 2) {\n            try {\n                runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n            finishedWork.flags &= -3;\n        }\n        flags & 4096 && (finishedWork.flags &= -4097);\n    }\n    function recursivelyResetForms(parentFiber) {\n        if (parentFiber.subtreeFlags & 1024) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var fiber = parentFiber;\n            recursivelyResetForms(fiber);\n            5 === fiber.tag && fiber.flags & 1024 && resetFormInstance(fiber.stateNode);\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function commitLayoutEffects(finishedWork, root, committedLanes) {\n        inProgressLanes = committedLanes;\n        inProgressRoot = root;\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n        inProgressRoot = inProgressLanes = null;\n    }\n    function recursivelyTraverseLayoutEffects(root, parentFiber) {\n        if (parentFiber.subtreeFlags & 8772) for(parentFiber = parentFiber.child; null !== parentFiber;)commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disappearLayoutEffects(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 14:\n            case 15:\n                commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 1:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                var instance = finishedWork.stateNode;\n                \"function\" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            case 22:\n                safelyDetachRef(finishedWork, finishedWork.return);\n                null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                commitHookLayoutEffects(finishedWork, Layout);\n                break;\n            case 1:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                current = finishedWork.stateNode;\n                \"function\" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);\n                current = finishedWork.updateQueue;\n                if (null !== current) {\n                    finishedRoot = finishedWork.stateNode;\n                    try {\n                        runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n                includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 26:\n            case 27:\n            case 5:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            case 12:\n                if (includeWorkInProgressEffects && flags & 4) {\n                    flags = pushNestedEffectDurations();\n                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                    includeWorkInProgressEffects = finishedWork.stateNode;\n                    includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                break;\n            case 13:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n            case 22:\n                null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                safelyAttachRef(finishedWork, finishedWork.return);\n                break;\n            default:\n                recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function commitOffscreenPassiveMountEffects(current, finishedWork) {\n        var previousCache = null;\n        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);\n        current = null;\n        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);\n        current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));\n    }\n    function commitCachePassiveMountEffect(current, finishedWork) {\n        current = null;\n        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);\n        finishedWork = finishedWork.memoizedState.cache;\n        finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));\n    }\n    function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));\n                finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                if (flags & 2048) {\n                    prevEffectDuration = pushNestedEffectDurations();\n                    recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                    finishedRoot = finishedWork.stateNode;\n                    finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                    try {\n                        runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                break;\n            case 23:\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & 4 ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));\n                flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n        }\n    }\n    function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n        for(parentFiber = parentFiber.child; null !== parentFiber;)reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;\n    }\n    function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n        var flags = finishedWork.flags;\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                commitHookPassiveMountEffects(finishedWork, Passive);\n                break;\n            case 23:\n                break;\n            case 22:\n                var _instance2 = finishedWork.stateNode;\n                null !== finishedWork.memoizedState ? _instance2._visibility & 4 ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= 4, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));\n                includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                break;\n            case 24:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                break;\n            default:\n                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n        }\n    }\n    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case 22:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);\n                    break;\n                case 24:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                    flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n                    break;\n                default:\n                    recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n            }\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n        if (parentFiber.subtreeFlags & suspenseyCommitFlag) for(parentFiber = parentFiber.child; null !== parentFiber;)accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function accumulateSuspenseyCommitOnFiber(fiber) {\n        switch(fiber.tag){\n            case 26:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && (null !== fiber.memoizedState ? suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps) : suspendInstance(fiber.type, fiber.memoizedProps));\n                break;\n            case 5:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n                fiber.flags & suspenseyCommitFlag && suspendInstance(fiber.type, fiber.memoizedProps);\n                break;\n            case 3:\n            case 4:\n                if (supportsResources) {\n                    var previousHoistableRoot = currentHoistableRoot;\n                    currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n                    recursivelyAccumulateSuspenseyCommit(fiber);\n                    currentHoistableRoot = previousHoistableRoot;\n                } else recursivelyAccumulateSuspenseyCommit(fiber);\n                break;\n            case 22:\n                null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));\n                break;\n            default:\n                recursivelyAccumulateSuspenseyCommit(fiber);\n        }\n    }\n    function detachAlternateSiblings(parentFiber) {\n        var previousFiber = parentFiber.alternate;\n        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {\n            previousFiber.child = null;\n            do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;\n            while (null !== parentFiber);\n        }\n    }\n    function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        if (parentFiber.subtreeFlags & 10256) for(parentFiber = parentFiber.child; null !== parentFiber;)commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function commitPassiveUnmountOnFiber(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                break;\n            case 3:\n                var prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);\n                break;\n            case 12:\n                prevEffectDuration = pushNestedEffectDurations();\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n                finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);\n                break;\n            case 22:\n                prevEffectDuration = finishedWork.stateNode;\n                null !== finishedWork.memoizedState && prevEffectDuration._visibility & 4 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);\n                break;\n            default:\n                recursivelyTraversePassiveUnmountEffects(finishedWork);\n        }\n    }\n    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n        var deletions = parentFiber.deletions;\n        if (0 !== (parentFiber.flags & 16)) {\n            if (null !== deletions) for(var i = 0; i < deletions.length; i++){\n                var childToDelete = deletions[i];\n                nextEffect = childToDelete;\n                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n            }\n            detachAlternateSiblings(parentFiber);\n        }\n        for(parentFiber = parentFiber.child; null !== parentFiber;)disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;\n    }\n    function disconnectPassiveEffect(finishedWork) {\n        switch(finishedWork.tag){\n            case 0:\n            case 11:\n            case 15:\n                commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                break;\n            case 22:\n                var instance = finishedWork.stateNode;\n                instance._visibility & 4 && (instance._visibility &= -5, recursivelyTraverseDisconnectPassiveEffects(finishedWork));\n                break;\n            default:\n                recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n        }\n    }\n    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n        for(; null !== nextEffect;){\n            var fiber = nextEffect, current = fiber;\n            switch(current.tag){\n                case 0:\n                case 11:\n                case 15:\n                    commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                    break;\n                case 23:\n                case 22:\n                    null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));\n                    break;\n                case 24:\n                    releaseCache(current.memoizedState.cache);\n            }\n            current = fiber.child;\n            if (null !== current) current.return = fiber, nextEffect = current;\n            else a: for(fiber = deletedSubtreeRoot; null !== nextEffect;){\n                current = nextEffect;\n                var sibling = current.sibling, returnFiber = current.return;\n                detachFiberAfterEffects(current);\n                if (current === fiber) {\n                    nextEffect = null;\n                    break a;\n                }\n                if (null !== sibling) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    break a;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n    }\n    function findFiberRootForHostRoot(hostRoot) {\n        var maybeFiber = getInstanceFromNode(hostRoot);\n        if (null != maybeFiber) {\n            if (\"string\" !== typeof maybeFiber.memoizedProps[\"data-testname\"]) throw Error(\"Invalid host root specified. Should be either a React container or a node with a testname attribute.\");\n            return maybeFiber;\n        }\n        hostRoot = findFiberRoot(hostRoot);\n        if (null === hostRoot) throw Error(\"Could not find React container within specified host subtree.\");\n        return hostRoot.stateNode.current;\n    }\n    function matchSelector(fiber$jscomp$0, selector) {\n        var tag = fiber$jscomp$0.tag;\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                if (fiber$jscomp$0.type === selector.value) return !0;\n                break;\n            case HAS_PSEUDO_CLASS_TYPE:\n                a: {\n                    selector = selector.value;\n                    fiber$jscomp$0 = [\n                        fiber$jscomp$0,\n                        0\n                    ];\n                    for(tag = 0; tag < fiber$jscomp$0.length;){\n                        var fiber = fiber$jscomp$0[tag++], tag$jscomp$0 = fiber.tag, selectorIndex = fiber$jscomp$0[tag++], selector$jscomp$0 = selector[selectorIndex];\n                        if (5 !== tag$jscomp$0 && 26 !== tag$jscomp$0 && 27 !== tag$jscomp$0 || !isHiddenSubtree(fiber)) {\n                            for(; null != selector$jscomp$0 && matchSelector(fiber, selector$jscomp$0);)selectorIndex++, selector$jscomp$0 = selector[selectorIndex];\n                            if (selectorIndex === selector.length) {\n                                selector = !0;\n                                break a;\n                            } else for(fiber = fiber.child; null !== fiber;)fiber$jscomp$0.push(fiber, selectorIndex), fiber = fiber.sibling;\n                        }\n                    }\n                    selector = !1;\n                }\n                return selector;\n            case ROLE_TYPE:\n                if ((5 === tag || 26 === tag || 27 === tag) && matchAccessibilityRole(fiber$jscomp$0.stateNode, selector.value)) return !0;\n                break;\n            case TEXT_TYPE:\n                if (5 === tag || 6 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = getTextContent(fiber$jscomp$0), null !== fiber$jscomp$0 && 0 <= fiber$jscomp$0.indexOf(selector.value)) return !0;\n                }\n                break;\n            case TEST_NAME_TYPE:\n                if (5 === tag || 26 === tag || 27 === tag) {\n                    if (fiber$jscomp$0 = fiber$jscomp$0.memoizedProps[\"data-testname\"], \"string\" === typeof fiber$jscomp$0 && fiber$jscomp$0.toLowerCase() === selector.value.toLowerCase()) return !0;\n                }\n                break;\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n        return !1;\n    }\n    function selectorToString(selector) {\n        switch(selector.$$typeof){\n            case COMPONENT_TYPE:\n                return \"<\" + (getComponentNameFromType(selector.value) || \"Unknown\") + \">\";\n            case HAS_PSEUDO_CLASS_TYPE:\n                return \":has(\" + (selectorToString(selector) || \"\") + \")\";\n            case ROLE_TYPE:\n                return '[role=\"' + selector.value + '\"]';\n            case TEXT_TYPE:\n                return '\"' + selector.value + '\"';\n            case TEST_NAME_TYPE:\n                return '[data-testname=\"' + selector.value + '\"]';\n            default:\n                throw Error(\"Invalid selector type specified.\");\n        }\n    }\n    function findPaths(root, selectors) {\n        var matchingFibers = [];\n        root = [\n            root,\n            0\n        ];\n        for(var index = 0; index < root.length;){\n            var fiber = root[index++], tag = fiber.tag, selectorIndex = root[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                for(; null != selector && matchSelector(fiber, selector);)selectorIndex++, selector = selectors[selectorIndex];\n                if (selectorIndex === selectors.length) matchingFibers.push(fiber);\n                else for(fiber = fiber.child; null !== fiber;)root.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        return matchingFibers;\n    }\n    function findAllNodes(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        hostRoot = findPaths(hostRoot, selectors);\n        selectors = [];\n        hostRoot = Array.from(hostRoot);\n        for(var index = 0; index < hostRoot.length;){\n            var node = hostRoot[index++], tag = node.tag;\n            if (5 === tag || 26 === tag || 27 === tag) isHiddenSubtree(node) || selectors.push(node.stateNode);\n            else for(node = node.child; null !== node;)hostRoot.push(node), node = node.sibling;\n        }\n        return selectors;\n    }\n    function onCommitRoot() {\n        supportsTestSelectors && commitHooks.forEach(function(commitHook) {\n            return commitHook();\n        });\n    }\n    function isConcurrentActEnvironment() {\n        var isReactActEnvironmentGlobal = \"undefined\" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;\n        isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(\"The current testing environment is not configured to support act(...)\");\n        return isReactActEnvironmentGlobal;\n    }\n    function requestUpdateLane(fiber) {\n        if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n        var transition = ReactSharedInternals.T;\n        return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();\n    }\n    function requestDeferredLane() {\n        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);\n        var suspenseHandler = suspenseHandlerStackCursor.current;\n        null !== suspenseHandler && (suspenseHandler.flags |= 32);\n        return workInProgressDeferredLane;\n    }\n    function scheduleUpdateOnFiber(root, fiber, lane) {\n        isRunningInsertionEffect && console.error(\"useInsertionEffect must not schedule updates.\");\n        isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);\n        if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n        markRootUpdated$1(root, lane);\n        if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {\n            if (isRendering) switch(fiber.tag){\n                case 0:\n                case 11:\n                case 15:\n                    root = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                    didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || \"Unknown\", console.error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render\", fiber, root, root));\n                    break;\n                case 1:\n                    didWarnAboutUpdateInRender || (console.error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\"), didWarnAboutUpdateInRender = !0);\n            }\n        } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);\n    }\n    function performWorkOnRoot(root, lanes, forceSync) {\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0), renderWasConcurrent = shouldTimeSlice;\n        do {\n            if (exitStatus === RootInProgress) {\n                workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);\n                break;\n            } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);\n            else {\n                forceSync = root.current.alternate;\n                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {\n                    exitStatus = renderRootSync(root, lanes, !1);\n                    renderWasConcurrent = !1;\n                    continue;\n                }\n                if (exitStatus === RootErrored) {\n                    renderWasConcurrent = lanes;\n                    if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;\n                    else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;\n                    if (0 !== errorRetryLanes) {\n                        lanes = errorRetryLanes;\n                        a: {\n                            exitStatus = root;\n                            var errorRetryLanes$jscomp$0 = errorRetryLanes;\n                            errorRetryLanes = workInProgressRootConcurrentErrors;\n                            var wasRootDehydrated = supportsHydration && exitStatus.current.memoizedState.isDehydrated;\n                            wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);\n                            errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);\n                            if (errorRetryLanes$jscomp$0 !== RootErrored) {\n                                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                                    exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;\n                                    exitStatus = RootSuspendedWithDelay;\n                                    break a;\n                                }\n                                exitStatus = workInProgressRootRecoverableErrors;\n                                workInProgressRootRecoverableErrors = errorRetryLanes;\n                                null !== exitStatus && queueRecoverableErrors(exitStatus);\n                            }\n                            exitStatus = errorRetryLanes$jscomp$0;\n                        }\n                        renderWasConcurrent = !1;\n                        if (exitStatus !== RootErrored) continue;\n                    }\n                }\n                if (exitStatus === RootFatalErrored) {\n                    prepareFreshStack(root, 0);\n                    markRootSuspended(root, lanes, 0, !0);\n                    break;\n                }\n                a: {\n                    shouldTimeSlice = root;\n                    switch(exitStatus){\n                        case RootInProgress:\n                        case RootFatalErrored:\n                            throw Error(\"Root did not complete. This is a bug in React.\");\n                        case RootSuspendedWithDelay:\n                            if ((lanes & 4194176) === lanes) {\n                                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                                break a;\n                            }\n                            break;\n                        case RootErrored:\n                            workInProgressRootRecoverableErrors = null;\n                            break;\n                        case RootSuspended:\n                        case RootCompleted:\n                            break;\n                        default:\n                            throw Error(\"Unknown root exit status.\");\n                    }\n                    shouldTimeSlice.finishedWork = forceSync;\n                    shouldTimeSlice.finishedLanes = lanes;\n                    if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, -0, 0);\n                    else {\n                        if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {\n                            markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);\n                            if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n                            shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, -0, 0), exitStatus);\n                            break a;\n                        }\n                        commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, -0, 0);\n                    }\n                }\n            }\n            break;\n        }while (1);\n        ensureRootIsScheduled(root);\n    }\n    function queueRecoverableErrors(errors) {\n        null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n    }\n    function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var subtreeFlags = finishedWork.subtreeFlags;\n        if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) {\n            if (startSuspendingCommit(), accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {\n                root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));\n                markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n                return;\n            }\n        }\n        commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n    }\n    function isRenderConsistentWithExternalStores(finishedWork) {\n        for(var node = finishedWork;;){\n            var tag = node.tag;\n            if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for(var i = 0; i < tag.length; i++){\n                var check = tag[i], getSnapshot = check.getSnapshot;\n                check = check.value;\n                try {\n                    if (!objectIs(getSnapshot(), check)) return !1;\n                } catch (error) {\n                    return !1;\n                }\n            }\n            tag = node.child;\n            if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;\n            else {\n                if (node === finishedWork) break;\n                for(; null === node.sibling;){\n                    if (null === node.return || node.return === finishedWork) return !0;\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        return !0;\n    }\n    function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {\n        suspendedLanes &= ~workInProgressRootPingedLanes;\n        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n        root.suspendedLanes |= suspendedLanes;\n        root.pingedLanes &= ~suspendedLanes;\n        didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n        didAttemptEntireTree = root.expirationTimes;\n        for(var lanes = suspendedLanes; 0 < lanes;){\n            var index = 31 - clz32(lanes), lane = 1 << index;\n            didAttemptEntireTree[index] = -1;\n            lanes &= ~lane;\n        }\n        0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n    }\n    function flushSyncWork() {\n        return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;\n    }\n    function resetWorkInProgressStack() {\n        if (null !== workInProgress) {\n            if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;\n            else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;\n            for(; null !== interruptedWork;)unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;\n            workInProgress = null;\n        }\n    }\n    function prepareFreshStack(root, lanes) {\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        var timeoutHandle = root.timeoutHandle;\n        timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));\n        timeoutHandle = root.cancelPendingCommit;\n        null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());\n        resetWorkInProgressStack();\n        workInProgressRoot = root;\n        workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n        workInProgressRootRenderLanes = lanes;\n        workInProgressSuspendedReason = NotSuspended;\n        workInProgressThrownValue = null;\n        workInProgressRootDidSkipSuspendedSiblings = !1;\n        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        workInProgressRootDidAttachPingListener = !1;\n        workInProgressRootExitStatus = RootInProgress;\n        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;\n        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;\n        workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n        0 !== (lanes & 8) && (lanes |= lanes & 32);\n        var allEntangledLanes = root.entangledLanes;\n        if (0 !== allEntangledLanes) for(root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;){\n            var index = 31 - clz32(allEntangledLanes), lane = 1 << index;\n            lanes |= root[index];\n            allEntangledLanes &= ~lane;\n        }\n        entangledRenderLanes = lanes;\n        finishQueueingConcurrentUpdates();\n        ReactStrictModeWarnings.discardPendingWarnings();\n        return timeoutHandle;\n    }\n    function handleThrow(root, thrownValue) {\n        currentlyRenderingFiber$1 = null;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        ReactSharedInternals.getCurrentStack = null;\n        isRendering = !1;\n        current = null;\n        thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && \"object\" === typeof thrownValue && \"function\" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;\n        workInProgressThrownValue = thrownValue;\n        var erroredWork = workInProgress;\n        if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n        else switch(erroredWork.mode & 2 && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason){\n            case SuspendedOnError:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                break;\n            case SuspendedOnData:\n            case SuspendedOnImmediate:\n            case SuspendedOnDeprecatedThrowPromise:\n            case SuspendedAndReadyToContinue:\n                null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n    }\n    function shouldRemainOnPreviousScreen() {\n        var handler = suspenseHandlerStackCursor.current;\n        return null === handler ? !0 : (workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null === shellBoundary ? !0 : !1 : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : !1;\n    }\n    function pushDispatcher() {\n        var prevDispatcher = ReactSharedInternals.H;\n        ReactSharedInternals.H = ContextOnlyDispatcher;\n        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n    }\n    function pushAsyncDispatcher() {\n        var prevAsyncDispatcher = ReactSharedInternals.A;\n        ReactSharedInternals.A = DefaultAsyncDispatcher;\n        return prevAsyncDispatcher;\n    }\n    function renderDidSuspendDelayIfPossible() {\n        workInProgressRootExitStatus = RootSuspendedWithDelay;\n        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);\n        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);\n    }\n    function renderRootSync(root, lanes, shouldYieldForPrerendering) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            prepareFreshStack(root, lanes);\n        }\n        markRenderStarted(lanes);\n        lanes = !1;\n        memoizedUpdaters = workInProgressRootExitStatus;\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {\n                var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnHydration:\n                        resetWorkInProgressStack();\n                        memoizedUpdaters = RootDidNotComplete;\n                        break a;\n                    case SuspendedOnImmediate:\n                    case SuspendedOnData:\n                    case SuspendedOnDeprecatedThrowPromise:\n                        null === suspenseHandlerStackCursor.current && (lanes = !0);\n                        var reason = workInProgressSuspendedReason;\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                        if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {\n                            memoizedUpdaters = RootInProgress;\n                            break a;\n                        }\n                        break;\n                    default:\n                        reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n                }\n            }\n            workLoopSync();\n            memoizedUpdaters = workInProgressRootExitStatus;\n            break;\n        } catch (thrownValue$4) {\n            handleThrow(root, thrownValue$4);\n        }\n        while (1);\n        lanes && root.shellSuspendCounter++;\n        resetContextDependencies();\n        executionContext = prevExecutionContext;\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        markRenderStopped();\n        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());\n        return memoizedUpdaters;\n    }\n    function workLoopSync() {\n        for(; null !== workInProgress;)performUnitOfWork(workInProgress);\n    }\n    function renderRootConcurrent(root, lanes) {\n        var prevExecutionContext = executionContext;\n        executionContext |= RenderContext;\n        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();\n        if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n            if (isDevToolsPresent) {\n                var memoizedUpdaters = root.memoizedUpdaters;\n                0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());\n                movePendingFibersToMemoized(root, lanes);\n            }\n            workInProgressTransitions = null;\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n            prepareFreshStack(root, lanes);\n        } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n        markRenderStarted(lanes);\n        a: do try {\n            if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch(lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason){\n                case SuspendedOnError:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);\n                    break;\n                case SuspendedOnData:\n                    if (isThenableResolved(memoizedUpdaters)) {\n                        workInProgressSuspendedReason = NotSuspended;\n                        workInProgressThrownValue = null;\n                        replaySuspendedUnitOfWork(lanes);\n                        break;\n                    }\n                    lanes = function() {\n                        workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);\n                        ensureRootIsScheduled(root);\n                    };\n                    memoizedUpdaters.then(lanes, lanes);\n                    break a;\n                case SuspendedOnImmediate:\n                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                    break a;\n                case SuspendedOnInstance:\n                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                    break a;\n                case SuspendedAndReadyToContinue:\n                    isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));\n                    break;\n                case SuspendedOnInstanceAndReadyToContinue:\n                    var resource = null;\n                    switch(workInProgress.tag){\n                        case 26:\n                            resource = workInProgress.memoizedState;\n                        case 5:\n                        case 27:\n                            var hostFiber = workInProgress, type = hostFiber.type, props = hostFiber.pendingProps;\n                            if (resource ? preloadResource(resource) : preloadInstance(type, props)) {\n                                workInProgressSuspendedReason = NotSuspended;\n                                workInProgressThrownValue = null;\n                                var sibling = hostFiber.sibling;\n                                if (null !== sibling) workInProgress = sibling;\n                                else {\n                                    var returnFiber = hostFiber.return;\n                                    null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;\n                                }\n                                break b;\n                            }\n                            break;\n                        default:\n                            console.error(\"Unexpected type of fiber triggered a suspensey commit. This is a bug in React.\");\n                    }\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);\n                    break;\n                case SuspendedOnDeprecatedThrowPromise:\n                    workInProgressSuspendedReason = NotSuspended;\n                    workInProgressThrownValue = null;\n                    throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);\n                    break;\n                case SuspendedOnHydration:\n                    resetWorkInProgressStack();\n                    workInProgressRootExitStatus = RootDidNotComplete;\n                    break a;\n                default:\n                    throw Error(\"Unexpected SuspendedReason. This is a bug in React.\");\n            }\n            null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();\n            break;\n        } catch (thrownValue$5) {\n            handleThrow(root, thrownValue$5);\n        }\n        while (1);\n        resetContextDependencies();\n        ReactSharedInternals.H = prevDispatcher;\n        ReactSharedInternals.A = prevAsyncDispatcher;\n        executionContext = prevExecutionContext;\n        if (null !== workInProgress) return null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;\n        markRenderStopped();\n        workInProgressRoot = null;\n        workInProgressRootRenderLanes = 0;\n        finishQueueingConcurrentUpdates();\n        return workInProgressRootExitStatus;\n    }\n    function workLoopConcurrent() {\n        for(; null !== workInProgress && !shouldYield();)performUnitOfWork(workInProgress);\n    }\n    function performUnitOfWork(unitOfWork) {\n        var current = unitOfWork.alternate;\n        (unitOfWork.mode & 2) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;\n    }\n    function replaySuspendedUnitOfWork(unitOfWork) {\n        var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);\n        unitOfWork.memoizedProps = unitOfWork.pendingProps;\n        null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;\n    }\n    function replayBeginWork(unitOfWork) {\n        var current = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & 2) !== NoMode;\n        isProfilingMode && startProfilerTimer(unitOfWork);\n        switch(unitOfWork.tag){\n            case 15:\n            case 0:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);\n                break;\n            case 11:\n                current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);\n                break;\n            case 5:\n                resetHooksOnUnwind(unitOfWork);\n            default:\n                unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);\n        }\n        isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);\n        return current;\n    }\n    function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {\n        resetContextDependencies();\n        resetHooksOnUnwind(unitOfWork);\n        thenableState$1 = null;\n        thenableIndexCounter$1 = 0;\n        var returnFiber = unitOfWork.return;\n        try {\n            if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                workInProgress = null;\n                return;\n            }\n        } catch (error) {\n            if (null !== returnFiber) throw workInProgress = returnFiber, error;\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n            workInProgress = null;\n            return;\n        }\n        if (unitOfWork.flags & 32768) {\n            if (isHydrating || suspendedReason === SuspendedOnError) root = !0;\n            else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;\n            else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);\n            unwindUnitOfWork(unitOfWork, root);\n        } else completeUnitOfWork(unitOfWork);\n    }\n    function completeUnitOfWork(unitOfWork) {\n        var completedWork = unitOfWork;\n        do {\n            if (0 !== (completedWork.flags & 32768)) {\n                unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);\n                return;\n            }\n            var current = completedWork.alternate;\n            unitOfWork = completedWork.return;\n            startProfilerTimer(completedWork);\n            current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);\n            (completedWork.mode & 2) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);\n            if (null !== current) {\n                workInProgress = current;\n                return;\n            }\n            completedWork = completedWork.sibling;\n            if (null !== completedWork) {\n                workInProgress = completedWork;\n                return;\n            }\n            workInProgress = completedWork = unitOfWork;\n        }while (null !== completedWork);\n        workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);\n    }\n    function unwindUnitOfWork(unitOfWork, skipSiblings) {\n        do {\n            var next = unwindWork(unitOfWork.alternate, unitOfWork);\n            if (null !== next) {\n                next.flags &= 32767;\n                workInProgress = next;\n                return;\n            }\n            if ((unitOfWork.mode & 2) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);\n                next = unitOfWork.actualDuration;\n                for(var child = unitOfWork.child; null !== child;)next += child.actualDuration, child = child.sibling;\n                unitOfWork.actualDuration = next;\n            }\n            next = unitOfWork.return;\n            null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);\n            if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {\n                workInProgress = unitOfWork;\n                return;\n            }\n            workInProgress = unitOfWork = next;\n        }while (null !== unitOfWork);\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n    }\n    function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {\n        var prevTransition = ReactSharedInternals.T, previousUpdateLanePriority = getCurrentUpdatePriority();\n        try {\n            setCurrentUpdatePriority(2), ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);\n        } finally{\n            ReactSharedInternals.T = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);\n        }\n    }\n    function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {\n        do flushPassiveEffects();\n        while (null !== rootWithPendingPassiveEffects);\n        ReactStrictModeWarnings.flushLegacyContextWarning();\n        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Should not already be working.\");\n        var finishedWork = root.finishedWork;\n        didIncludeRenderPhaseUpdate = root.finishedLanes;\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);\n        if (null === finishedWork) return markCommitStopped(), null;\n        0 === didIncludeRenderPhaseUpdate && console.error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n        root.finishedWork = null;\n        root.finishedLanes = 0;\n        if (finishedWork === root.current) throw Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n        root.callbackNode = null;\n        root.callbackPriority = 0;\n        root.cancelPendingCommit = null;\n        var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n        remainingLanes |= concurrentlyUpdatedLanes;\n        markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);\n        root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);\n        0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback(NormalPriority$1, function() {\n            flushPassiveEffects(!0);\n            return null;\n        }));\n        commitStartTime = now();\n        transitions = 0 !== (finishedWork.flags & 15990);\n        0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = getCurrentUpdatePriority(), setCurrentUpdatePriority(2), updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), resetAfterCommit(root.containerInfo), root.current = finishedWork, null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, setCurrentUpdatePriority(spawnedLane), ReactSharedInternals.T = transitions) : root.current = finishedWork;\n        (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);\n        remainingLanes = root.pendingLanes;\n        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n        transitions || commitDoubleInvokeEffectsInDEV(root);\n        onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n        isDevToolsPresent && root.memoizedUpdaters.clear();\n        onCommitRoot();\n        ensureRootIsScheduled(root);\n        if (null !== recoverableErrors) for(renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++)remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);\n        0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n        remainingLanes = root.pendingLanes;\n        0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        markCommitStopped();\n        return null;\n    }\n    function makeErrorInfo(componentStack) {\n        componentStack = {\n            componentStack: componentStack\n        };\n        Object.defineProperty(componentStack, \"digest\", {\n            get: function() {\n                console.error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');\n            }\n        });\n        return componentStack;\n    }\n    function releaseRootPooledCache(root, remainingLanes) {\n        0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));\n    }\n    function flushPassiveEffects() {\n        if (null !== rootWithPendingPassiveEffects) {\n            var root = rootWithPendingPassiveEffects, remainingLanes = pendingPassiveEffectsRemainingLanes;\n            pendingPassiveEffectsRemainingLanes = 0;\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = 32 > renderPriority ? 32 : renderPriority;\n            renderPriority = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(priority);\n                ReactSharedInternals.T = null;\n                if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;\n                else {\n                    priority = pendingPassiveTransitions;\n                    pendingPassiveTransitions = null;\n                    var root$jscomp$0 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;\n                    rootWithPendingPassiveEffects = null;\n                    pendingPassiveEffectsLanes = 0;\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error(\"Cannot flush passive effects while already rendering.\");\n                    isFlushingPassiveEffects = !0;\n                    didScheduleUpdateDuringPassiveEffects = !1;\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                    var prevExecutionContext = executionContext;\n                    executionContext |= CommitContext;\n                    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n                    commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);\n                    null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();\n                    commitDoubleInvokeEffectsInDEV(root$jscomp$0);\n                    executionContext = prevExecutionContext;\n                    flushSyncWorkAcrossRoots_impl(0, !1);\n                    didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;\n                    didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;\n                    if (injectedHook && \"function\" === typeof injectedHook.onPostCommitFiberRoot) try {\n                        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n                    } catch (err) {\n                        hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n                    }\n                    var stateNode = root$jscomp$0.current.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                    JSCompiler_inline_result = !0;\n                }\n                return JSCompiler_inline_result;\n            } finally{\n                setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);\n            }\n        }\n        return !1;\n    }\n    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n    }\n    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n        isRunningInsertionEffect = !1;\n        if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n        else {\n            for(; null !== nearestMountedAncestor;){\n                if (3 === nearestMountedAncestor.tag) {\n                    captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);\n                    return;\n                }\n                if (1 === nearestMountedAncestor.tag) {\n                    var instance = nearestMountedAncestor.stateNode;\n                    if (\"function\" === typeof nearestMountedAncestor.type.getDerivedStateFromError || \"function\" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {\n                        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n                        error = createClassErrorUpdate(2);\n                        instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n                        null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));\n                        return;\n                    }\n                }\n                nearestMountedAncestor = nearestMountedAncestor.return;\n            }\n            console.error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error);\n        }\n    }\n    function attachPingListener(root, wakeable, lanes) {\n        var pingCache = root.pingCache;\n        if (null === pingCache) {\n            pingCache = root.pingCache = new PossiblyWeakMap();\n            var threadIDs = new Set();\n            pingCache.set(wakeable, threadIDs);\n        } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));\n        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));\n    }\n    function pingSuspendedRoot(root, wakeable, pingedLanes) {\n        var pingCache = root.pingCache;\n        null !== pingCache && pingCache.delete(wakeable);\n        root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        root.warmLanes &= ~pingedLanes;\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\");\n        workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));\n        ensureRootIsScheduled(root);\n    }\n    function retryTimedOutBoundary(boundaryFiber, retryLane) {\n        0 === retryLane && (retryLane = claimNextRetryLane());\n        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));\n    }\n    function retryDehydratedSuspenseBoundary(boundaryFiber) {\n        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;\n        null !== suspenseState && (retryLane = suspenseState.retryLane);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function resolveRetryWakeable(boundaryFiber, wakeable) {\n        var retryLane = 0;\n        switch(boundaryFiber.tag){\n            case 13:\n                var retryCache = boundaryFiber.stateNode;\n                var suspenseState = boundaryFiber.memoizedState;\n                null !== suspenseState && (retryLane = suspenseState.retryLane);\n                break;\n            case 19:\n                retryCache = boundaryFiber.stateNode;\n                break;\n            case 22:\n                retryCache = boundaryFiber.stateNode._retryCache;\n                break;\n            default:\n                throw Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n        }\n        null !== retryCache && retryCache.delete(wakeable);\n        retryTimedOutBoundary(boundaryFiber, retryLane);\n    }\n    function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {\n        if (0 !== (parentFiber.subtreeFlags & 33562624)) for(parentFiber = parentFiber.child; null !== parentFiber;){\n            var root = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            isStrictModeFiber = isInStrictMode || isStrictModeFiber;\n            22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & 64) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));\n            parentFiber = parentFiber.sibling;\n        }\n    }\n    function doubleInvokeEffectsOnFiber(root, fiber) {\n        var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;\n        setIsStrictModeForDevtools(!0);\n        try {\n            disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);\n        } finally{\n            setIsStrictModeForDevtools(!1);\n        }\n    }\n    function commitDoubleInvokeEffectsInDEV(root) {\n        var doubleInvokeEffects = !0;\n        root.current.mode & 24 || (doubleInvokeEffects = !1);\n        recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n    }\n    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n        if ((executionContext & RenderContext) === NoContext) {\n            var tag = fiber.tag;\n            if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {\n                tag = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n                if (null !== didWarnStateUpdateForNotYetMountedComponent) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;\n                    didWarnStateUpdateForNotYetMountedComponent.add(tag);\n                } else didWarnStateUpdateForNotYetMountedComponent = new Set([\n                    tag\n                ]);\n                runWithFiberInDEV(fiber, function() {\n                    console.error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n                });\n            }\n        }\n    }\n    function restorePendingUpdaters(root, lanes) {\n        isDevToolsPresent && root.memoizedUpdaters.forEach(function(schedulingFiber) {\n            addFiberToLanesMap(root, schedulingFiber, lanes);\n        });\n    }\n    function scheduleCallback(priorityLevel, callback) {\n        var actQueue = ReactSharedInternals.actQueue;\n        return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback$3(priorityLevel, callback);\n    }\n    function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n        isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {\n            console.error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n        });\n    }\n    function resolveFunctionForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? type : family.current;\n    }\n    function resolveForwardRefForHotReloading(type) {\n        if (null === resolveFamily) return type;\n        var family = resolveFamily(type);\n        return void 0 === family ? null !== type && void 0 !== type && \"function\" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: family\n        }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;\n    }\n    function isCompatibleFamilyForHotReloading(fiber, element) {\n        if (null === resolveFamily) return !1;\n        var prevType = fiber.elementType;\n        element = element.type;\n        var needsCompareFamilies = !1, $$typeofNextType = \"object\" === typeof element && null !== element ? element.$$typeof : null;\n        switch(fiber.tag){\n            case 1:\n                \"function\" === typeof element && (needsCompareFamilies = !0);\n                break;\n            case 0:\n                \"function\" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 11:\n                $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            case 14:\n            case 15:\n                $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);\n                break;\n            default:\n                return !1;\n        }\n        return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;\n    }\n    function markFailedErrorBoundaryForHotReloading(fiber) {\n        null !== resolveFamily && \"function\" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));\n    }\n    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;\n        switch(tag){\n            case 0:\n            case 15:\n            case 1:\n                candidateType = type;\n                break;\n            case 11:\n                candidateType = type.render;\n        }\n        if (null === resolveFamily) throw Error(\"Expected resolveFamily to be set during hot reload.\");\n        var needsRender = !1;\n        type = !1;\n        null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));\n        null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);\n        type && (fiber._debugNeedsRemount = !0);\n        if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);\n        null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n        null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n    function FiberNode(tag, pendingProps, key, mode) {\n        this.tag = tag;\n        this.key = key;\n        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;\n        this.index = 0;\n        this.refCleanup = this.ref = null;\n        this.pendingProps = pendingProps;\n        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;\n        this.mode = mode;\n        this.subtreeFlags = this.flags = 0;\n        this.deletions = null;\n        this.childLanes = this.lanes = 0;\n        this.alternate = null;\n        this.actualDuration = -0;\n        this.actualStartTime = -1.1;\n        this.treeBaseDuration = this.selfBaseDuration = -0;\n        this._debugOwner = this._debugInfo = null;\n        this._debugNeedsRemount = !1;\n        this._debugHookTypes = null;\n        hasBadMapPolyfill || \"function\" !== typeof Object.preventExtensions || Object.preventExtensions(this);\n    }\n    function shouldConstruct(Component) {\n        Component = Component.prototype;\n        return !(!Component || !Component.isReactComponent);\n    }\n    function createWorkInProgress(current, pendingProps) {\n        var workInProgress = current.alternate;\n        null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);\n        workInProgress.flags = current.flags & 31457280;\n        workInProgress.childLanes = current.childLanes;\n        workInProgress.lanes = current.lanes;\n        workInProgress.child = current.child;\n        workInProgress.memoizedProps = current.memoizedProps;\n        workInProgress.memoizedState = current.memoizedState;\n        workInProgress.updateQueue = current.updateQueue;\n        pendingProps = current.dependencies;\n        workInProgress.dependencies = null === pendingProps ? null : {\n            lanes: pendingProps.lanes,\n            firstContext: pendingProps.firstContext,\n            _debugThenableState: pendingProps._debugThenableState\n        };\n        workInProgress.sibling = current.sibling;\n        workInProgress.index = current.index;\n        workInProgress.ref = current.ref;\n        workInProgress.refCleanup = current.refCleanup;\n        workInProgress.selfBaseDuration = current.selfBaseDuration;\n        workInProgress.treeBaseDuration = current.treeBaseDuration;\n        workInProgress._debugInfo = current._debugInfo;\n        workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n        switch(workInProgress.tag){\n            case 0:\n            case 15:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 1:\n                workInProgress.type = resolveFunctionForHotReloading(current.type);\n                break;\n            case 11:\n                workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        }\n        return workInProgress;\n    }\n    function resetWorkInProgress(workInProgress, renderLanes) {\n        workInProgress.flags &= 31457282;\n        var current = workInProgress.alternate;\n        null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {\n            lanes: renderLanes.lanes,\n            firstContext: renderLanes.firstContext,\n            _debugThenableState: renderLanes._debugThenableState\n        }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);\n        return workInProgress;\n    }\n    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n        var fiberTag = 0, resolvedType = type;\n        if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);\n        else if (\"string\" === typeof type) supportsResources && supportsSingletons ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : isHostSingletonType(type) ? 27 : 5) : supportsResources ? (fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : 5) : fiberTag = supportsSingletons ? isHostSingletonType(type) ? 27 : 5 : 5;\n        else a: switch(type){\n            case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n            case REACT_STRICT_MODE_TYPE:\n                fiberTag = 8;\n                mode |= 24;\n                break;\n            case REACT_PROFILER_TYPE:\n                return type = pendingProps, owner = mode, \"string\" !== typeof type.id && console.error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | 2), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                }, key;\n            case REACT_SUSPENSE_TYPE:\n                return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;\n            case REACT_SUSPENSE_LIST_TYPE:\n                return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;\n            case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n            default:\n                if (\"object\" === typeof type && null !== type) switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                    case REACT_CONTEXT_TYPE:\n                        fiberTag = 10;\n                        break a;\n                    case REACT_CONSUMER_TYPE:\n                        fiberTag = 9;\n                        break a;\n                    case REACT_FORWARD_REF_TYPE:\n                        fiberTag = 11;\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                        break a;\n                    case REACT_MEMO_TYPE:\n                        fiberTag = 14;\n                        break a;\n                    case REACT_LAZY_TYPE:\n                        fiberTag = 16;\n                        resolvedType = null;\n                        break a;\n                }\n                resolvedType = \"\";\n                if (void 0 === type || \"object\" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                null === type ? pendingProps = \"null\" : isArrayImpl(type) ? pendingProps = \"array\" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\", resolvedType = \" Did you accidentally export a JSX literal instead of a component?\") : pendingProps = typeof type;\n                fiberTag = owner ? \"number\" === typeof owner.tag ? getComponentNameFromFiber(owner) : \"string\" === typeof owner.name ? owner.name : null : null;\n                fiberTag && (resolvedType += \"\\n\\nCheck the render method of `\" + fiberTag + \"`.\");\n                fiberTag = 29;\n                pendingProps = Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: \" + (pendingProps + \".\" + resolvedType));\n                resolvedType = null;\n        }\n        key = createFiber(fiberTag, pendingProps, key, mode);\n        key.elementType = type;\n        key.type = resolvedType;\n        key.lanes = lanes;\n        key._debugOwner = owner;\n        return key;\n    }\n    function createFiberFromElement(element, mode, lanes) {\n        mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);\n        mode._debugOwner = element._owner;\n        return mode;\n    }\n    function createFiberFromFragment(elements, mode, lanes, key) {\n        elements = createFiber(7, elements, key, mode);\n        elements.lanes = lanes;\n        return elements;\n    }\n    function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n        pendingProps = createFiber(22, pendingProps, key, mode);\n        pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n        pendingProps.lanes = lanes;\n        var primaryChildInstance = {\n            _visibility: 1,\n            _pendingVisibility: 1,\n            _pendingMarkers: null,\n            _retryCache: null,\n            _transitions: null,\n            _current: null,\n            detach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 === (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility |= 2, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            },\n            attach: function() {\n                var instance = primaryChildInstance, fiber = instance._current;\n                if (null === fiber) throw Error(\"Calling Offscreen.detach before instance handle has been set.\");\n                if (0 !== (instance._pendingVisibility & 2)) {\n                    var root = enqueueConcurrentRenderForLane(fiber, 2);\n                    null !== root && (instance._pendingVisibility &= -3, scheduleUpdateOnFiber(root, fiber, 2));\n                }\n            }\n        };\n        pendingProps.stateNode = primaryChildInstance;\n        return pendingProps;\n    }\n    function createFiberFromText(content, mode, lanes) {\n        content = createFiber(6, content, null, mode);\n        content.lanes = lanes;\n        return content;\n    }\n    function createFiberFromPortal(portal, mode, lanes) {\n        mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);\n        mode.lanes = lanes;\n        mode.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            implementation: portal.implementation\n        };\n        return mode;\n    }\n    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n        this.tag = 1;\n        this.containerInfo = containerInfo;\n        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;\n        this.timeoutHandle = noTimeout;\n        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;\n        this.callbackPriority = 0;\n        this.expirationTimes = createLaneMap(-1);\n        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;\n        this.entanglements = createLaneMap(0);\n        this.hiddenUpdates = createLaneMap(null);\n        this.identifierPrefix = identifierPrefix;\n        this.onUncaughtError = onUncaughtError;\n        this.onCaughtError = onCaughtError;\n        this.onRecoverableError = onRecoverableError;\n        this.pooledCache = null;\n        this.pooledCacheLanes = 0;\n        this.formState = formState;\n        this.incompleteTransitions = new Map();\n        this.passiveEffectDuration = this.effectDuration = -0;\n        this.memoizedUpdaters = new Set();\n        containerInfo = this.pendingUpdatersLaneMap = [];\n        for(tag = 0; 31 > tag; tag++)containerInfo.push(new Set());\n        this._debugRootType = hydrate ? \"hydrateRoot()\" : \"createRoot()\";\n    }\n    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n        tag = 1;\n        !0 === isStrictMode && (tag |= 24);\n        isDevToolsPresent && (tag |= 2);\n        isStrictMode = createFiber(3, null, null, tag);\n        containerInfo.current = isStrictMode;\n        isStrictMode.stateNode = containerInfo;\n        tag = createCache();\n        retainCache(tag);\n        containerInfo.pooledCache = tag;\n        retainCache(tag);\n        isStrictMode.memoizedState = {\n            element: initialChildren,\n            isDehydrated: hydrate,\n            cache: tag\n        };\n        initializeUpdateQueue(isStrictMode);\n        return containerInfo;\n    }\n    function testStringCoercion(value) {\n        return \"\" + value;\n    }\n    function getContextForSubtree(parentComponent) {\n        if (!parentComponent) return emptyContextObject;\n        parentComponent = emptyContextObject;\n        return parentComponent;\n    }\n    function updateContainerSync(element, container, parentComponent, callback) {\n        0 === container.tag && flushPassiveEffects();\n        updateContainerImpl(container.current, 2, element, container, parentComponent, callback);\n        return 2;\n    }\n    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n        if (injectedHook && \"function\" === typeof injectedHook.onScheduleFiberRoot) try {\n            injectedHook.onScheduleFiberRoot(rendererID, container, element);\n        } catch (err) {\n            hasLoggedError || (hasLoggedError = !0, console.error(\"React instrumentation encountered an error: %s\", err));\n        }\n        null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);\n        parentComponent = getContextForSubtree(parentComponent);\n        null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;\n        isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\"));\n        container = createUpdate(lane);\n        container.payload = {\n            element: element\n        };\n        callback = void 0 === callback ? null : callback;\n        null !== callback && (\"function\" !== typeof callback && console.error(\"Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback), container.callback = callback);\n        element = enqueueUpdate(rootFiber, container, lane);\n        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));\n    }\n    function markRetryLaneImpl(fiber, retryLane) {\n        fiber = fiber.memoizedState;\n        if (null !== fiber && null !== fiber.dehydrated) {\n            var a = fiber.retryLane;\n            fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n        }\n    }\n    function markRetryLaneIfNotHydrated(fiber, retryLane) {\n        markRetryLaneImpl(fiber, retryLane);\n        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n    }\n    function getCurrentFiberForDevTools() {\n        return current;\n    }\n    function getLaneLabelMap() {\n        for(var map = new Map(), lane = 1, index = 0; 31 > index; index++){\n            var label = getLabelForLane(lane);\n            map.set(lane, label);\n            lane *= 2;\n        }\n        return map;\n    }\n    var exports = {};\n    \"use strict\";\n    var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"), Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/scheduler/index.js\"), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"), REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"), REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"), REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"), REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"), REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"), REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"), REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"), REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"), REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"), REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"), REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"), REACT_MEMO_TYPE = Symbol.for(\"react.memo\"), REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n    Symbol.for(\"react.scope\");\n    Symbol.for(\"react.debug_trace_mode\");\n    var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n    Symbol.for(\"react.legacy_hidden\");\n    Symbol.for(\"react.tracing_marker\");\n    var REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix, suffix, reentry = !1;\n    var componentFrameCache = new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var current = null, isRendering = !1, isArrayImpl = Array.isArray, rendererVersion = $$$config.rendererVersion, rendererPackageName = $$$config.rendererPackageName, extraDevToolsConfig = $$$config.extraDevToolsConfig, getPublicInstance = $$$config.getPublicInstance, getRootHostContext = $$$config.getRootHostContext, getChildHostContext = $$$config.getChildHostContext, prepareForCommit = $$$config.prepareForCommit, resetAfterCommit = $$$config.resetAfterCommit, createInstance = $$$config.createInstance, appendInitialChild = $$$config.appendInitialChild, finalizeInitialChildren = $$$config.finalizeInitialChildren, shouldSetTextContent = $$$config.shouldSetTextContent, createTextInstance = $$$config.createTextInstance, scheduleTimeout = $$$config.scheduleTimeout, cancelTimeout = $$$config.cancelTimeout, noTimeout = $$$config.noTimeout, isPrimaryRenderer = $$$config.isPrimaryRenderer;\n    $$$config.warnsIfNotActing;\n    var supportsMutation = $$$config.supportsMutation, supportsPersistence = $$$config.supportsPersistence, supportsHydration = $$$config.supportsHydration, getInstanceFromNode = $$$config.getInstanceFromNode;\n    $$$config.beforeActiveInstanceBlur;\n    $$$config.afterActiveInstanceBlur;\n    var preparePortalMount = $$$config.preparePortalMount;\n    $$$config.prepareScopeUpdate;\n    $$$config.getInstanceFromScope;\n    var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority, getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority, resolveUpdatePriority = $$$config.resolveUpdatePriority;\n    $$$config.resolveEventType;\n    $$$config.resolveEventTimeStamp;\n    var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition, detachDeletedInstance = $$$config.detachDeletedInstance;\n    $$$config.requestPostPaintCallback;\n    var maySuspendCommit = $$$config.maySuspendCommit, preloadInstance = $$$config.preloadInstance, startSuspendingCommit = $$$config.startSuspendingCommit, suspendInstance = $$$config.suspendInstance, waitForCommitToBeReady = $$$config.waitForCommitToBeReady, NotPendingTransition = $$$config.NotPendingTransition, HostTransitionContext = $$$config.HostTransitionContext, resetFormInstance = $$$config.resetFormInstance, bindToConsole = $$$config.bindToConsole, supportsMicrotasks = $$$config.supportsMicrotasks, scheduleMicrotask = $$$config.scheduleMicrotask, supportsTestSelectors = $$$config.supportsTestSelectors, findFiberRoot = $$$config.findFiberRoot, getBoundingRect = $$$config.getBoundingRect, getTextContent = $$$config.getTextContent, isHiddenSubtree = $$$config.isHiddenSubtree, matchAccessibilityRole = $$$config.matchAccessibilityRole, setFocusIfFocusable = $$$config.setFocusIfFocusable, setupIntersectionObserver = $$$config.setupIntersectionObserver, appendChild = $$$config.appendChild, appendChildToContainer = $$$config.appendChildToContainer, commitTextUpdate = $$$config.commitTextUpdate, commitMount = $$$config.commitMount, commitUpdate = $$$config.commitUpdate, insertBefore = $$$config.insertBefore, insertInContainerBefore = $$$config.insertInContainerBefore, removeChild = $$$config.removeChild, removeChildFromContainer = $$$config.removeChildFromContainer, resetTextContent = $$$config.resetTextContent, hideInstance = $$$config.hideInstance, hideTextInstance = $$$config.hideTextInstance, unhideInstance = $$$config.unhideInstance, unhideTextInstance = $$$config.unhideTextInstance, clearContainer = $$$config.clearContainer, cloneInstance = $$$config.cloneInstance, createContainerChildSet = $$$config.createContainerChildSet, appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet, finalizeContainerChildren = $$$config.finalizeContainerChildren, replaceContainerChildren = $$$config.replaceContainerChildren, cloneHiddenInstance = $$$config.cloneHiddenInstance, cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance, isSuspenseInstancePending = $$$config.isSuspenseInstancePending, isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback, getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails, registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry, canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker, isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching, getNextHydratableSibling = $$$config.getNextHydratableSibling, getFirstHydratableChild = $$$config.getFirstHydratableChild, getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer, getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance, canHydrateInstance = $$$config.canHydrateInstance, canHydrateTextInstance = $$$config.canHydrateTextInstance, canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance, hydrateInstance = $$$config.hydrateInstance, hydrateTextInstance = $$$config.hydrateTextInstance, hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance, getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance, commitHydratedContainer = $$$config.commitHydratedContainer, commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance, clearSuspenseBoundary = $$$config.clearSuspenseBoundary, clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer, shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances, diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings, diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings, describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings, validateHydratableInstance = $$$config.validateHydratableInstance, validateHydratableTextInstance = $$$config.validateHydratableTextInstance, supportsResources = $$$config.supportsResources, isHostHoistableType = $$$config.isHostHoistableType, getHoistableRoot = $$$config.getHoistableRoot, getResource = $$$config.getResource, acquireResource = $$$config.acquireResource, releaseResource = $$$config.releaseResource, hydrateHoistable = $$$config.hydrateHoistable, mountHoistable = $$$config.mountHoistable, unmountHoistable = $$$config.unmountHoistable, createHoistableInstance = $$$config.createHoistableInstance, prepareToCommitHoistables = $$$config.prepareToCommitHoistables, mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit, preloadResource = $$$config.preloadResource, suspendResource = $$$config.suspendResource, supportsSingletons = $$$config.supportsSingletons, resolveSingletonInstance = $$$config.resolveSingletonInstance, clearSingleton = $$$config.clearSingleton, acquireSingletonInstance = $$$config.acquireSingletonInstance, releaseSingletonInstance = $$$config.releaseSingletonInstance, isHostSingletonType = $$$config.isHostSingletonType, valueStack = [];\n    var fiberStack = [];\n    var index$jscomp$0 = -1, emptyContextObject = {};\n    Object.freeze(emptyContextObject);\n    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log$1 = Math.log, LN2 = Math.LN2, nextTransitionLane = 128, nextRetryLane = 4194304, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, IdlePriority = Scheduler.unstable_IdlePriority, log = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, objectIs = \"function\" === typeof Object.is ? Object.is : is, CapturedStacks = new WeakMap(), forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = \"\", contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), needsEscaping = /[\"'&<>\\n\\t]|^\\s|\\s$/, hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = !1, HydrationMismatchException = Error(\"Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), NoMode = 0, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, now = Scheduler.unstable_now, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = !1, nestedUpdateScheduled = !1, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = !1, didScheduleMicrotask_act = !1, mightHavePendingSyncWork = !1, isFlushingWork = !1, currentEventTransitionLane = 0, fakeActCallbackNode$1 = {}, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1;\n    var didWarnUpdateInsideUpdate = !1;\n    var currentlyProcessingQueue = null;\n    var didReadFromEntangledAsyncAction = !1, hasOwnProperty = Object.prototype.hasOwnProperty, ReactStrictModeWarnings = {\n        recordUnsafeLifecycleWarnings: function() {},\n        flushPendingUnsafeLifecycleWarnings: function() {},\n        recordLegacyContextWarning: function() {},\n        flushLegacyContextWarning: function() {},\n        discardPendingWarnings: function() {}\n    }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = new Set();\n    ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n        didWarnAboutUnsafeLifecycles.has(fiber.type) || (\"function\" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), \"function\" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), \"function\" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & 8 && \"function\" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));\n    };\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n        var componentWillMountUniqueNames = new Set();\n        0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {\n            componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillMountWarnings = []);\n        var UNSAFE_componentWillMountUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillMountWarnings = []);\n        var componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillReceivePropsWarnings = []);\n        var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);\n        var componentWillUpdateUniqueNames = new Set();\n        0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n            componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingComponentWillUpdateWarnings = []);\n        var UNSAFE_componentWillUpdateUniqueNames = new Set();\n        0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n            UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n        }), pendingUNSAFE_ComponentWillUpdateWarnings = []);\n        if (0 < UNSAFE_componentWillMountUniqueNames.size) {\n            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n            console.error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n        }\n        0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(\"componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n        0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", sortedNames));\n    };\n    var pendingLegacyContextWarning = new Map(), didWarnAboutLegacyContext = new Set();\n    ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n        var strictRoot = null;\n        for(var node = fiber; null !== node;)node.mode & 8 && (strictRoot = node), node = node.return;\n        null === strictRoot ? console.error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && \"function\" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));\n    };\n    ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n        pendingLegacyContextWarning.forEach(function(fiberArray) {\n            if (0 !== fiberArray.length) {\n                var firstFiber = fiberArray[0], uniqueNames = new Set();\n                fiberArray.forEach(function(fiber) {\n                    uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                    didWarnAboutLegacyContext.add(fiber.type);\n                });\n                var sortedNames = setToSortedString(uniqueNames);\n                runWithFiberInDEV(firstFiber, function() {\n                    console.error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context\", sortedNames);\n                });\n            }\n        });\n    };\n    ReactStrictModeWarnings.discardPendingWarnings = function() {\n        pendingComponentWillMountWarnings = [];\n        pendingUNSAFE_ComponentWillMountWarnings = [];\n        pendingComponentWillReceivePropsWarnings = [];\n        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n        pendingComponentWillUpdateWarnings = [];\n        pendingUNSAFE_ComponentWillUpdateWarnings = [];\n        pendingLegacyContextWarning = new Map();\n    };\n    var SuspenseException = Error(\"Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\\n\\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`\"), SuspenseyCommitException = Error(\"Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React.\"), noopSuspenseyCommitThenable = {\n        then: function() {\n            console.error('Internal React error: A listener was unexpectedly attached to a \"noop\" thenable. This is a bug in React. Please file an issue.');\n        }\n    }, suspendedThenable = null, needsToResetSuspendedThenableDEV = !1, callComponent = {\n        \"react-stack-bottom-frame\": function(Component, props, secondArg) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return Component(props, secondArg);\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callComponentInDEV = callComponent[\"react-stack-bottom-frame\"].bind(callComponent), callRender = {\n        \"react-stack-bottom-frame\": function(instance) {\n            var wasRendering = isRendering;\n            isRendering = !0;\n            try {\n                return instance.render();\n            } finally{\n                isRendering = wasRendering;\n            }\n        }\n    }, callRenderInDEV = callRender[\"react-stack-bottom-frame\"].bind(callRender), callComponentDidMount = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance) {\n            try {\n                instance.componentDidMount();\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidMountInDEV = callComponentDidMount[\"react-stack-bottom-frame\"].bind(callComponentDidMount), callComponentDidUpdate = {\n        \"react-stack-bottom-frame\": function(finishedWork, instance, prevProps, prevState, snapshot) {\n            try {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n    }, callComponentDidUpdateInDEV = callComponentDidUpdate[\"react-stack-bottom-frame\"].bind(callComponentDidUpdate), callComponentDidCatch = {\n        \"react-stack-bottom-frame\": function(instance, errorInfo) {\n            var stack = errorInfo.stack;\n            instance.componentDidCatch(errorInfo.value, {\n                componentStack: null !== stack ? stack : \"\"\n            });\n        }\n    }, callComponentDidCatchInDEV = callComponentDidCatch[\"react-stack-bottom-frame\"].bind(callComponentDidCatch), callComponentWillUnmount = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, instance) {\n            try {\n                instance.componentWillUnmount();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callComponentWillUnmountInDEV = callComponentWillUnmount[\"react-stack-bottom-frame\"].bind(callComponentWillUnmount), callCreate = {\n        \"react-stack-bottom-frame\": function(effect) {\n            var create = effect.create;\n            effect = effect.inst;\n            create = create();\n            return effect.destroy = create;\n        }\n    }, callCreateInDEV = callCreate[\"react-stack-bottom-frame\"].bind(callCreate), callDestroy = {\n        \"react-stack-bottom-frame\": function(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n    }, callDestroyInDEV = callDestroy[\"react-stack-bottom-frame\"].bind(callDestroy), callLazyInit = {\n        \"react-stack-bottom-frame\": function(lazy) {\n            var init = lazy._init;\n            return init(lazy._payload);\n        }\n    }, callLazyInitInDEV = callLazyInit[\"react-stack-bottom-frame\"].bind(callLazyInit), thenableState$1 = null, thenableIndexCounter$1 = 0, currentDebugInfo = null, didWarnAboutMaps;\n    var didWarnAboutGenerators = didWarnAboutMaps = !1;\n    var ownerHasKeyUseWarning = {};\n    var ownerHasFunctionTypeWarning = {};\n    var ownerHasSymbolTypeWarning = {};\n    warnForMissingKey = function(returnFiber, workInProgress, child) {\n        if (null !== child && \"object\" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {\n            if (\"object\" !== typeof child._store) throw Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            child._store.validated = 1;\n            var componentName = getComponentNameFromFiber(returnFiber), componentKey = componentName || \"null\";\n            if (!ownerHasKeyUseWarning[componentKey]) {\n                ownerHasKeyUseWarning[componentKey] = !0;\n                child = child._owner;\n                returnFiber = returnFiber._debugOwner;\n                var currentComponentErrorInfo = \"\";\n                returnFiber && \"number\" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = \"\\n\\nCheck the render method of `\" + componentKey + \"`.\");\n                currentComponentErrorInfo || componentName && (currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\");\n                var childOwnerAppendix = \"\";\n                null != child && returnFiber !== child && (componentName = null, \"number\" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : \"string\" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = \" It was passed a child from \" + componentName + \".\"));\n                runWithFiberInDEV(workInProgress, function() {\n                    console.error('Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                });\n            }\n        }\n    };\n    var reconcileChildFibers = createChildReconciler(!0), mountChildFibers = createChildReconciler(!1), currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, didWarnUncachedGetSnapshot;\n    var didWarnAboutMismatchedHooksForComponent = new Set();\n    var didWarnAboutUseWrappedInTryCatch = new Set();\n    var didWarnAboutAsyncClientComponent = new Set();\n    var didWarnAboutUseFormState = new Set();\n    var renderLanes = 0, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, shouldDoubleInvokeUserFnsInHooksDEV = !1, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;\n    var createFunctionComponentUpdateQueue = function() {\n        return {\n            lastEffect: null,\n            events: null,\n            stores: null,\n            memoCache: null\n        };\n    };\n    var ContextOnlyDispatcher = {\n        readContext: readContext,\n        use: use,\n        useCallback: throwInvalidHookError,\n        useContext: throwInvalidHookError,\n        useEffect: throwInvalidHookError,\n        useImperativeHandle: throwInvalidHookError,\n        useLayoutEffect: throwInvalidHookError,\n        useInsertionEffect: throwInvalidHookError,\n        useMemo: throwInvalidHookError,\n        useReducer: throwInvalidHookError,\n        useRef: throwInvalidHookError,\n        useState: throwInvalidHookError,\n        useDebugValue: throwInvalidHookError,\n        useDeferredValue: throwInvalidHookError,\n        useTransition: throwInvalidHookError,\n        useSyncExternalStore: throwInvalidHookError,\n        useId: throwInvalidHookError\n    };\n    ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n    ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n    ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n    ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n    ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n    ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n    var HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n    HooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            mountHookTypesDev();\n            checkDepsAreArrayDev(deps);\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        mountHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return mountRefresh();\n        }\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    HooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    HooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    HooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            return readContext(context);\n        },\n        use: use,\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        }\n    };\n    HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n    HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    HooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        updateHookTypesDev();\n        warnOnUseFormStateInDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    HooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountEffect(create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            mountEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountLayoutEffect(create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function(initialValue) {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountRef(initialValue);\n        },\n        useState: function(initialState) {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n            try {\n                return mountState(initialState);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            mountHookTypesDev();\n            return mountId();\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            mountHookTypesDev();\n            return mountRefresh();\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function(action, initialState) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function(action, initialState) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountActionState(action, initialState);\n    };\n    InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function(passthrough) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        mountHookTypesDev();\n        return mountOptimistic(passthrough);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return updateOptimistic(passthrough, reducer);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV = {\n        readContext: function(context) {\n            warnInvalidContextAccess();\n            return readContext(context);\n        },\n        use: function(usable) {\n            warnInvalidHookAccess();\n            return use(usable);\n        },\n        useCallback: function(callback, deps) {\n            currentHookNameInDev = \"useCallback\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateCallback(callback, deps);\n        },\n        useContext: function(context) {\n            currentHookNameInDev = \"useContext\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return readContext(context);\n        },\n        useEffect: function(create, deps) {\n            currentHookNameInDev = \"useEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            updateEffectImpl(2048, Passive, create, deps);\n        },\n        useImperativeHandle: function(ref, create, deps) {\n            currentHookNameInDev = \"useImperativeHandle\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateImperativeHandle(ref, create, deps);\n        },\n        useInsertionEffect: function(create, deps) {\n            currentHookNameInDev = \"useInsertionEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Insertion, create, deps);\n        },\n        useLayoutEffect: function(create, deps) {\n            currentHookNameInDev = \"useLayoutEffect\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateEffectImpl(4, Layout, create, deps);\n        },\n        useMemo: function(create, deps) {\n            currentHookNameInDev = \"useMemo\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return updateMemo(create, deps);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useReducer: function(reducer, initialArg, init) {\n            currentHookNameInDev = \"useReducer\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(reducer, initialArg, init);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useRef: function() {\n            currentHookNameInDev = \"useRef\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useState: function() {\n            currentHookNameInDev = \"useState\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n            try {\n                return rerenderReducer(basicStateReducer);\n            } finally{\n                ReactSharedInternals.H = prevDispatcher;\n            }\n        },\n        useDebugValue: function() {\n            currentHookNameInDev = \"useDebugValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n        },\n        useDeferredValue: function(value, initialValue) {\n            currentHookNameInDev = \"useDeferredValue\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderDeferredValue(value, initialValue);\n        },\n        useTransition: function() {\n            currentHookNameInDev = \"useTransition\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return rerenderTransition();\n        },\n        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n            currentHookNameInDev = \"useSyncExternalStore\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        },\n        useId: function() {\n            currentHookNameInDev = \"useId\";\n            warnInvalidHookAccess();\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useCacheRefresh: function() {\n            currentHookNameInDev = \"useCacheRefresh\";\n            updateHookTypesDev();\n            return updateWorkInProgressHook().memoizedState;\n        },\n        useMemoCache: function(size) {\n            warnInvalidHookAccess();\n            return useMemoCache(size);\n        }\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function(action) {\n        currentHookNameInDev = \"useFormState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function(action) {\n        currentHookNameInDev = \"useActionState\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderActionState(action);\n    };\n    InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function(passthrough, reducer) {\n        currentHookNameInDev = \"useOptimistic\";\n        warnInvalidHookAccess();\n        updateHookTypesDev();\n        return rerenderOptimistic(passthrough, reducer);\n    };\n    var fakeInternalInstance = {};\n    var didWarnAboutStateAssignmentForComponent = new Set();\n    var didWarnAboutUninitializedState = new Set();\n    var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n    var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n    var didWarnAboutDirectlyAssigningPropsToState = new Set();\n    var didWarnAboutUndefinedDerivedState = new Set();\n    var didWarnAboutContextTypes$1 = new Set();\n    var didWarnAboutChildContextTypes = new Set();\n    var didWarnAboutInvalidateContextType = new Set();\n    var didWarnOnInvalidCallback = new Set();\n    Object.freeze(fakeInternalInstance);\n    var classComponentUpdater = {\n        isMounted: function(component) {\n            var owner = current;\n            if (null !== owner && isRendering && 1 === owner.tag) {\n                var instance = owner.stateNode;\n                instance._warnedAboutRefsInRender || console.error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(owner) || \"A component\");\n                instance._warnedAboutRefsInRender = !0;\n            }\n            return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;\n        },\n        enqueueSetState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueReplaceState: function(inst, payload, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            payload = enqueueUpdate(inst, update, lane);\n            null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));\n            markStateUpdateScheduled(inst, lane);\n        },\n        enqueueForceUpdate: function(inst, callback) {\n            inst = inst._reactInternals;\n            var lane = requestUpdateLane(inst), update = createUpdate(lane);\n            update.tag = ForceUpdate;\n            void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);\n            callback = enqueueUpdate(inst, update, lane);\n            null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));\n            null !== injectedProfilingHooks && \"function\" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);\n        }\n    }, reportGlobalError = \"function\" === typeof reportError ? reportError : function(error) {\n        if (false) { var event; } else if (\"object\" === typeof process && \"function\" === typeof process.emit) {\n            process.emit(\"uncaughtException\", error);\n            return;\n        }\n        console.error(error);\n    }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(\"This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue.\"), didReceiveUpdate = !1;\n    var didWarnAboutBadClass = {};\n    var didWarnAboutContextTypeOnFunctionComponent = {};\n    var didWarnAboutContextTypes = {};\n    var didWarnAboutGetDerivedStateOnFunctionComponent = {};\n    var didWarnAboutReassigningProps = !1;\n    var didWarnAboutRevealOrder = {};\n    var didWarnAboutTailOptions = {};\n    var SUSPENDED_MARKER = {\n        dehydrated: null,\n        treeContext: null,\n        retryLane: 0\n    }, hasWarnedAboutUsingNoValuePropOnContextProvider = !1, valueCursor = createCursor(null);\n    var rendererCursorDEV = createCursor(null);\n    var renderer2CursorDEV = createCursor(null);\n    var rendererSigil = {};\n    var currentlyRenderingFiber = null, lastContextDependency = null, isDisallowedContextReadInDEV = !1, AbortControllerLocal = \"undefined\" !== typeof AbortController ? AbortController : function() {\n        var listeners = [], signal = this.signal = {\n            aborted: !1,\n            addEventListener: function(type, listener) {\n                listeners.push(listener);\n            }\n        };\n        this.abort = function() {\n            signal.aborted = !0;\n            listeners.forEach(function(listener) {\n                return listener();\n            });\n        };\n    }, scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        Consumer: null,\n        Provider: null,\n        _currentValue: null,\n        _currentValue2: null,\n        _threadCount: 0,\n        _currentRenderer: null,\n        _currentRenderer2: null\n    }, prevOnStartTransitionFinish = ReactSharedInternals.S;\n    ReactSharedInternals.S = function(transition, returnValue) {\n        \"object\" === typeof returnValue && null !== returnValue && \"function\" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);\n        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);\n    };\n    var resumedCache = createCursor(null), didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n    didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, needsFormReset = !1, PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, shouldFireAfterActiveInstanceBlur = !1, hostParent = null, hostParentIsContainer = !1, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {\n        getCacheForType: function(resourceType) {\n            var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);\n            void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));\n            return cacheForType;\n        },\n        getOwner: function() {\n            return current;\n        }\n    }, COMPONENT_TYPE = 0, HAS_PSEUDO_CLASS_TYPE = 1, ROLE_TYPE = 2, TEST_NAME_TYPE = 3, TEXT_TYPE = 4;\n    if (\"function\" === typeof Symbol && Symbol.for) {\n        var symbolFor = Symbol.for;\n        COMPONENT_TYPE = symbolFor(\"selector.component\");\n        HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n        ROLE_TYPE = symbolFor(\"selector.role\");\n        TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n        TEXT_TYPE = symbolFor(\"selector.text\");\n    }\n    var commitHooks = [], PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = !1, workInProgressRootIsPrerendering = !1, workInProgressRootDidAttachPingListener = !1, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = !1, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = 0, pendingPassiveEffectsRemainingLanes = 0, pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = !1, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = !1;\n    var didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n    var fakeActCallbackNode = {}, resolveFamily = null, failedBoundaries = null;\n    var hasBadMapPolyfill = !1;\n    try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        new Map([\n            [\n                nonExtensibleObject,\n                null\n            ]\n        ]);\n        new Set([\n            nonExtensibleObject\n        ]);\n    } catch (e) {\n        hasBadMapPolyfill = !0;\n    }\n    var didWarnAboutNestedUpdates = !1;\n    var didWarnAboutFindNodeInStrictMode = {};\n    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;\n    overrideHookState = function(fiber, id, path, value) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateDeletePath = function(fiber, id, path) {\n        id = findHook(fiber, id);\n        null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));\n    };\n    overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n        id = findHook(fiber, id);\n        null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));\n    };\n    overrideProps = function(fiber, path, value) {\n        fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsDeletePath = function(fiber, path) {\n        fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        path = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== path && scheduleUpdateOnFiber(path, fiber, 2);\n    };\n    overridePropsRenamePath = function(fiber, oldPath, newPath) {\n        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n        fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);\n        oldPath = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);\n    };\n    scheduleUpdate = function(fiber) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n    };\n    setErrorHandler = function(newShouldErrorImpl) {\n        shouldErrorImpl = newShouldErrorImpl;\n    };\n    setSuspenseHandler = function(newShouldSuspendImpl) {\n        shouldSuspendImpl = newShouldSuspendImpl;\n    };\n    exports.attemptContinuousHydration = function(fiber) {\n        if (13 === fiber.tag) {\n            var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n            null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n            markRetryLaneIfNotHydrated(fiber, 67108864);\n        }\n    };\n    exports.attemptHydrationAtCurrentPriority = function(fiber) {\n        if (13 === fiber.tag) {\n            var lane = requestUpdateLane(fiber), root = enqueueConcurrentRenderForLane(fiber, lane);\n            null !== root && scheduleUpdateOnFiber(root, fiber, lane);\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n    };\n    exports.attemptSynchronousHydration = function(fiber) {\n        switch(fiber.tag){\n            case 3:\n                fiber = fiber.stateNode;\n                if (fiber.current.memoizedState.isDehydrated) {\n                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                    if (0 !== lanes) {\n                        fiber.pendingLanes |= 2;\n                        for(fiber.entangledLanes |= 2; lanes;){\n                            var lane = 1 << 31 - clz32(lanes);\n                            fiber.entanglements[1] |= lane;\n                            lanes &= ~lane;\n                        }\n                        ensureRootIsScheduled(fiber);\n                        (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));\n                    }\n                }\n                break;\n            case 13:\n                lanes = enqueueConcurrentRenderForLane(fiber, 2), null !== lanes && scheduleUpdateOnFiber(lanes, fiber, 2), flushSyncWork(), markRetryLaneIfNotHydrated(fiber, 2);\n        }\n    };\n    exports.batchedUpdates = function(fn, a) {\n        return fn(a);\n    };\n    exports.createComponentSelector = function(component) {\n        return {\n            $$typeof: COMPONENT_TYPE,\n            value: component\n        };\n    };\n    exports.createContainer = function(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n        return createFiberRoot(containerInfo, tag, !1, null, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n    };\n    exports.createHasPseudoClassSelector = function(selectors) {\n        return {\n            $$typeof: HAS_PSEUDO_CLASS_TYPE,\n            value: selectors\n        };\n    };\n    exports.createHydrationContainer = function(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n        initialChildren = createFiberRoot(containerInfo, tag, !0, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);\n        initialChildren.context = getContextForSubtree(null);\n        containerInfo = initialChildren.current;\n        tag = requestUpdateLane(containerInfo);\n        hydrationCallbacks = createUpdate(tag);\n        hydrationCallbacks.callback = void 0 !== callback && null !== callback ? callback : null;\n        enqueueUpdate(containerInfo, hydrationCallbacks, tag);\n        initialChildren.current.lanes = tag;\n        markRootUpdated$1(initialChildren, tag);\n        ensureRootIsScheduled(initialChildren);\n        return initialChildren;\n    };\n    exports.createPortal = function(children, containerInfo, implementation) {\n        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n        try {\n            testStringCoercion(key);\n            var JSCompiler_inline_result = !1;\n        } catch (e$6) {\n            JSCompiler_inline_result = !0;\n        }\n        JSCompiler_inline_result && (console.error(\"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\", \"function\" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || \"Object\"), testStringCoercion(key));\n        return {\n            $$typeof: REACT_PORTAL_TYPE,\n            key: null == key ? null : \"\" + key,\n            children: children,\n            containerInfo: containerInfo,\n            implementation: implementation\n        };\n    };\n    exports.createRoleSelector = function(role) {\n        return {\n            $$typeof: ROLE_TYPE,\n            value: role\n        };\n    };\n    exports.createTestNameSelector = function(id) {\n        return {\n            $$typeof: TEST_NAME_TYPE,\n            value: id\n        };\n    };\n    exports.createTextSelector = function(text) {\n        return {\n            $$typeof: TEXT_TYPE,\n            value: text\n        };\n    };\n    exports.defaultOnCaughtError = function(error, errorInfo) {\n        var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : \"The above error occurred in one of your React components.\", recreateMessage = \"React will try to recreate this component tree from scratch using the error boundary you provided, \" + ((errorBoundaryName || \"Anonymous\") + \".\"), prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            \"object\" === typeof error && null !== error && \"string\" === typeof error.environmentName ? bindToConsole(\"error\", [\n                \"%o\\n\\n%s\\n\\n%s\\n\",\n                error,\n                componentNameMessage,\n                recreateMessage\n            ], error.environmentName)() : console.error(\"%o\\n\\n%s\\n\\n%s\\n\", error, componentNameMessage, recreateMessage);\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.defaultOnRecoverableError = function(error) {\n        reportGlobalError(error);\n    };\n    exports.defaultOnUncaughtError = function(error, errorInfo) {\n        reportGlobalError(error);\n        error = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : \"An error occurred in one of your React components.\";\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack, componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : \"\";\n        ReactSharedInternals.getCurrentStack = function() {\n            return componentStack;\n        };\n        try {\n            console.warn(\"%s\\n\\n%s\\n\", error, \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.\");\n        } finally{\n            ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n        }\n    };\n    exports.deferredUpdates = function(fn) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(32), ReactSharedInternals.T = null, fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition;\n        }\n    };\n    exports.discreteUpdates = function(fn, a, b, c, d) {\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            return setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn(a, b, c, d);\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS);\n        }\n    };\n    exports.findAllNodes = findAllNodes;\n    exports.findBoundingRects = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        selectors = findAllNodes(hostRoot, selectors);\n        hostRoot = [];\n        for(var i = 0; i < selectors.length; i++)hostRoot.push(getBoundingRect(selectors[i]));\n        for(selectors = hostRoot.length - 1; 0 < selectors; selectors--){\n            i = hostRoot[selectors];\n            for(var targetLeft = i.x, targetRight = targetLeft + i.width, targetTop = i.y, targetBottom = targetTop + i.height, j = selectors - 1; 0 <= j; j--)if (selectors !== j) {\n                var otherRect = hostRoot[j], otherLeft = otherRect.x, otherRight = otherLeft + otherRect.width, otherTop = otherRect.y, otherBottom = otherTop + otherRect.height;\n                if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetLeft !== otherLeft || i.width !== otherRect.width || otherBottom < targetTop || otherTop > targetBottom)) {\n                    otherTop > targetTop && (otherRect.height += otherTop - targetTop, otherRect.y = targetTop);\n                    otherBottom < targetBottom && (otherRect.height = targetBottom - otherTop);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                } else if (!(targetTop !== otherTop || i.height !== otherRect.height || otherRight < targetLeft || otherLeft > targetRight)) {\n                    otherLeft > targetLeft && (otherRect.width += otherLeft - targetLeft, otherRect.x = targetLeft);\n                    otherRight < targetRight && (otherRect.width = targetRight - otherLeft);\n                    hostRoot.splice(selectors, 1);\n                    break;\n                }\n            }\n        }\n        return hostRoot;\n    };\n    exports.findHostInstance = function(component) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        return null === component ? null : getPublicInstance(component.stateNode);\n    };\n    exports.findHostInstanceWithNoPortals = function(fiber) {\n        fiber = findCurrentFiberUsingSlowPath(fiber);\n        fiber = null !== fiber ? findCurrentHostFiberWithNoPortalsImpl(fiber) : null;\n        return null === fiber ? null : getPublicInstance(fiber.stateNode);\n    };\n    exports.findHostInstanceWithWarning = function(component, methodName) {\n        var fiber = component._reactInternals;\n        if (void 0 === fiber) {\n            if (\"function\" === typeof component.render) throw Error(\"Unable to find node on an unmounted component.\");\n            component = Object.keys(component).join(\",\");\n            throw Error(\"Argument appears to not be a ReactComponent. Keys: \" + component);\n        }\n        component = findCurrentHostFiber(fiber);\n        if (null === component) return null;\n        if (component.mode & 8) {\n            var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n            didWarnAboutFindNodeInStrictMode[componentName] || (didWarnAboutFindNodeInStrictMode[componentName] = !0, runWithFiberInDEV(component, function() {\n                fiber.mode & 8 ? console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName) : console.error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://react.dev/link/strict-mode-find-node\", methodName, methodName, componentName);\n            }));\n        }\n        return getPublicInstance(component.stateNode);\n    };\n    exports.flushPassiveEffects = flushPassiveEffects;\n    exports.flushSyncFromReconciler = function(fn) {\n        var prevExecutionContext = executionContext;\n        executionContext |= 1;\n        var prevTransition = ReactSharedInternals.T, previousPriority = getCurrentUpdatePriority();\n        try {\n            if (setCurrentUpdatePriority(2), ReactSharedInternals.T = null, fn) return fn();\n        } finally{\n            setCurrentUpdatePriority(previousPriority), ReactSharedInternals.T = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncWorkAcrossRoots_impl(0, !1);\n        }\n    };\n    exports.flushSyncWork = flushSyncWork;\n    exports.focusWithin = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        hostRoot = findFiberRootForHostRoot(hostRoot);\n        selectors = findPaths(hostRoot, selectors);\n        selectors = Array.from(selectors);\n        for(hostRoot = 0; hostRoot < selectors.length;){\n            var fiber = selectors[hostRoot++], tag = fiber.tag;\n            if (!isHiddenSubtree(fiber)) {\n                if ((5 === tag || 26 === tag || 27 === tag) && setFocusIfFocusable(fiber.stateNode)) return !0;\n                for(fiber = fiber.child; null !== fiber;)selectors.push(fiber), fiber = fiber.sibling;\n            }\n        }\n        return !1;\n    };\n    exports.getFindAllNodesFailureDescription = function(hostRoot, selectors) {\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var maxSelectorIndex = 0, matchedNames = [];\n        hostRoot = [\n            findFiberRootForHostRoot(hostRoot),\n            0\n        ];\n        for(var index = 0; index < hostRoot.length;){\n            var fiber = hostRoot[index++], tag = fiber.tag, selectorIndex = hostRoot[index++], selector = selectors[selectorIndex];\n            if (5 !== tag && 26 !== tag && 27 !== tag || !isHiddenSubtree(fiber)) {\n                if (matchSelector(fiber, selector) && (matchedNames.push(selectorToString(selector)), selectorIndex++, selectorIndex > maxSelectorIndex && (maxSelectorIndex = selectorIndex)), selectorIndex < selectors.length) for(fiber = fiber.child; null !== fiber;)hostRoot.push(fiber, selectorIndex), fiber = fiber.sibling;\n            }\n        }\n        if (maxSelectorIndex < selectors.length) {\n            for(hostRoot = []; maxSelectorIndex < selectors.length; maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));\n            return \"findAllNodes was able to match part of the selector:\\n  \" + (matchedNames.join(\" > \") + \"\\n\\nNo matching component was found for:\\n  \") + hostRoot.join(\" > \");\n        }\n        return null;\n    };\n    exports.getPublicRootInstance = function(container) {\n        container = container.current;\n        if (!container.child) return null;\n        switch(container.child.tag){\n            case 27:\n            case 5:\n                return getPublicInstance(container.child.stateNode);\n            default:\n                return container.child.stateNode;\n        }\n    };\n    exports.injectIntoDevTools = function() {\n        var internals = {\n            bundleType: 1,\n            version: rendererVersion,\n            rendererPackageName: rendererPackageName,\n            currentDispatcherRef: ReactSharedInternals,\n            findFiberByHostInstance: getInstanceFromNode,\n            reconcilerVersion: \"19.0.0\"\n        };\n        null !== extraDevToolsConfig && (internals.rendererConfig = extraDevToolsConfig);\n        internals.overrideHookState = overrideHookState;\n        internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n        internals.overrideHookStateRenamePath = overrideHookStateRenamePath;\n        internals.overrideProps = overrideProps;\n        internals.overridePropsDeletePath = overridePropsDeletePath;\n        internals.overridePropsRenamePath = overridePropsRenamePath;\n        internals.scheduleUpdate = scheduleUpdate;\n        internals.setErrorHandler = setErrorHandler;\n        internals.setSuspenseHandler = setSuspenseHandler;\n        internals.scheduleRefresh = scheduleRefresh;\n        internals.scheduleRoot = scheduleRoot;\n        internals.setRefreshHandler = setRefreshHandler;\n        internals.getCurrentFiber = getCurrentFiberForDevTools;\n        internals.getLaneLabelMap = getLaneLabelMap;\n        internals.injectProfilingHooks = injectProfilingHooks;\n        return injectInternals(internals);\n    };\n    exports.isAlreadyRendering = function() {\n        return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n    };\n    exports.observeVisibleRects = function(hostRoot, selectors, callback, options) {\n        function commitHook() {\n            var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n            instanceRoots.forEach(function(target) {\n                0 > nextInstanceRoots.indexOf(target) && unobserve(target);\n            });\n            nextInstanceRoots.forEach(function(target) {\n                0 > instanceRoots.indexOf(target) && observe(target);\n            });\n        }\n        if (!supportsTestSelectors) throw Error(\"Test selector API is not supported by this renderer.\");\n        var instanceRoots = findAllNodes(hostRoot, selectors);\n        callback = setupIntersectionObserver(instanceRoots, callback, options);\n        var disconnect = callback.disconnect, observe = callback.observe, unobserve = callback.unobserve;\n        commitHooks.push(commitHook);\n        return {\n            disconnect: function() {\n                var index = commitHooks.indexOf(commitHook);\n                0 <= index && commitHooks.splice(index, 1);\n                disconnect();\n            }\n        };\n    };\n    exports.shouldError = function(fiber) {\n        return shouldErrorImpl(fiber);\n    };\n    exports.shouldSuspend = function(fiber) {\n        return shouldSuspendImpl(fiber);\n    };\n    exports.startHostTransition = function(formFiber, pendingState, action, formData) {\n        if (5 !== formFiber.tag) throw Error(\"Expected the form instance to be a HostComponent. This is a bug in React.\");\n        var queue = ensureFormComponentIsStateful(formFiber).queue;\n        startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop : function() {\n            null === ReactSharedInternals.T && console.error(\"requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.\");\n            var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n            dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));\n            return action(formData);\n        });\n    };\n    exports.updateContainer = function(element, container, parentComponent, callback) {\n        var current = container.current, lane = requestUpdateLane(current);\n        updateContainerImpl(current, lane, element, container, parentComponent, callback);\n        return lane;\n    };\n    exports.updateContainerSync = updateContainerSync;\n    return exports;\n}, module.exports[\"default\"] = module.exports, Object.defineProperty(module.exports, \"__esModule\", {\n    value: !0\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVZO0FBQ2IsS0EyT29CLElBMU9qQixRQUFRQyxPQUFPLEdBQUcsU0FBVUMsU0FBUztJQUNwQyxTQUFTQyxTQUFTQyxLQUFLLEVBQUVDLEVBQUU7UUFDekIsSUFBS0QsUUFBUUEsTUFBTUUsYUFBYSxFQUFFLFNBQVNGLFNBQVMsSUFBSUMsSUFDdEQsUUFBU0QsTUFBTUcsSUFBSSxFQUFHRjtRQUN4QixPQUFPRDtJQUNUO0lBQ0EsU0FBU0ksZ0JBQWdCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxLQUFLO1FBQzlDLElBQUlELFNBQVNELEtBQUtHLE1BQU0sRUFBRSxPQUFPRDtRQUNqQyxJQUFJRSxNQUFNSixJQUFJLENBQUNDLE1BQU0sRUFDbkJJLFVBQVVDLFlBQVlQLE9BQU9BLElBQUlRLEtBQUssS0FBS0MsT0FBTyxDQUFDLEdBQUdUO1FBQ3hETSxPQUFPLENBQUNELElBQUksR0FBR04sZ0JBQWdCQyxHQUFHLENBQUNLLElBQUksRUFBRUosTUFBTUMsUUFBUSxHQUFHQztRQUMxRCxPQUFPRztJQUNUO0lBQ0EsU0FBU0ksZUFBZVYsR0FBRyxFQUFFVyxPQUFPLEVBQUVDLE9BQU87UUFDM0MsSUFBSUQsUUFBUVAsTUFBTSxLQUFLUSxRQUFRUixNQUFNLEVBQ25DUyxRQUFRQyxJQUFJLENBQUM7YUFDVjtZQUNILElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxRQUFRUixNQUFNLEdBQUcsR0FBR1csSUFDdEMsSUFBSUosT0FBTyxDQUFDSSxFQUFFLEtBQUtILE9BQU8sQ0FBQ0csRUFBRSxFQUFFO2dCQUM3QkYsUUFBUUMsSUFBSSxDQUNWO2dCQUVGO1lBQ0Y7WUFDRixPQUFPRSxtQkFBbUJoQixLQUFLVyxTQUFTQyxTQUFTO1FBQ25EO0lBQ0Y7SUFDQSxT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QXFCdXRCLENBQUMsSUFDN0J0MEIsUUFBUWdDLEtBQUssQ0FDWDtZQUVKLElBQUl3d0Qsa0JBQ0ZsNkIsOEJBQThCQyxXQUFXdDVCLElBQUksQ0FBQ3FiLEtBQUs7WUFDckQ4ZCx5QkFDRUcsV0FDQWk2QixpQkFDQSxDQUFDLEdBQ0RuNkIsa0JBQWtCRTtZQUVwQixPQUFPakksT0FBT2lpQztRQUNoQjtJQUVSO0lBQ0E1ekQsUUFBUTh6RCxlQUFlLEdBQUcsU0FDeEJ6eEQsT0FBTyxFQUNQMnBDLFNBQVMsRUFDVHNhLGVBQWUsRUFDZjk3QyxRQUFRO1FBRVIsSUFBSXZILFVBQVUrb0MsVUFBVS9vQyxPQUFPLEVBQzdCK0osT0FBTzBzQixrQkFBa0J6MkI7UUFDM0JzakQsb0JBQ0V0akQsU0FDQStKLE1BQ0EzSyxTQUNBMnBDLFdBQ0FzYSxpQkFDQTk3QztRQUVGLE9BQU93QztJQUNUO0lBQ0FoTixRQUFRd0MsbUJBQW1CLEdBQUdBO0lBQzlCLE9BQU94QztBQUNULEdBQ0NELHlCQUFzQixHQUFHQSxPQUFPQyxPQUFPLEVBQ3hDZ0gsT0FBT3lCLGNBQWMsQ0FBQzFJLE9BQU9DLE9BQU8sRUFBRSxjQUFjO0lBQUVXLE9BQU8sQ0FBQztBQUFFLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYWthbXVyYS9naXQvM2Qvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKChtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkJCRjb25maWcpIHtcbiAgICBmdW5jdGlvbiBmaW5kSG9vayhmaWJlciwgaWQpIHtcbiAgICAgIGZvciAoZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlOyBudWxsICE9PSBmaWJlciAmJiAwIDwgaWQ7IClcbiAgICAgICAgKGZpYmVyID0gZmliZXIubmV4dCksIGlkLS07XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aClcbiAgICAgICAgY29uc29sZS53YXJuKFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4KSB7XG4gICAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF0sXG4gICAgICAgIHVwZGF0ZWQgPSBpc0FycmF5SW1wbChvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG4gICAgICBpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoXG4gICAgICAgID8gKCh1cGRhdGVkW25ld1BhdGhbaW5kZXhdXSA9IHVwZGF0ZWRbb2xkS2V5XSksXG4gICAgICAgICAgaXNBcnJheUltcGwodXBkYXRlZClcbiAgICAgICAgICAgID8gdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKVxuICAgICAgICAgICAgOiBkZWxldGUgdXBkYXRlZFtvbGRLZXldKVxuICAgICAgICA6ICh1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoXG4gICAgICAgICAgICBvYmpbb2xkS2V5XSxcbiAgICAgICAgICAgIG9sZFBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoLFxuICAgICAgICAgICAgaW5kZXggKyAxXG4gICAgICAgICAgKSk7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVdpdGhEZWxldGVJbXBsKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XSxcbiAgICAgICAgdXBkYXRlZCA9IGlzQXJyYXlJbXBsKG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcbiAgICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGlzQXJyYXlJbXBsKHVwZGF0ZWQpID8gdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKSA6IGRlbGV0ZSB1cGRhdGVkW2tleV0sXG4gICAgICAgICAgdXBkYXRlZFxuICAgICAgICApO1xuICAgICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGVJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEpO1xuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFN1c3BlbmRJbXBsKCkge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRFcnJvckltcGwoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXIodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlUm9vdChyb290LCBlbGVtZW50KSB7XG4gICAgICByb290LmNvbnRleHQgPT09IGVtcHR5Q29udGV4dE9iamVjdCAmJlxuICAgICAgICAodXBkYXRlQ29udGFpbmVyU3luYyhlbGVtZW50LCByb290LCBudWxsLCBudWxsKSwgZmx1c2hTeW5jV29yaygpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZWZyZXNoKHJvb3QsIHVwZGF0ZSkge1xuICAgICAgaWYgKG51bGwgIT09IHJlc29sdmVGYW1pbHkpIHtcbiAgICAgICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcztcbiAgICAgICAgdXBkYXRlID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIHJvb3QuY3VycmVudCxcbiAgICAgICAgICB1cGRhdGUsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgICAgICBmbHVzaFN5bmNXb3JrKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFJlZnJlc2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkRvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gICAgZnVuY3Rpb24gd2FybkZvck1pc3NpbmdLZXkoKSB7fVxuICAgIGZ1bmN0aW9uIHNldFRvU29ydGVkU3RyaW5nKHNldCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICAgIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIG1heWJlSXRlcmFibGUgPVxuICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICByZXR1cm4gXCJDYWNoZVwiO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgcmV0dXJuIFwiRGVoeWRyYXRlZEZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IHR5cGUucmVuZGVyKSxcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLmRpc3BsYXlOYW1lIHx8IGZpYmVyLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lIHx8XG4gICAgICAgICAgICAgIChcIlwiICE9PSBmaWJlciA/IFwiRm9yd2FyZFJlZihcIiArIGZpYmVyICsgXCIpXCIgOiBcIkZvcndhcmRSZWZcIilcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIFwiRnJhZ21lbnRcIjtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gXCJSb290XCI7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gXCJUZXh0XCI7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID8gXCJTdHJpY3RNb2RlXCIgOiBcIk1vZGVcIjtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJldHVybiBcIlNjb3BlXCI7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gXCJUcmFjaW5nTWFya2VyXCI7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0eXBlID0gZmliZXIuX2RlYnVnSW5mbztcbiAgICAgICAgICBpZiAobnVsbCAhPSB0eXBlKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHR5cGUubGVuZ3RoIC0gMTsgMCA8PSBpOyBpLS0pXG4gICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZVtpXS5uYW1lKSByZXR1cm4gdHlwZVtpXS5uYW1lO1xuICAgICAgICAgIGlmIChudWxsICE9PSBmaWJlci5yZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlci5yZXR1cm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cbiAgICBmdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRpc2FibGVkRGVwdGgrKztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICAgICAgZGlzYWJsZWREZXB0aC0tO1xuICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcbiAgICAgICAgdmFyIHByb3BzID0geyBjb25maWd1cmFibGU6ICEwLCBlbnVtZXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG4gICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkluZm8gfSksXG4gICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldldhcm4gfSksXG4gICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcbiAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwIH0pLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWQgfSksXG4gICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgICAgICBzdWZmaXggPVxuICAgICAgICAgICAgLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJcXG4gICAgYXRcIilcbiAgICAgICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcbiAgICAgICAgICAgICAgICA/IFwiQHVua25vd246MDowXCJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZSArIHN1ZmZpeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gICAgICBpZiAoIWZuIHx8IHJlZW50cnkpIHJldHVybiBcIlwiO1xuICAgICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcbiAgICAgIHJlZW50cnkgPSAhMDtcbiAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBSdW5JblJvb3RGcmFtZSA9IHtcbiAgICAgICAgICBEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBSZWZsZWN0ICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0geDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCQxKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sID0geCQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoRmFrZSA9IGZuKCkpICYmXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBGYWtlLmNhdGNoICYmXG4gICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCI7XG4gICAgICAgIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICBcIm5hbWVcIlxuICAgICAgICApO1xuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IuY29uZmlndXJhYmxlICYmXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICAgICAgXCJuYW1lXCIsXG4gICAgICAgICAgICB7IHZhbHVlOiBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiIH1cbiAgICAgICAgICApO1xuICAgICAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID1cbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCgpLFxuICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcbiAgICAgICAgaWYgKHNhbXBsZVN0YWNrICYmIGNvbnRyb2xTdGFjaykge1xuICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXS5pbmNsdWRlcyhcbiAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIrKztcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID09PSBjb250cm9sTGluZXMubGVuZ3RoXG4gICAgICAgICAgKVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgJiZcbiAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXTtcblxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSwgX1J1bkluUm9vdEZyYW1lJERldGVyLS1cbiAgICAgICAgICApXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKDEgIT09IG5hbWVQcm9wRGVzY3JpcHRvciB8fCAxICE9PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXIpIHtcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAobmFtZVByb3BEZXNjcmlwdG9yLS0sXG4gICAgICAgICAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlci0tLFxuICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IG5ldyBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIGF0IFwiXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm4uZGlzcGxheU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgKHJlZW50cnkgPSAhMSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuICAgICAgICAgIHJlZW5hYmxlTG9ncygpLFxuICAgICAgICAgIChFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IGZyYW1lKTtcbiAgICAgIH1cbiAgICAgIHNhbXBsZUxpbmVzID0gKHNhbXBsZUxpbmVzID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIilcbiAgICAgICAgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShzYW1wbGVMaW5lcylcbiAgICAgICAgOiBcIlwiO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiYgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHNhbXBsZUxpbmVzKTtcbiAgICAgIHJldHVybiBzYW1wbGVMaW5lcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJMYXp5XCIpO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKSksIGZpYmVyO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyLCAhMSkpLCBmaWJlclxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMCkpLCBmaWJlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBkZWJ1Z0luZm8gPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgICAgICAgIGlmIChkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IGRlYnVnSW5mb1tpXTtcbiAgICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfdGVtcF9jb25zdCA9IGluZm8sXG4gICAgICAgICAgICAgICAgICBlbnYgPSBlbnRyeS5lbnY7XG4gICAgICAgICAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFxuICAgICAgICAgICAgICAgICAgZW50cnkubmFtZSArIChlbnYgPyBcIiBbXCIgKyBlbnYgKyBcIl1cIiA6IFwiXCIpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpbmZvID0gSlNDb21waWxlcl90ZW1wX2NvbnN0ICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlxcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6IFwiICsgeC5tZXNzYWdlICsgXCJcXG5cIiArIHguc3RhY2s7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudCA/IFwiXCIgOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1bldpdGhGaWJlckluREVWKGZpYmVyLCBjYWxsYmFjaywgYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID1cbiAgICAgICAgbnVsbCA9PT0gZmliZXIgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50ID0gcHJldmlvdXNGaWJlcjtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcInJ1bldpdGhGaWJlckluREVWIHNob3VsZCBuZXZlciBiZSBjYWxsZWQgaW4gcHJvZHVjdGlvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICAgICAgdmFyIG5vZGUgPSBmaWJlcixcbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIGZvciAoOyBub2RlLnJldHVybjsgKSBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICBlbHNlIHtcbiAgICAgICAgZmliZXIgPSBub2RlO1xuICAgICAgICBkb1xuICAgICAgICAgIChub2RlID0gZmliZXIpLFxuICAgICAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJiAobmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybiksXG4gICAgICAgICAgICAoZmliZXIgPSBub2RlLnJldHVybik7XG4gICAgICAgIHdoaWxlIChmaWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gMyA9PT0gbm9kZS50YWcgPyBuZWFyZXN0TW91bnRlZCA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAgICAgaWYgKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpICE9PSBmaWJlcilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgICAgICBpZiAobnVsbCA9PT0gYWx0ZXJuYXRlKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBhID0gZmliZXIsIGIgPSBhbHRlcm5hdGU7IDsgKSB7XG4gICAgICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSBwYXJlbnRBKSBicmVhaztcbiAgICAgICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgICAgICBiID0gcGFyZW50QS5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgIT09IGIpIHtcbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYSkgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgZmliZXI7XG4gICAgICAgICAgICBpZiAocGFyZW50QiA9PT0gYikgcmV0dXJuIGFzc2VydElzTW91bnRlZChwYXJlbnRBKSwgYWx0ZXJuYXRlO1xuICAgICAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGRpZEZpbmRDaGlsZCA9ICExLCBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkOyBfY2hpbGQ7ICkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAgIGZvciAoX2NoaWxkID0gcGFyZW50Qi5jaGlsZDsgX2NoaWxkOyApIHtcbiAgICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoMyAhPT0gYS50YWcpXG4gICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgIHJldHVybiBhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhID8gZmliZXIgOiBhbHRlcm5hdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgICAgIHJldHVybiBudWxsICE9PSBwYXJlbnQgPyBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwocGFyZW50KSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICAgICAgZm9yIChub2RlID0gbm9kZS5jaGlsZDsgbnVsbCAhPT0gbm9kZTsgKSB7XG4gICAgICAgIHRhZyA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKTtcbiAgICAgICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnIHx8IDYgPT09IHRhZykgcmV0dXJuIG5vZGU7XG4gICAgICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDQgIT09IG5vZGUudGFnICYmXG4gICAgICAgICAgKCh0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpKSwgbnVsbCAhPT0gdGFnKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4geyBjdXJyZW50OiBkZWZhdWx0VmFsdWUgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgICAgIDAgPiBpbmRleCRqc2NvbXAkMFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXCJVbmV4cGVjdGVkIHBvcC5cIilcbiAgICAgICAgOiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXgkanNjb21wJDBdICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuXCIpLFxuICAgICAgICAgIChjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdKSxcbiAgICAgICAgICAodmFsdWVTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICAoZmliZXJTdGFja1tpbmRleCRqc2NvbXAkMF0gPSBudWxsKSxcbiAgICAgICAgICBpbmRleCRqc2NvbXAkMC0tKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICAgICAgaW5kZXgkanNjb21wJDArKztcbiAgICAgIHZhbHVlU3RhY2tbaW5kZXgkanNjb21wJDBdID0gY3Vyc29yLmN1cnJlbnQ7XG4gICAgICBmaWJlclN0YWNrW2luZGV4JGpzY29tcCQwXSA9IGZpYmVyO1xuICAgICAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gICAgICB4ID4+Pj0gMDtcbiAgICAgIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyQxKHgpIC8gTE4yKSB8IDApKSB8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExhYmVsRm9yTGFuZShsYW5lKSB7XG4gICAgICBpZiAobGFuZSAmIDEpIHJldHVybiBcIlN5bmNIeWRyYXRpb25MYW5lXCI7XG4gICAgICBpZiAobGFuZSAmIDIpIHJldHVybiBcIlN5bmNcIjtcbiAgICAgIGlmIChsYW5lICYgNCkgcmV0dXJuIFwiSW5wdXRDb250aW51b3VzSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDgpIHJldHVybiBcIklucHV0Q29udGludW91c1wiO1xuICAgICAgaWYgKGxhbmUgJiAxNikgcmV0dXJuIFwiRGVmYXVsdEh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAzMikgcmV0dXJuIFwiRGVmYXVsdFwiO1xuICAgICAgaWYgKGxhbmUgJiA2NCkgcmV0dXJuIFwiVHJhbnNpdGlvbkh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiA0MTk0MTc2KSByZXR1cm4gXCJUcmFuc2l0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDYyOTE0NTYwKSByZXR1cm4gXCJSZXRyeVwiO1xuICAgICAgaWYgKGxhbmUgJiA2NzEwODg2NCkgcmV0dXJuIFwiU2VsZWN0aXZlSHlkcmF0aW9uXCI7XG4gICAgICBpZiAobGFuZSAmIDEzNDIxNzcyOCkgcmV0dXJuIFwiSWRsZUh5ZHJhdGlvblwiO1xuICAgICAgaWYgKGxhbmUgJiAyNjg0MzU0NTYpIHJldHVybiBcIklkbGVcIjtcbiAgICAgIGlmIChsYW5lICYgNTM2ODcwOTEyKSByZXR1cm4gXCJPZmZzY3JlZW5cIjtcbiAgICAgIGlmIChsYW5lICYgMTA3Mzc0MTgyNCkgcmV0dXJuIFwiRGVmZXJyZWRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAgICAgIHZhciBwZW5kaW5nU3luY0xhbmVzID0gbGFuZXMgJiA0MjtcbiAgICAgIGlmICgwICE9PSBwZW5kaW5nU3luY0xhbmVzKSByZXR1cm4gcGVuZGluZ1N5bmNMYW5lcztcbiAgICAgIHN3aXRjaCAobGFuZXMgJiAtbGFuZXMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gNDtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgcmV0dXJuIDY0O1xuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDQxOTQxNzY7XG4gICAgICAgIGNhc2UgNDE5NDMwNDpcbiAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgICAgIHJldHVybiBsYW5lcyAmIDYyOTE0NTYwO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICAgIHJldHVybiA2NzEwODg2NDtcbiAgICAgICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICAgICAgcmV0dXJuIDEzNDIxNzcyODtcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgICAgcmV0dXJuIDI2ODQzNTQ1NjtcbiAgICAgICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgICAgICAgcmV0dXJuIDUzNjg3MDkxMjtcbiAgICAgICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgICAgIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgIGlmICgwID09PSBwZW5kaW5nTGFuZXMpIHJldHVybiAwO1xuICAgICAgdmFyIG5leHRMYW5lcyA9IDAsXG4gICAgICAgIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgICB3YXJtTGFuZXMgPSByb290Lndhcm1MYW5lcztcbiAgICAgIHJvb3QgPSAwICE9PSByb290LmZpbmlzaGVkTGFuZXM7XG4gICAgICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIDEzNDIxNzcyNztcbiAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgPyAoKHBlbmRpbmdMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IHBlbmRpbmdMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGVuZGluZ0xhbmVzKSlcbiAgICAgICAgICAgIDogKChwaW5nZWRMYW5lcyAmPSBub25JZGxlUGVuZGluZ0xhbmVzKSxcbiAgICAgICAgICAgICAgMCAhPT0gcGluZ2VkTGFuZXNcbiAgICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgICAgOiByb290IHx8XG4gICAgICAgICAgICAgICAgICAoKHdhcm1MYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKSlcbiAgICAgICAgOiAoKG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgICAgIDAgIT09IG5vbklkbGVQZW5kaW5nTGFuZXNcbiAgICAgICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQZW5kaW5nTGFuZXMpKVxuICAgICAgICAgICAgOiAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgICA/IChuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcykpXG4gICAgICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgICAgICgod2FybUxhbmVzID0gcGVuZGluZ0xhbmVzICYgfndhcm1MYW5lcyksXG4gICAgICAgICAgICAgICAgMCAhPT0gd2FybUxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKTtcbiAgICAgIHJldHVybiAwID09PSBuZXh0TGFuZXNcbiAgICAgICAgPyAwXG4gICAgICAgIDogMCAhPT0gd2lwTGFuZXMgJiZcbiAgICAgICAgICAgIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiZcbiAgICAgICAgICAgIDAgPT09ICh3aXBMYW5lcyAmIHN1c3BlbmRlZExhbmVzKSAmJlxuICAgICAgICAgICAgKChzdXNwZW5kZWRMYW5lcyA9IG5leHRMYW5lcyAmIC1uZXh0TGFuZXMpLFxuICAgICAgICAgICAgKHdhcm1MYW5lcyA9IHdpcExhbmVzICYgLXdpcExhbmVzKSxcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID49IHdhcm1MYW5lcyB8fFxuICAgICAgICAgICAgICAoMzIgPT09IHN1c3BlbmRlZExhbmVzICYmIDAgIT09ICh3YXJtTGFuZXMgJiA0MTk0MTc2KSkpXG4gICAgICAgICAgPyB3aXBMYW5lc1xuICAgICAgICAgIDogbmV4dExhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAwID09PVxuICAgICAgICAocm9vdC5wZW5kaW5nTGFuZXMgJlxuICAgICAgICAgIH4ocm9vdC5zdXNwZW5kZWRMYW5lcyAmIH5yb290LnBpbmdlZExhbmVzKSAmXG4gICAgICAgICAgcmVuZGVyTGFuZXMpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgICAgIHN3aXRjaCAobGFuZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICBjYXNlIDY0OlxuICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgIGNhc2UgNTEyOlxuICAgICAgICBjYXNlIDEwMjQ6XG4gICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICBjYXNlIDgxOTI6XG4gICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgIGNhc2UgNjU1MzY6XG4gICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgY2FzZSA1MjQyODg6XG4gICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgIHJldHVybiBjdXJyZW50VGltZSArIDVlMztcbiAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICBjYXNlIDgzODg2MDg6XG4gICAgICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjYXNlIDY3MTA4ODY0OlxuICAgICAgICBjYXNlIDEzNDIxNzcyODpcbiAgICAgICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgICAgIGNhc2UgNTM2ODcwOTEyOlxuICAgICAgICBjYXNlIDEwNzM3NDE4MjQ6XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgLTFcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgICAgIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25MYW5lO1xuICAgICAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuICAgICAgMCA9PT0gKG5leHRUcmFuc2l0aW9uTGFuZSAmIDQxOTQxNzYpICYmIChuZXh0VHJhbnNpdGlvbkxhbmUgPSAxMjgpO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYWltTmV4dFJldHJ5TGFuZSgpIHtcbiAgICAgIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcbiAgICAgIG5leHRSZXRyeUxhbmUgPDw9IDE7XG4gICAgICAwID09PSAobmV4dFJldHJ5TGFuZSAmIDYyOTE0NTYwKSAmJiAobmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQpO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICAgICAgZm9yICh2YXIgbGFuZU1hcCA9IFtdLCBpID0gMDsgMzEgPiBpOyBpKyspIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgICAgIHJldHVybiBsYW5lTWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCB1cGRhdGVMYW5lKSB7XG4gICAgICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lO1xuICAgICAgMjY4NDM1NDU2ICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICgocm9vdC5zdXNwZW5kZWRMYW5lcyA9IDApLFxuICAgICAgICAocm9vdC5waW5nZWRMYW5lcyA9IDApLFxuICAgICAgICAocm9vdC53YXJtTGFuZXMgPSAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQoXG4gICAgICByb290LFxuICAgICAgZmluaXNoZWRMYW5lcyxcbiAgICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgICAgc3Bhd25lZExhbmUsXG4gICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldmlvdXNseVBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICAgICAgcm9vdC5waW5nZWRMYW5lcyA9IDA7XG4gICAgICByb290Lndhcm1MYW5lcyA9IDA7XG4gICAgICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgICAgIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gICAgICByb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICAgICAgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzLFxuICAgICAgICBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcyxcbiAgICAgICAgaGlkZGVuVXBkYXRlcyA9IHJvb3QuaGlkZGVuVXBkYXRlcztcbiAgICAgIGZvciAoXG4gICAgICAgIHJlbWFpbmluZ0xhbmVzID0gcHJldmlvdXNseVBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgICAgICAgMCA8IHJlbWFpbmluZ0xhbmVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihyZW1haW5pbmdMYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdID0gMDtcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IC0xO1xuICAgICAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4XTtcbiAgICAgICAgaWYgKG51bGwgIT09IGhpZGRlblVwZGF0ZXNGb3JMYW5lKVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBoaWRkZW5VcGRhdGVzW2luZGV4XSA9IG51bGwsIGluZGV4ID0gMDtcbiAgICAgICAgICAgIGluZGV4IDwgaGlkZGVuVXBkYXRlc0ZvckxhbmUubGVuZ3RoO1xuICAgICAgICAgICAgaW5kZXgrK1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2luZGV4XTtcbiAgICAgICAgICAgIG51bGwgIT09IHVwZGF0ZSAmJiAodXBkYXRlLmxhbmUgJj0gLTUzNjg3MDkxMyk7XG4gICAgICAgICAgfVxuICAgICAgICByZW1haW5pbmdMYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIDAgIT09IHNwYXduZWRMYW5lICYmIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCAwKTtcbiAgICAgIDAgIT09IHN1c3BlbmRlZFJldHJ5TGFuZXMgJiZcbiAgICAgICAgMCA9PT0gdXBkYXRlZExhbmVzICYmXG4gICAgICAgIDAgIT09IHJvb3QudGFnICYmXG4gICAgICAgIChyb290LnN1c3BlbmRlZExhbmVzIHw9XG4gICAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyAmIH4ocHJldmlvdXNseVBlbmRpbmdMYW5lcyAmIH5maW5pc2hlZExhbmVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gICAgICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTtcbiAgICAgIHZhciBzcGF3bmVkTGFuZUluZGV4ID0gMzEgLSBjbHozMihzcGF3bmVkTGFuZSk7XG4gICAgICByb290LmVudGFuZ2xlZExhbmVzIHw9IHNwYXduZWRMYW5lO1xuICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdID1cbiAgICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdIHxcbiAgICAgICAgMTA3Mzc0MTgyNCB8XG4gICAgICAgIChlbnRhbmdsZWRMYW5lcyAmIDQxOTQyMTgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IChyb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgICAgIGZvciAocm9vdCA9IHJvb3QuZW50YW5nbGVtZW50czsgcm9vdEVudGFuZ2xlZExhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihyb290RW50YW5nbGVkTGFuZXMpLFxuICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAobGFuZSAmIGVudGFuZ2xlZExhbmVzKSB8IChyb290W2luZGV4XSAmIGVudGFuZ2xlZExhbmVzKSAmJlxuICAgICAgICAgIChyb290W2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgICAgIHJvb3RFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lcykge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICBmb3IgKHJvb3QgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7IDAgPCBsYW5lczsgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgICBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgICAgICByb290W2luZGV4XS5hZGQoZmliZXIpO1xuICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwLFxuICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbGFuZXM7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyk7XG4gICAgICAgICAgcm9vdCA9IDEgPDwgaW5kZXg7XG4gICAgICAgICAgaW5kZXggPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcbiAgICAgICAgICAwIDwgaW5kZXguc2l6ZSAmJlxuICAgICAgICAgICAgKGluZGV4LmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkgfHxcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4LmNsZWFyKCkpO1xuICAgICAgICAgIGxhbmVzICY9IH5yb290O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gICAgICBsYW5lcyAmPSAtbGFuZXM7XG4gICAgICByZXR1cm4gMiA8IGxhbmVzXG4gICAgICAgID8gOCA8IGxhbmVzXG4gICAgICAgICAgPyAwICE9PSAobGFuZXMgJiAxMzQyMTc3MjcpXG4gICAgICAgICAgICA/IDMyXG4gICAgICAgICAgICA6IDI2ODQzNTQ1NlxuICAgICAgICAgIDogOFxuICAgICAgICA6IDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgICAgIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKSByZXR1cm4gITE7XG4gICAgICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgICAgIGlmIChob29rLmlzRGlzYWJsZWQpIHJldHVybiAhMDtcbiAgICAgIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlRoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9yZWFjdC1kZXZ0b29sc1wiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAhMFxuICAgICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgKHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpKSwgKGluamVjdGVkSG9vayA9IGhvb2spO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLlwiLCBlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvb2suY2hlY2tEQ0UgPyAhMCA6ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbW1pdFJvb3QkMShyb290LCBldmVudFByaW9yaXR5KSB7XG4gICAgICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZGlkRXJyb3IgPSAxMjggPT09IChyb290LmN1cnJlbnQuZmxhZ3MgJiAxMjgpO1xuICAgICAgICAgIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChcbiAgICAgICAgICAgIHJlbmRlcmVySUQsXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHksXG4gICAgICAgICAgICBkaWRFcnJvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsb2cgJiZcbiAgICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUocmVuZGVyZXJJRCwgbmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbmplY3RQcm9maWxpbmdIb29rcyhwcm9maWxpbmdIb29rcykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQgJiZcbiAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZW5kZXJTdG9wcGVkKCkge1xuICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgICAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmIG51bGwgIT09IHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IENhcHR1cmVkU3RhY2tzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmICh2b2lkIDAgIT09IGV4aXN0aW5nKSByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gICAgICAgIH07XG4gICAgICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuKSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleCsrXSA9IHRyZWVGb3JrQ291bnQ7XG4gICAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya1Byb3ZpZGVyO1xuICAgICAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdHJlZUZvcmtDb3VudCA9IHRvdGFsQ2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gICAgICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICY9IH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gICAgICBpZiAoMzAgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIChiYXNlTGVuZ3RoICUgNSk7XG4gICAgICAgIGxlbmd0aCA9IChcbiAgICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmXG4gICAgICAgICAgKCgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDEpXG4gICAgICAgICkudG9TdHJpbmcoMzIpO1xuICAgICAgICBiYXNlSWRXaXRoTGVhZGluZ0JpdCA+Pj0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIGJhc2VMZW5ndGggLT0gbnVtYmVyT2ZPdmVyZmxvd0JpdHM7XG4gICAgICAgIHRyZWVDb250ZXh0SWQgPVxuICAgICAgICAgICgxIDw8ICgzMiAtIGNsejMyKHRvdGFsQ2hpbGRyZW4pICsgYmFzZUxlbmd0aCkpIHxcbiAgICAgICAgICAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfFxuICAgICAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0O1xuICAgICAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gbGVuZ3RoICsgd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVDb250ZXh0SWQgPVxuICAgICAgICAgICgxIDw8IGxlbmd0aCkgfCAoaW5kZXggPDwgYmFzZUxlbmd0aCkgfCBiYXNlSWRXaXRoTGVhZGluZ0JpdCksXG4gICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MucmV0dXJuICYmXG4gICAgICAgIChwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIDEpLCBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCAxLCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBmb3IgKDsgd29ya0luUHJvZ3Jlc3MgPT09IHRyZWVGb3JrUHJvdmlkZXI7IClcbiAgICAgICAgKHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAgICAgKHRyZWVGb3JrQ291bnQgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCk7XG4gICAgICBmb3IgKDsgd29ya0luUHJvZ3Jlc3MgPT09IHRyZWVDb250ZXh0UHJvdmlkZXI7IClcbiAgICAgICAgKHRyZWVDb250ZXh0UHJvdmlkZXIgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpIHtcbiAgICAgIGlzSHlkcmF0aW5nIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBiZSBoeWRyYXRpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgICBudWxsID09PSBjICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBudWxsLCBmaWJlcik7XG4gICAgICBuZXh0Um9vdEluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIHB1c2goaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpO1xuICAgICAgY29udGV4dCAhPT0gbmV4dENvbnRleHQgJiZcbiAgICAgICAgKHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlciksXG4gICAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAgIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgICAgIChwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlciksIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpKTtcbiAgICAgIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IuY3VycmVudCA9PT0gZmliZXIgJiZcbiAgICAgICAgKHBvcChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLCBmaWJlciksXG4gICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyXG4gICAgICAgICAgPyAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbilcbiAgICAgICAgICA6IChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBOb3RQZW5kaW5nVHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kTm90YWJsZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzICYmXG4gICAgICAgIDAgPT09IG5vZGUuc2VydmVyVGFpbC5sZW5ndGggJiZcbiAgICAgICAgMSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgMyA8IG5vZGUuZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiAxNSAtIGluZGVudFxuICAgICAgICA/IGZpbmROb3RhYmxlTm9kZShub2RlLmNoaWxkcmVuWzBdLCBpbmRlbnQpXG4gICAgICAgIDogbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZW50YXRpb24oaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCIgIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRlZChpbmRlbnQpIHtcbiAgICAgIHJldHVybiBcIisgXCIgKyBcIiAgXCIucmVwZWF0KGluZGVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gICAgICByZXR1cm4gXCItIFwiICsgXCIgIFwiLnJlcGVhdChpbmRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUZpYmVyVHlwZShmaWJlcikge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBmaWJlci50eXBlO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJldHVybiBcIkxhenlcIjtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIChmaWJlciA9IGZpYmVyLnR5cGUpLCBmaWJlci5kaXNwbGF5TmFtZSB8fCBmaWJlci5uYW1lIHx8IG51bGw7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChmaWJlciA9IGZpYmVyLnR5cGUucmVuZGVyKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiAoZmliZXIgPSBmaWJlci50eXBlKSwgZmliZXIuZGlzcGxheU5hbWUgfHwgZmliZXIubmFtZSB8fCBudWxsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVRleHROb2RlKGNvbnRlbnQsIG1heExlbmd0aCkge1xuICAgICAgcmV0dXJuIG5lZWRzRXNjYXBpbmcudGVzdChjb250ZW50KVxuICAgICAgICA/ICgoY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKSxcbiAgICAgICAgICBjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aCAtIDJcbiAgICAgICAgICAgID8gOCA+IG1heExlbmd0aFxuICAgICAgICAgICAgICA/ICd7XCIuLi5cIn0nXG4gICAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDcpICsgJy4uLlwifSdcbiAgICAgICAgICAgIDogXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCIpXG4gICAgICAgIDogY29udGVudC5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICA/IDUgPiBtYXhMZW5ndGhcbiAgICAgICAgICAgID8gJ3tcIi4uLlwifSdcbiAgICAgICAgICAgIDogY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKSArIFwiLi4uXCJcbiAgICAgICAgICA6IGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIG1heExlbmd0aCA9IDEyMCAtIDIgKiBpbmRlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gc2VydmVyUHJvcHMpXG4gICAgICAgIHJldHVybiBhZGRlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgXCJcXG5cIjtcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2Ygc2VydmVyUHJvcHMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgZmlyc3REaWZmID0gMDtcbiAgICAgICAgICBmaXJzdERpZmYgPCBzZXJ2ZXJQcm9wcy5sZW5ndGggJiZcbiAgICAgICAgICBmaXJzdERpZmYgPCBjbGllbnRUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgIHNlcnZlclByb3BzLmNoYXJDb2RlQXQoZmlyc3REaWZmKSA9PT1cbiAgICAgICAgICAgIGNsaWVudFRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpO1xuICAgICAgICAgIGZpcnN0RGlmZisrXG4gICAgICAgICk7XG4gICAgICAgIGZpcnN0RGlmZiA+IG1heExlbmd0aCAtIDggJiZcbiAgICAgICAgICAxMCA8IGZpcnN0RGlmZiAmJlxuICAgICAgICAgICgoY2xpZW50VGV4dCA9IFwiLi4uXCIgKyBjbGllbnRUZXh0LnNsaWNlKGZpcnN0RGlmZiAtIDgpKSxcbiAgICAgICAgICAoc2VydmVyUHJvcHMgPSBcIi4uLlwiICsgc2VydmVyUHJvcHMuc2xpY2UoZmlyc3REaWZmIC0gOCkpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhZGRlZChpbmRlbnQpICtcbiAgICAgICAgICBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgK1xuICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgIHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJQcm9wcywgbWF4TGVuZ3RoKSArXG4gICAgICAgICAgXCJcXG5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgaW5kZW50YXRpb24oaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9iamVjdE5hbWUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAuY2FsbChvYmplY3QpXG4gICAgICAgIC5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgICAgICAgcmV0dXJuIHAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKSksXG4gICAgICAgICAgICB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGhcbiAgICAgICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICAgICAgPyAnXCIuLi5cIidcbiAgICAgICAgICAgICAgICA6IHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDQpICsgJy4uLlwiJ1xuICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGlmIChudWxsID09PSB2YWx1ZSkgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIGlmIChpc0FycmF5SW1wbCh2YWx1ZSkpIHJldHVybiBcIlsuLi5dXCI7XG4gICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh2YWx1ZS50eXBlKSlcbiAgICAgICAgICAgICAgPyBcIjxcIiArIG1heExlbmd0aCArIFwiPlwiXG4gICAgICAgICAgICAgIDogXCI8Li4uPlwiO1xuICAgICAgICAgIHZhciBuYW1lID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKFwiT2JqZWN0XCIgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IDI7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZSlcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciBqc29uUHJvcE5hbWUgPSBKU09OLnN0cmluZ2lmeShwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAganNvblByb3BOYW1lICE9PSAnXCInICsgcHJvcE5hbWUgKyAnXCInICYmXG4gICAgICAgICAgICAgICAgICAocHJvcE5hbWUgPSBqc29uUHJvcE5hbWUpO1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIGpzb25Qcm9wTmFtZSA9IGRlc2NyaWJlVmFsdWUoXG4gICAgICAgICAgICAgICAgICB2YWx1ZVtwcm9wTmFtZV0sXG4gICAgICAgICAgICAgICAgICAxNSA+IG1heExlbmd0aCA/IG1heExlbmd0aCA6IDE1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBtYXhMZW5ndGggLT0ganNvblByb3BOYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoMCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgbmFtZSArPSBcIlwiID09PSBuYW1lID8gXCIuLi5cIiA6IFwiLCAuLi5cIjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuYW1lICs9XG4gICAgICAgICAgICAgICAgICAoXCJcIiA9PT0gbmFtZSA/IFwiXCIgOiBcIixcIikgKyBwcm9wTmFtZSArIFwiOlwiICsganNvblByb3BOYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBuYW1lICsgXCJ9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gKG1heExlbmd0aCA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUpXG4gICAgICAgICAgICA/IFwiZnVuY3Rpb24gXCIgKyBtYXhMZW5ndGhcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZVByb3BWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHZhbHVlIHx8IG5lZWRzRXNjYXBpbmcudGVzdCh2YWx1ZSlcbiAgICAgICAgPyBcIntcIiArIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCAtIDIpICsgXCJ9XCJcbiAgICAgICAgOiB2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGggLSAyXG4gICAgICAgICAgPyA1ID4gbWF4TGVuZ3RoXG4gICAgICAgICAgICA/ICdcIi4uLlwiJ1xuICAgICAgICAgICAgOiAnXCInICsgdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNSkgKyAnLi4uXCInXG4gICAgICAgICAgOiAnXCInICsgdmFsdWUgKyAnXCInO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBwcm9wcywgcm93UHJlZml4KSB7XG4gICAgICB2YXIgcmVtYWluaW5nUm93TGVuZ3RoID0gMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHR5cGUubGVuZ3RoLFxuICAgICAgICBwcm9wZXJ0aWVzID0gW10sXG4gICAgICAgIHByb3BOYW1lO1xuICAgICAgZm9yIChwcm9wTmFtZSBpbiBwcm9wcylcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiBcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgcHJvcHNbcHJvcE5hbWVdLFxuICAgICAgICAgICAgMTIwIC0gcm93UHJlZml4Lmxlbmd0aCAtIHByb3BOYW1lLmxlbmd0aCAtIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlbWFpbmluZ1Jvd0xlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcE5hbWUgKyBcIj1cIiArIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAwID09PSBwcm9wZXJ0aWVzLmxlbmd0aFxuICAgICAgICA/IHJvd1ByZWZpeCArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiXG4gICAgICAgIDogMCA8IHJlbWFpbmluZ1Jvd0xlbmd0aFxuICAgICAgICAgID8gcm93UHJlZml4ICsgXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBwcm9wZXJ0aWVzLmpvaW4oXCIgXCIpICsgXCI+XFxuXCJcbiAgICAgICAgICA6IHJvd1ByZWZpeCArXG4gICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgcm93UHJlZml4ICtcbiAgICAgICAgICAgIFwiICBcIiArXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmpvaW4oXCJcXG5cIiArIHJvd1ByZWZpeCArIFwiICBcIikgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICByb3dQcmVmaXggK1xuICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoY2xpZW50T2JqZWN0LCBzZXJ2ZXJPYmplY3QsIGluZGVudCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBcIlwiLFxuICAgICAgICByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzID0gYXNzaWduKHt9LCBzZXJ2ZXJPYmplY3QpLFxuICAgICAgICBwcm9wTmFtZTtcbiAgICAgIGZvciAocHJvcE5hbWUgaW4gY2xpZW50T2JqZWN0KVxuICAgICAgICBpZiAoY2xpZW50T2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgIGRlbGV0ZSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIGluZGVudCAtIHByb3BOYW1lLmxlbmd0aCAtIDIsXG4gICAgICAgICAgICBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKGNsaWVudE9iamVjdFtwcm9wTmFtZV0sIG1heExlbmd0aCk7XG4gICAgICAgICAgc2VydmVyT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKVxuICAgICAgICAgICAgPyAoKG1heExlbmd0aCA9IGRlc2NyaWJlVmFsdWUoc2VydmVyT2JqZWN0W3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgXCI6IFwiICsgY2xpZW50UHJvcFZhbHVlICsgXCJcXG5cIiksXG4gICAgICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBtYXhMZW5ndGggKyBcIlxcblwiKSlcbiAgICAgICAgICAgIDogKHByb3BlcnRpZXMgKz1cbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRQcm9wVmFsdWUgKyBcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMpXG4gICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSAmJlxuICAgICAgICAgICgoY2xpZW50T2JqZWN0ID0gZGVzY3JpYmVWYWx1ZShcbiAgICAgICAgICAgIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbX3Byb3BOYW1lXSxcbiAgICAgICAgICAgIDEyMCAtIDIgKiBpbmRlbnQgLSBfcHJvcE5hbWUubGVuZ3RoIC0gMlxuICAgICAgICAgICkpLFxuICAgICAgICAgIChwcm9wZXJ0aWVzICs9XG4gICAgICAgICAgICByZW1vdmVkKGluZGVudCkgKyBfcHJvcE5hbWUgKyBcIjogXCIgKyBjbGllbnRPYmplY3QgKyBcIlxcblwiKSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiLFxuICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKHByb3BOYW1lJGpzY29tcCQwIGluIHNlcnZlclByb3BzKVxuICAgICAgICBzZXJ2ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSRqc2NvbXAkMCkgJiZcbiAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZXMuc2V0KFxuICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHByb3BOYW1lJGpzY29tcCQwXG4gICAgICAgICAgKTtcbiAgICAgIGlmICgxID09PSBzZXJ2ZXJQcm9wTmFtZXMuc2l6ZSAmJiBzZXJ2ZXJQcm9wTmFtZXMuaGFzKFwiY2hpbGRyZW5cIikpXG4gICAgICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjbGllbnRQcm9wcyxcbiAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpXG4gICAgICAgICk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX3Byb3BOYW1lMiBpbiBjbGllbnRQcm9wcylcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjbGllbnRQcm9wcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUyKSAmJlxuICAgICAgICAgICAgXCJjaGlsZHJlblwiICE9PSBfcHJvcE5hbWUyXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoJGpzY29tcCQwID1cbiAgICAgICAgICAgICAgICAxMjAgLSAyICogKGluZGVudCArIDEpIC0gX3Byb3BOYW1lMi5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BOYW1lcy5nZXQoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IHNlcnZlclByb3BOYW1lKSB7XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lcy5kZWxldGUoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgdmFyIHByb3BOYW1lJGpzY29tcCQwID0gY2xpZW50UHJvcHNbX3Byb3BOYW1lMl07XG4gICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lID0gc2VydmVyUHJvcHNbc2VydmVyUHJvcE5hbWVdO1xuICAgICAgICAgICAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoXG4gICAgICAgICAgICAgICAgcHJvcE5hbWUkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoJGpzY29tcCQwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCA9IGRlc2NyaWJlUHJvcFZhbHVlKFxuICAgICAgICAgICAgICAgIHNlcnZlclByb3BOYW1lLFxuICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcHJvcE5hbWUkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHNlcnZlclByb3BOYW1lICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUocHJvcE5hbWUkanNjb21wJDApICYmXG4gICAgICAgICAgICAgIFwiT2JqZWN0XCIgPT09IG9iamVjdE5hbWUoc2VydmVyUHJvcE5hbWUpICYmXG4gICAgICAgICAgICAgICgyIDwgT2JqZWN0LmtleXMocHJvcE5hbWUkanNjb21wJDApLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIDIgPCBPYmplY3Qua2V5cyhzZXJ2ZXJQcm9wTmFtZSkubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLTEgPCBjbGllbnRQcm9wVmFsdWUuaW5kZXhPZihcIi4uLlwiKSB8fFxuICAgICAgICAgICAgICAgIC0xIDwgbWF4TGVuZ3RoJGpzY29tcCQwLmluZGV4T2YoXCIuLi5cIikpXG4gICAgICAgICAgICAgICAgPyAoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj17e1xcblwiICtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihcbiAgICAgICAgICAgICAgICAgICAgICBwcm9wTmFtZSRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQcm9wTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKyAyXG4gICAgICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIFwifX1cXG5cIilcbiAgICAgICAgICAgICAgICA6ICgoY29udGVudCArPVxuICAgICAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudFByb3BWYWx1ZSArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpLFxuICAgICAgICAgICAgICAgICAgKGNvbnRlbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZChpbmRlbnQgKyAxKSArXG4gICAgICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgICAgICBcIj1cIiArXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aCRqc2NvbXAkMCArXG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgICAgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICAgIF9wcm9wTmFtZTIgK1xuICAgICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgICBkZXNjcmliZVByb3BWYWx1ZShjbGllbnRQcm9wc1tfcHJvcE5hbWUyXSwgbWF4TGVuZ3RoJGpzY29tcCQwKSArXG4gICAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIHNlcnZlclByb3BOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgICAgIGlmIChcImNoaWxkcmVuXCIgIT09IHByb3BOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbWF4TGVuZ3RoID0gMTIwIC0gMiAqIChpbmRlbnQgKyAxKSAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBjb250ZW50ICs9XG4gICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50ICsgMSkgK1xuICAgICAgICAgICAgICBwcm9wTmFtZSArXG4gICAgICAgICAgICAgIFwiPVwiICtcbiAgICAgICAgICAgICAgZGVzY3JpYmVQcm9wVmFsdWUoc2VydmVyUHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpICtcbiAgICAgICAgICAgICAgXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZW50ID1cbiAgICAgICAgICBcIlwiID09PSBjb250ZW50XG4gICAgICAgICAgICA/IGluZGVudGF0aW9uKGluZGVudCkgKyBcIjxcIiArIHR5cGUgKyBcIj5cXG5cIlxuICAgICAgICAgICAgOiBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI8XCIgK1xuICAgICAgICAgICAgICB0eXBlICtcbiAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgIGNvbnRlbnQgK1xuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICtcbiAgICAgICAgICAgICAgXCI+XFxuXCI7XG4gICAgICB9XG4gICAgICB0eXBlID0gc2VydmVyUHJvcHMuY2hpbGRyZW47XG4gICAgICBjbGllbnRQcm9wcyA9IGNsaWVudFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgKSB7XG4gICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgY2xpZW50UHJvcHMgfHxcbiAgICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgICAgKVxuICAgICAgICAgIHNlcnZlclByb3BOYW1lcyA9IFwiXCIgKyBjbGllbnRQcm9wcztcbiAgICAgICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKHNlcnZlclByb3BOYW1lcywgXCJcIiArIHR5cGUsIGluZGVudCArIDEpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNsaWVudFByb3BzIHx8XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBjbGllbnRQcm9wcyB8fFxuICAgICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgY2xpZW50UHJvcHNcbiAgICAgIClcbiAgICAgICAgY29udGVudCA9XG4gICAgICAgICAgbnVsbCA9PSB0eXBlXG4gICAgICAgICAgICA/IGNvbnRlbnQgKyBkZXNjcmliZVRleHREaWZmKFwiXCIgKyBjbGllbnRQcm9wcywgbnVsbCwgaW5kZW50ICsgMSlcbiAgICAgICAgICAgIDogY29udGVudCArIGRlc2NyaWJlVGV4dERpZmYoXCJcIiArIGNsaWVudFByb3BzLCB2b2lkIDAsIGluZGVudCArIDEpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpIHtcbiAgICAgIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpO1xuICAgICAgaWYgKG51bGwgPT09IHR5cGUpIHtcbiAgICAgICAgdHlwZSA9IFwiXCI7XG4gICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgZmliZXI7IClcbiAgICAgICAgICAodHlwZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSksXG4gICAgICAgICAgICAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArIFwiPFwiICsgdHlwZSArIFwiPlxcblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjcmliZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gICAgICB2YXIgc2tpcFRvTm9kZSA9IGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpO1xuICAgICAgaWYgKFxuICAgICAgICBza2lwVG9Ob2RlICE9PSBub2RlICYmXG4gICAgICAgICgxICE9PSBub2RlLmNoaWxkcmVuLmxlbmd0aCB8fCBub2RlLmNoaWxkcmVuWzBdICE9PSBza2lwVG9Ob2RlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGluZGVudGF0aW9uKGluZGVudCkgKyBcIi4uLlxcblwiICsgZGVzY3JpYmVOb2RlKHNraXBUb05vZGUsIGluZGVudCArIDEpXG4gICAgICAgICk7XG4gICAgICBza2lwVG9Ob2RlID0gXCJcIjtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSBub2RlLmZpYmVyLl9kZWJ1Z0luZm87XG4gICAgICBpZiAoZGVidWdJbmZvKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVidWdJbmZvW2ldLm5hbWU7XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICgoc2tpcFRvTm9kZSArPVxuICAgICAgICAgICAgICBpbmRlbnRhdGlvbihpbmRlbnQpICsgXCI8XCIgKyBzZXJ2ZXJDb21wb25lbnROYW1lICsgXCI+XFxuXCIpLFxuICAgICAgICAgICAgaW5kZW50KyspO1xuICAgICAgICB9XG4gICAgICBkZWJ1Z0luZm8gPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgaWYgKDYgPT09IG5vZGUuZmliZXIudGFnKVxuICAgICAgICAoZGVidWdJbmZvID0gZGVzY3JpYmVUZXh0RGlmZihpLCBub2RlLnNlcnZlclByb3BzLCBpbmRlbnQpKSwgaW5kZW50Kys7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgKChzZXJ2ZXJDb21wb25lbnROYW1lID0gZGVzY3JpYmVGaWJlclR5cGUobm9kZS5maWJlcikpLFxuICAgICAgICBudWxsICE9PSBzZXJ2ZXJDb21wb25lbnROYW1lKVxuICAgICAgKVxuICAgICAgICBpZiAodm9pZCAwID09PSBub2RlLnNlcnZlclByb3BzKSB7XG4gICAgICAgICAgZGVidWdJbmZvID0gaW5kZW50O1xuICAgICAgICAgIHZhciBtYXhMZW5ndGggPSAxMjAgLSAyICogZGVidWdJbmZvIC0gc2VydmVyQ29tcG9uZW50TmFtZS5sZW5ndGggLSAyLFxuICAgICAgICAgICAgY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgZm9yIChwcm9wTmFtZSBpbiBpKVxuICAgICAgICAgICAgaWYgKGkuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmIFwiY2hpbGRyZW5cIiAhPT0gcHJvcE5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKGlbcHJvcE5hbWVdLCAxNSk7XG4gICAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgaWYgKDAgPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ICs9IFwiIC4uLlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRlbnQgKz0gXCIgXCIgKyBwcm9wTmFtZSArIFwiPVwiICsgcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnSW5mbyA9XG4gICAgICAgICAgICBpbmRlbnRhdGlvbihkZWJ1Z0luZm8pICtcbiAgICAgICAgICAgIFwiPFwiICtcbiAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUgK1xuICAgICAgICAgICAgY29udGVudCArXG4gICAgICAgICAgICBcIj5cXG5cIjtcbiAgICAgICAgICBpbmRlbnQrKztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbnVsbCA9PT0gbm9kZS5zZXJ2ZXJQcm9wc1xuICAgICAgICAgICAgPyAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgIHNlcnZlckNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBhZGRlZChpbmRlbnQpXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBpbmRlbnQrKylcbiAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5vZGUuc2VydmVyUHJvcHNcbiAgICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJTaG91bGQgbm90IGhhdmUgbWF0Y2hlZCBhIG5vbiBIb3N0VGV4dCBmaWJlciB0byBhIFRleHQgbm9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAoKGRlYnVnSW5mbyA9IGRlc2NyaWJlRWxlbWVudERpZmYoXG4gICAgICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgIG5vZGUuc2VydmVyUHJvcHMsXG4gICAgICAgICAgICAgICAgICBpbmRlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBpbmRlbnQrKyk7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBcIlwiO1xuICAgICAgaSA9IG5vZGUuZmliZXIuY2hpbGQ7XG4gICAgICBmb3IgKFxuICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lID0gMDtcbiAgICAgICAgaSAmJiBzZXJ2ZXJDb21wb25lbnROYW1lIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgIClcbiAgICAgICAgKG1heExlbmd0aCA9IG5vZGUuY2hpbGRyZW5bc2VydmVyQ29tcG9uZW50TmFtZV0pLFxuICAgICAgICAgIG1heExlbmd0aC5maWJlciA9PT0gaVxuICAgICAgICAgICAgPyAoKHByb3BOYW1lICs9IGRlc2NyaWJlTm9kZShtYXhMZW5ndGgsIGluZGVudCkpLFxuICAgICAgICAgICAgICBzZXJ2ZXJDb21wb25lbnROYW1lKyspXG4gICAgICAgICAgICA6IChwcm9wTmFtZSArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihpLCBpbmRlbnQpKSxcbiAgICAgICAgICAoaSA9IGkuc2libGluZyk7XG4gICAgICBpICYmXG4gICAgICAgIDAgPCBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxuICAgICAgICAocHJvcE5hbWUgKz0gaW5kZW50YXRpb24oaW5kZW50KSArIFwiLi4uXFxuXCIpO1xuICAgICAgaSA9IG5vZGUuc2VydmVyVGFpbDtcbiAgICAgIG51bGwgPT09IG5vZGUuc2VydmVyUHJvcHMgJiYgaW5kZW50LS07XG4gICAgICBmb3IgKG5vZGUgPSAwOyBub2RlIDwgaS5sZW5ndGg7IG5vZGUrKylcbiAgICAgICAgKHNlcnZlckNvbXBvbmVudE5hbWUgPSBpW25vZGVdKSxcbiAgICAgICAgICAocHJvcE5hbWUgPVxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICAgPyBwcm9wTmFtZSArXG4gICAgICAgICAgICAgICAgKHJlbW92ZWQoaW5kZW50KSArXG4gICAgICAgICAgICAgICAgICBkZXNjcmliZVRleHROb2RlKHNlcnZlckNvbXBvbmVudE5hbWUsIDEyMCAtIDIgKiBpbmRlbnQpICtcbiAgICAgICAgICAgICAgICAgIFwiXFxuXCIpXG4gICAgICAgICAgICAgIDogcHJvcE5hbWUgK1xuICAgICAgICAgICAgICAgIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS50eXBlLFxuICAgICAgICAgICAgICAgICAgc2VydmVyQ29tcG9uZW50TmFtZS5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQoaW5kZW50KVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgcmV0dXJuIHNraXBUb05vZGUgKyBkZWJ1Z0luZm8gKyBwcm9wTmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzY3JpYmVEaWZmKHJvb3ROb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gXCJcXG5cXG5cIiArIGRlc2NyaWJlTm9kZShyb290Tm9kZSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCBkaXN0YW5jZUZyb21MZWFmKSB7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIucmV0dXJuKSB7XG4gICAgICAgIGlmIChudWxsID09PSBoeWRyYXRpb25EaWZmUm9vdERFVilcbiAgICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IHtcbiAgICAgICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHNlcnZlclByb3BzOiB2b2lkIDAsXG4gICAgICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgICAgIGRpc3RhbmNlRnJvbUxlYWY6IGRpc3RhbmNlRnJvbUxlYWZcbiAgICAgICAgICB9O1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZmliZXIgIT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiU2F3IG11bHRpcGxlIGh5ZHJhdGlvbiBkaWZmIHJvb3RzIGluIGEgcGFzcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICB9XG4gICAgICB2YXIgc2libGluZ3MgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKFxuICAgICAgICBmaWJlci5yZXR1cm4sXG4gICAgICAgIGRpc3RhbmNlRnJvbUxlYWYgKyAxXG4gICAgICApLmNoaWxkcmVuO1xuICAgICAgaWYgKDAgPCBzaWJsaW5ncy5sZW5ndGggJiYgc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV0uZmliZXIgPT09IGZpYmVyKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChzaWJsaW5ncyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdKSxcbiAgICAgICAgICBzaWJsaW5ncy5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZiAmJlxuICAgICAgICAgICAgKHNpYmxpbmdzLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmKSxcbiAgICAgICAgICBzaWJsaW5nc1xuICAgICAgICApO1xuICAgICAgZGlzdGFuY2VGcm9tTGVhZiA9IHtcbiAgICAgICAgZmliZXI6IGZpYmVyLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHNlcnZlclByb3BzOiB2b2lkIDAsXG4gICAgICAgIHNlcnZlclRhaWw6IFtdLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICB9O1xuICAgICAgc2libGluZ3MucHVzaChkaXN0YW5jZUZyb21MZWFmKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZUZyb21MZWFmO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgcmVqZWN0ZWRDYW5kaWRhdGUpIHtcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWIHx8XG4gICAgICAgICgoZmliZXIgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKSksXG4gICAgICAgIChmaWJlci5zZXJ2ZXJQcm9wcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSByZWplY3RlZENhbmRpZGF0ZSAmJlxuICAgICAgICAgICgocmVqZWN0ZWRDYW5kaWRhdGUgPVxuICAgICAgICAgICAgZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyhyZWplY3RlZENhbmRpZGF0ZSkpLFxuICAgICAgICAgIGZpYmVyLnNlcnZlclRhaWwucHVzaChyZWplY3RlZENhbmRpZGF0ZSkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKSB7XG4gICAgICB2YXIgZGlmZiA9IFwiXCIsXG4gICAgICAgIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG4gICAgICBudWxsICE9PSBkaWZmUm9vdCAmJlxuICAgICAgICAoKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksIChkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KSkpO1xuICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihcbiAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIkh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQuIEFzIGEgcmVzdWx0IHRoaXMgdHJlZSB3aWxsIGJlIHJlZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuIFRoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuXFxuLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG4tIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG4tIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcbi0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbi0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcblxcbkl0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcblxcbmh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoXCIgK1xuICAgICAgICAgICAgICBkaWZmXG4gICAgICAgICAgKSxcbiAgICAgICAgICBmaWJlclxuICAgICAgICApXG4gICAgICApO1xuICAgICAgdGhyb3cgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIGhvc3RDb250ZXh0KSB7XG4gICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlLFxuICAgICAgICBmaWJlci50eXBlLFxuICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzLFxuICAgICAgICBob3N0Q29udGV4dCxcbiAgICAgICAgZmliZXJcbiAgICAgICkgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgICAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICAgICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICAgIGlmICghc3VwcG9ydHNIeWRyYXRpb24gfHwgZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSByZXR1cm4gITE7XG4gICAgICBpZiAoIWlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlciksIChpc0h5ZHJhdGluZyA9ICEwKSwgITE7XG4gICAgICB2YXIgc2hvdWxkQ2xlYXIgPSAhMTtcbiAgICAgIHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICA/IDMgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAgIDI3ICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAoNSAhPT0gZmliZXIudGFnIHx8XG4gICAgICAgICAgICAoc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkgJiZcbiAgICAgICAgICAoc2hvdWxkQ2xlYXIgPSAhMClcbiAgICAgICAgOiAzICE9PSBmaWJlci50YWcgJiZcbiAgICAgICAgICAoNSAhPT0gZmliZXIudGFnIHx8XG4gICAgICAgICAgICAoc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMoZmliZXIudHlwZSkgJiZcbiAgICAgICAgICAgICAgIXNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkgJiZcbiAgICAgICAgICAoc2hvdWxkQ2xlYXIgPSAhMCk7XG4gICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICBmb3IgKHNob3VsZENsZWFyID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTsgc2hvdWxkQ2xlYXI7ICkge1xuICAgICAgICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHNob3VsZENsZWFyKTtcbiAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuICAgICAgICAgIHNob3VsZENsZWFyID1cbiAgICAgICAgICAgIFwiU3VzcGVuc2VcIiA9PT0gZGVzY3JpcHRpb24udHlwZVxuICAgICAgICAgICAgICA/IGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc2hvdWxkQ2xlYXIpXG4gICAgICAgICAgICAgIDogZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKHNob3VsZENsZWFyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICAgICAgfVxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICBmaWJlciA9IG51bGwgIT09IGZpYmVyID8gZmliZXIuZGVoeWRyYXRlZCA6IG51bGw7XG4gICAgICAgIGlmICghZmliZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UoZmliZXIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgICAgICAgID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSlcbiAgICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAoKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwpLFxuICAgICAgICAoZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBpc0h5ZHJhdGluZyA9ICExKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICAgIG51bGwgPT09IGh5ZHJhdGlvbkVycm9yc1xuICAgICAgICA/IChoeWRyYXRpb25FcnJvcnMgPSBbZXJyb3JdKVxuICAgICAgICA6IGh5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpIHtcbiAgICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICAgICAgbnVsbCAhPT0gZGlmZlJvb3QgJiZcbiAgICAgICAgKChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAoZGlmZlJvb3QgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkEgdHJlZSBoeWRyYXRlZCBidXQgc29tZSBhdHRyaWJ1dGVzIG9mIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgSFRNTCBkaWRuJ3QgbWF0Y2ggdGhlIGNsaWVudCBwcm9wZXJ0aWVzLiBUaGlzIHdvbid0IGJlIHBhdGNoZWQgdXAuIFRoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuXFxuLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG4tIFZhcmlhYmxlIGlucHV0IHN1Y2ggYXMgYERhdGUubm93KClgIG9yIGBNYXRoLnJhbmRvbSgpYCB3aGljaCBjaGFuZ2VzIGVhY2ggdGltZSBpdCdzIGNhbGxlZC5cXG4tIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcbi0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbi0gSW52YWxpZCBIVE1MIHRhZyBuZXN0aW5nLlxcblxcbkl0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcblxcbiVzJXNcIixcbiAgICAgICAgICBcImh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoXCIsXG4gICAgICAgICAgZGlmZlJvb3RcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb25jdXJyZW50UXVldWVzSW5kZXgsXG4gICAgICAgICAgaSA9IChjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwKTtcbiAgICAgICAgaSA8IGVuZEluZGV4O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgICAgIHZhciBsYW5lID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICAgICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IHF1ZXVlICYmIG51bGwgIT09IHVwZGF0ZSkge1xuICAgICAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcbiAgICAgICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgICAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICAgICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIDAgIT09IGxhbmUgJiYgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gICAgICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgICAgIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyB8PSBsYW5lO1xuICAgICAgZmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLmxhbmVzIHw9IGxhbmUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBudWxsLCBudWxsLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qoc291cmNlRmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSBsYW5lKTtcbiAgICAgIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIChwYXJlbnQuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAoYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgICAgICAyMiA9PT0gcGFyZW50LnRhZyAmJlxuICAgICAgICAgICAgKChzb3VyY2VGaWJlciA9IHBhcmVudC5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHxcbiAgICAgICAgICAgICAgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiAxIHx8XG4gICAgICAgICAgICAgIChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAgICAgKHNvdXJjZUZpYmVyID0gcGFyZW50KSxcbiAgICAgICAgICAocGFyZW50ID0gcGFyZW50LnJldHVybik7XG4gICAgICBpc0hpZGRlbiAmJlxuICAgICAgICBudWxsICE9PSB1cGRhdGUgJiZcbiAgICAgICAgMyA9PT0gc291cmNlRmliZXIudGFnICYmXG4gICAgICAgICgocGFyZW50ID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgKGlzSGlkZGVuID0gMzEgLSBjbHozMihsYW5lKSksXG4gICAgICAgIChwYXJlbnQgPSBwYXJlbnQuaGlkZGVuVXBkYXRlcyksXG4gICAgICAgIChzb3VyY2VGaWJlciA9IHBhcmVudFtpc0hpZGRlbl0pLFxuICAgICAgICBudWxsID09PSBzb3VyY2VGaWJlclxuICAgICAgICAgID8gKHBhcmVudFtpc0hpZGRlbl0gPSBbdXBkYXRlXSlcbiAgICAgICAgICA6IHNvdXJjZUZpYmVyLnB1c2godXBkYXRlKSxcbiAgICAgICAgKHVwZGF0ZS5sYW5lID0gbGFuZSB8IDUzNjg3MDkxMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gICAgICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKVxuICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSBuZXN0ZWRVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgIChyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbCksXG4gICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cIlxuICAgICAgICAgICkpXG4gICAgICAgICk7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgJiZcbiAgICAgICAgKChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIk1heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IGhhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uIGV2ZXJ5IHJlbmRlci5cIlxuICAgICAgICApKTtcbiAgICAgIG51bGwgPT09IHNvdXJjZUZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAwICE9PSAoc291cmNlRmliZXIuZmxhZ3MgJiA0MDk4KSAmJlxuICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBzb3VyY2VGaWJlciwgcGFyZW50ID0gbm9kZS5yZXR1cm47IG51bGwgIT09IHBhcmVudDsgKVxuICAgICAgICBudWxsID09PSBub2RlLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIDAgIT09IChub2RlLmZsYWdzICYgNDA5OCkgJiZcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKSxcbiAgICAgICAgICAobm9kZSA9IHBhcmVudCksXG4gICAgICAgICAgKHBhcmVudCA9IG5vZGUucmV0dXJuKTtcbiAgICAgIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5vZGUuc3RhdGVOb2RlIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0RHVyYXRpb24gPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICByZXR1cm4gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMocHJldkVmZmVjdER1cmF0aW9uKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwcm9maWxlckVmZmVjdER1cmF0aW9uO1xuICAgICAgcHJvZmlsZXJFZmZlY3REdXJhdGlvbiA9IHByZXZFZmZlY3REdXJhdGlvbjtcbiAgICAgIHJldHVybiBlbGFwc2VkVGltZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbikge1xuICAgICAgdmFyIGVsYXBzZWRUaW1lID0gcHJvZmlsZXJFZmZlY3REdXJhdGlvbjtcbiAgICAgIHByb2ZpbGVyRWZmZWN0RHVyYXRpb24gKz0gcHJldkVmZmVjdER1cmF0aW9uO1xuICAgICAgcmV0dXJuIGVsYXBzZWRUaW1lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFByb2ZpbGVyVGltZXIoZmliZXIpIHtcbiAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAwID4gZmliZXIuYWN0dWFsU3RhcnRUaW1lICYmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBwcm9maWxlclN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZmliZXIpIHtcbiAgICAgIGlmICgwIDw9IHByb2ZpbGVyU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGZpYmVyKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb3JkRWZmZWN0RHVyYXRpb24oKSB7XG4gICAgICBpZiAoMCA8PSBwcm9maWxlclN0YXJ0VGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydEVmZmVjdFRpbWVyKCkge1xuICAgICAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAgICAgZm9yICh2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgY2hpbGQ7IClcbiAgICAgICAgKGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gICAgICByb290ICE9PSBsYXN0U2NoZWR1bGVkUm9vdCAmJlxuICAgICAgICBudWxsID09PSByb290Lm5leHQgJiZcbiAgICAgICAgKG51bGwgPT09IGxhc3RTY2hlZHVsZWRSb290XG4gICAgICAgICAgPyAoZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290KVxuICAgICAgICAgIDogKGxhc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QubmV4dCA9IHJvb3QpKTtcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWVcbiAgICAgICAgPyBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgfHxcbiAgICAgICAgICAoKGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9ICEwKSxcbiAgICAgICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKSlcbiAgICAgICAgOiBkaWRTY2hlZHVsZU1pY3JvdGFzayB8fFxuICAgICAgICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMCksXG4gICAgICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChzeW5jVHJhbnNpdGlvbkxhbmVzLCBvbmx5TGVnYWN5KSB7XG4gICAgICBpZiAoIWlzRmx1c2hpbmdXb3JrICYmIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yaykge1xuICAgICAgICBpc0ZsdXNoaW5nV29yayA9ICEwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGRpZFBlcmZvcm1Tb21lV29yayA9ICExO1xuICAgICAgICAgIGZvciAodmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7IG51bGwgIT09IHJvb3Q7ICkge1xuICAgICAgICAgICAgaWYgKCFvbmx5TGVnYWN5KVxuICAgICAgICAgICAgICBpZiAoMCAhPT0gc3luY1RyYW5zaXRpb25MYW5lcykge1xuICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gcGVuZGluZ0xhbmVzKSB2YXIgbmV4dExhbmVzID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgICAgICAgICAgICAgICAgIG5leHRMYW5lcyA9XG4gICAgICAgICAgICAgICAgICAgICgxIDw8ICgzMSAtIGNsejMyKDQyIHwgc3luY1RyYW5zaXRpb25MYW5lcykgKyAxKSkgLSAxO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzICY9IHBlbmRpbmdMYW5lcyAmIH4oc3VzcGVuZGVkTGFuZXMgJiB+cGluZ2VkTGFuZXMpO1xuICAgICAgICAgICAgICAgICAgbmV4dExhbmVzID1cbiAgICAgICAgICAgICAgICAgICAgbmV4dExhbmVzICYgMjAxMzI2Njc3XG4gICAgICAgICAgICAgICAgICAgICAgPyAobmV4dExhbmVzICYgMjAxMzI2Njc3KSB8IDFcbiAgICAgICAgICAgICAgICAgICAgICA6IG5leHRMYW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXh0TGFuZXMgfCAyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDAgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIChuZXh0TGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyBuZXh0TGFuZXMgOiAwXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09IChuZXh0TGFuZXMgJiAzKSB8fFxuICAgICAgICAgICAgICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIG5leHRMYW5lcykgfHxcbiAgICAgICAgICAgICAgICAgICAgKChkaWRQZXJmb3JtU29tZVdvcmsgPSAhMCksXG4gICAgICAgICAgICAgICAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBuZXh0TGFuZXMpKTtcbiAgICAgICAgICAgIHJvb3QgPSByb290Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaWRQZXJmb3JtU29tZVdvcmspO1xuICAgICAgICBpc0ZsdXNoaW5nV29yayA9ICExO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKSB7XG4gICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPVxuICAgICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPVxuICAgICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgICAgICAgITE7XG4gICAgICB2YXIgc3luY1RyYW5zaXRpb25MYW5lcyA9IDA7XG4gICAgICAwICE9PSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAmJlxuICAgICAgICAoc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpICYmXG4gICAgICAgICAgKHN5bmNUcmFuc2l0aW9uTGFuZXMgPSBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSksXG4gICAgICAgIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IDApKTtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCksIHByZXYgPSBudWxsLCByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICBudWxsICE9PSByb290O1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5leHQgPSByb290Lm5leHQsXG4gICAgICAgICAgbmV4dExhbmVzID0gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSk7XG4gICAgICAgIGlmICgwID09PSBuZXh0TGFuZXMpXG4gICAgICAgICAgKHJvb3QubmV4dCA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcHJldiA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0KSA6IChwcmV2Lm5leHQgPSBuZXh0KSxcbiAgICAgICAgICAgIG51bGwgPT09IG5leHQgJiYgKGxhc3RTY2hlZHVsZWRSb290ID0gcHJldik7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICgocHJldiA9IHJvb3QpLCAwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzIHx8IDAgIT09IChuZXh0TGFuZXMgJiAzKSlcbiAgICAgICAgKVxuICAgICAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgICAgICByb290ID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSkge1xuICAgICAgZm9yIChcbiAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICAgICAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXMsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICAgICAgbGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIC02MjkxNDU2MTtcbiAgICAgICAgMCA8IGxhbmVzO1xuXG4gICAgICApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXgsXG4gICAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuICAgICAgICBpZiAoLTEgPT09IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgaWYgKDAgPT09IChsYW5lICYgc3VzcGVuZGVkTGFuZXMpIHx8IDAgIT09IChsYW5lICYgcGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH0gZWxzZSBleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSAmJiAocm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZSk7XG4gICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgfVxuICAgICAgY3VycmVudFRpbWUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICBzdXNwZW5kZWRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICAgICAgc3VzcGVuZGVkTGFuZXMgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3QgPT09IGN1cnJlbnRUaW1lID8gc3VzcGVuZGVkTGFuZXMgOiAwXG4gICAgICApO1xuICAgICAgcGluZ2VkTGFuZXMgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgMCA9PT0gc3VzcGVuZGVkTGFuZXMgfHxcbiAgICAgICAgKHJvb3QgPT09IGN1cnJlbnRUaW1lICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSkgfHxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gICAgICApXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbnVsbCAhPT0gcGluZ2VkTGFuZXMgJiYgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpLFxuICAgICAgICAgIChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLFxuICAgICAgICAgIChyb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwKVxuICAgICAgICApO1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSAoc3VzcGVuZGVkTGFuZXMgJiAzKSB8fFxuICAgICAgICBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKHJvb3QsIHN1c3BlbmRlZExhbmVzKVxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRUaW1lID0gc3VzcGVuZGVkTGFuZXMgJiAtc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50VGltZSAhPT0gcm9vdC5jYWxsYmFja1ByaW9yaXR5IHx8XG4gICAgICAgICAgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgICAgICBwaW5nZWRMYW5lcyAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKVxuICAgICAgICApXG4gICAgICAgICAgY2FuY2VsQ2FsbGJhY2socGluZ2VkTGFuZXMpO1xuICAgICAgICBlbHNlIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShzdXNwZW5kZWRMYW5lcykpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI2ODQzNTQ1NjpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN1c3BlbmRlZExhbmVzID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgfVxuICAgICAgICBwaW5nZWRMYW5lcyA9IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpO1xuICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZVxuICAgICAgICAgID8gKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2gocGluZ2VkTGFuZXMpLFxuICAgICAgICAgICAgKHN1c3BlbmRlZExhbmVzID0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKSlcbiAgICAgICAgICA6IChzdXNwZW5kZWRMYW5lcyA9IHNjaGVkdWxlQ2FsbGJhY2skMyhzdXNwZW5kZWRMYW5lcywgcGluZ2VkTGFuZXMpKTtcbiAgICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gY3VycmVudFRpbWU7XG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrKHBpbmdlZExhbmVzKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDI7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrKHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9ICExO1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpICYmIHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gZ2V0TmV4dExhbmVzKFxuICAgICAgICByb290LFxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCA6IDBcbiAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDApIHJldHVybiBudWxsO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwLFxuICAgICAgICBkaWRUaW1lb3V0XG4gICAgICApO1xuICAgICAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3ckMSgpKTtcbiAgICAgIHJldHVybiBudWxsICE9IHJvb3QuY2FsbGJhY2tOb2RlICYmXG4gICAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZVxuICAgICAgICA/IHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzay5iaW5kKG51bGwsIHJvb3QpXG4gICAgICAgIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIGxhbmVzKSB7XG4gICAgICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpKSByZXR1cm4gbnVsbDtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExO1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gICAgICBjYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSAmJlxuICAgICAgICBudWxsICE9PSBjYWxsYmFja05vZGUgJiZcbiAgICAgICAgY2FuY2VsQ2FsbGJhY2skMShjYWxsYmFja05vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICYmXG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgc3VwcG9ydHNNaWNyb3Rhc2tzXG4gICAgICAgID8gc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0XG4gICAgICAgICAgICAgID8gc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYilcbiAgICAgICAgICAgICAgOiBjYigpO1xuICAgICAgICAgIH0pXG4gICAgICAgIDogc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpIHtcbiAgICAgIDAgPT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgICAgIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkpO1xuICAgICAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKSB7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycykge1xuICAgICAgICB2YXIgZW50YW5nbGVkTGlzdGVuZXJzID0gKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBbXSk7XG4gICAgICAgIGN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgPSAwO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSB7XG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICBlbnRhbmdsZWRMaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50Kys7XG4gICAgICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKCkge1xuICAgICAgaWYgKFxuICAgICAgICAwID09PSAtLWN1cnJlbnRFbnRhbmdsZWRQZW5kaW5nQ291bnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVyc1xuICAgICAgKSB7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAmJlxuICAgICAgICAgIChjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIik7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSAwO1xuICAgICAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykgKDAsIGxpc3RlbmVyc1tpXSkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hhaW5UaGVuYWJsZVZhbHVlKHRoZW5hYmxlLCByZXN1bHQpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUgPSB7XG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIHRoZW5hYmxlLnRoZW4oXG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnZhbHVlID0gcmVzdWx0O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSAoMCwgbGlzdGVuZXJzW2ldKShyZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICB0aGVuYWJsZVdpdGhPdmVycmlkZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgZm9yIChlcnJvciA9IDA7IGVycm9yIDwgbGlzdGVuZXJzLmxlbmd0aDsgZXJyb3IrKylcbiAgICAgICAgICAgICgwLCBsaXN0ZW5lcnNbZXJyb3JdKSh2b2lkIDApO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoZW5hYmxlV2l0aE92ZXJyaWRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0aWFsaXplVXBkYXRlUXVldWUoZmliZXIpIHtcbiAgICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG51bGwsXG4gICAgICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB7XG4gICAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50LmJhc2VTdGF0ZSxcbiAgICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50Lmxhc3RCYXNlVXBkYXRlLFxuICAgICAgICAgIHNoYXJlZDogY3VycmVudC5zaGFyZWQsXG4gICAgICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFuZTogbGFuZSxcbiAgICAgICAgdGFnOiBVcGRhdGVTdGF0ZSxcbiAgICAgICAgcGF5bG9hZDogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSkge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gdXBkYXRlUXVldWUpIHJldHVybiBudWxsO1xuICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gdXBkYXRlUXVldWUgJiZcbiAgICAgICAgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGVcbiAgICAgICkge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsIHdpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhIGNhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzXCIsXG4gICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChjb21wb25lbnROYW1lID0gdXBkYXRlUXVldWUucGVuZGluZyksXG4gICAgICAgICAgbnVsbCA9PT0gY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBjb21wb25lbnROYW1lLm5leHQpLFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZS5uZXh0ID0gdXBkYXRlKSksXG4gICAgICAgICAgKHVwZGF0ZVF1ZXVlLnBlbmRpbmcgPSB1cGRhdGUpLFxuICAgICAgICAgICh1cGRhdGUgPSBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKSksXG4gICAgICAgICAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIG51bGwsIGxhbmUpLFxuICAgICAgICAgIHVwZGF0ZVxuICAgICAgICApO1xuICAgICAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCB1cGRhdGVRdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICAgIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgIGlmIChudWxsICE9PSBmaWJlciAmJiAoKGZpYmVyID0gZmliZXIuc2hhcmVkKSwgMCAhPT0gKGxhbmUgJiA0MTk0MTc2KSkpIHtcbiAgICAgICAgdmFyIHF1ZXVlTGFuZXMgPSBmaWJlci5sYW5lcztcbiAgICAgICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICAgICAgbGFuZSB8PSBxdWV1ZUxhbmVzO1xuICAgICAgICBmaWJlci5sYW5lcyA9IGxhbmU7XG4gICAgICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gICAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSxcbiAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSwgcXVldWUgPT09IGN1cnJlbnQpXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbCxcbiAgICAgICAgICBuZXdMYXN0ID0gbnVsbDtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBxdWV1ZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgICAgbGFuZTogcXVldWUubGFuZSxcbiAgICAgICAgICAgICAgdGFnOiBxdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZSlcbiAgICAgICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUubmV4dDtcbiAgICAgICAgICB9IHdoaWxlIChudWxsICE9PSBxdWV1ZSk7XG4gICAgICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgICAgICAgICA6IChuZXdMYXN0ID0gbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIHF1ZXVlID0ge1xuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICAgICAgfTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgICAgID8gKHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5uZXh0ID0gY2FwdHVyZWRVcGRhdGUpO1xuICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgICAgIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgaWYgKG51bGwgIT09IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlKSB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBwcm9wcyxcbiAgICAgIGluc3RhbmNlJGpzY29tcCQwLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgICAgICBmaXJzdFBlbmRpbmdVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgICAgICA/IChmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgOiAobGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSk7XG4gICAgICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgKHBlbmRpbmdRdWV1ZSA9IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUpLFxuICAgICAgICAgIHBlbmRpbmdRdWV1ZSAhPT0gbGFzdEJhc2VVcGRhdGUgJiZcbiAgICAgICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGUpXG4gICAgICAgICAgICAgIDogKHBlbmRpbmdRdWV1ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlKSxcbiAgICAgICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gZmlyc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICAgICAgbGFzdEJhc2VVcGRhdGUgPSAwO1xuICAgICAgICBjdXJyZW50ID0gZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgdXBkYXRlTGFuZSA9IHBlbmRpbmdRdWV1ZS5sYW5lICYgLTUzNjg3MDkxMyxcbiAgICAgICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGVcbiAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICAgICA6IChyZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQubmV4dCA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgICAgIHRhZzogcGVuZGluZ1F1ZXVlLnRhZyxcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgIHVwZGF0ZUxhbmUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UkanNjb21wJDA7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFydGlhbFN0YXRlLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcGFydGlhbFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBhcnRpYWxTdGF0ZS5jYWxsKFxuICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlTGFuZS5tb2RlICYgOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHBhcnRpYWxTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAgICAgICAgICAgICAgdXBkYXRlTGFuZS5mbGFncyA9ICh1cGRhdGVMYW5lLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgICAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gcGFydGlhbFN0YXRlLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV4dFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSAhMDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFN0YXRlID0gbmV4dFN0YXRlLmNhbGwoXG4gICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVMYW5lLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHBhcnRpYWxTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBwYXJ0aWFsU3RhdGUgfHwgdm9pZCAwID09PSBwYXJ0aWFsU3RhdGUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IGFzc2lnbih7fSwgbmV3U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICAgICAgICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVMYW5lID0gcGVuZGluZ1F1ZXVlLmNhbGxiYWNrO1xuICAgICAgICAgICAgbnVsbCAhPT0gdXBkYXRlTGFuZSAmJlxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICAgICAgaXNIaWRkZW5VcGRhdGUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpLFxuICAgICAgICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSBxdWV1ZS5jYWxsYmFja3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgICAgID8gKHF1ZXVlLmNhbGxiYWNrcyA9IFt1cGRhdGVMYW5lXSlcbiAgICAgICAgICAgICAgICA6IGlzSGlkZGVuVXBkYXRlLnB1c2godXBkYXRlTGFuZSkpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0ge1xuICAgICAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IHBlbmRpbmdRdWV1ZS5wYXlsb2FkLFxuICAgICAgICAgICAgICBjYWxsYmFjazogcGVuZGluZ1F1ZXVlLmNhbGxiYWNrLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAgICAgKGxhc3RQZW5kaW5nVXBkYXRlID0gbmV3U3RhdGUpKVxuICAgICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBjdXJyZW50Lm5leHQgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgICAgICBwZW5kaW5nUXVldWUgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcGVuZGluZ1F1ZXVlKVxuICAgICAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgICAgICAocGVuZGluZ1F1ZXVlID0gaXNIaWRkZW5VcGRhdGUubmV4dCksXG4gICAgICAgICAgICAgICAgKGlzSGlkZGVuVXBkYXRlLm5leHQgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAgICAgKHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgICAgICBudWxsID09PSBmaXJzdEJhc2VVcGRhdGUgJiYgKHF1ZXVlLnNoYXJlZC5sYW5lcyA9IDApO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiBcIiArXG4gICAgICAgICAgICBjYWxsYmFja1xuICAgICAgICApO1xuICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgaGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcbiAgICAgIGlmIChudWxsICE9PSBoaWRkZW5DYWxsYmFja3MpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2tzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA8IGNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgdXBkYXRlUXVldWUrK1xuICAgICAgICApXG4gICAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrc1t1cGRhdGVRdWV1ZV0sIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICAgICAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSByZXR1cm4gITA7XG4gICAgICBpZiAoXG4gICAgICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpBIHx8XG4gICAgICAgIG51bGwgPT09IG9iakEgfHxcbiAgICAgICAgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG9iakIgfHxcbiAgICAgICAgbnVsbCA9PT0gb2JqQlxuICAgICAgKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKSxcbiAgICAgICAga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgICAgIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuICExO1xuICAgICAgZm9yIChrZXlzQiA9IDA7IGtleXNCIDwga2V5c0EubGVuZ3RoOyBrZXlzQisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5c0Fba2V5c0JdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwgY3VycmVudEtleSkgfHxcbiAgICAgICAgICAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSlcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7IGRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZTogITEsIHRoZW5hYmxlczogW10gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSB7XG4gICAgICB0aGVuYWJsZSA9IHRoZW5hYmxlLnN0YXR1cztcbiAgICAgIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZSB8fCBcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wJDEoKSB7fVxuICAgIGZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICAgICAgbnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UgPSAhMCk7XG4gICAgICB2YXIgdHJhY2tlZFRoZW5hYmxlcyA9IHRoZW5hYmxlU3RhdGUudGhlbmFibGVzO1xuICAgICAgaW5kZXggPSB0cmFja2VkVGhlbmFibGVzW2luZGV4XTtcbiAgICAgIHZvaWQgMCA9PT0gaW5kZXhcbiAgICAgICAgPyB0cmFja2VkVGhlbmFibGVzLnB1c2godGhlbmFibGUpXG4gICAgICAgIDogaW5kZXggIT09IHRoZW5hYmxlICYmXG4gICAgICAgICAgKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIHx8XG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBIGNvbXBvbmVudCB3YXMgc3VzcGVuZGVkIGJ5IGFuIHVuY2FjaGVkIHByb21pc2UuIENyZWF0aW5nIHByb21pc2VzIGluc2lkZSBhIENsaWVudCBDb21wb25lbnQgb3IgaG9vayBpcyBub3QgeWV0IHN1cHBvcnRlZCwgZXhjZXB0IHZpYSBhIFN1c3BlbnNlLWNvbXBhdGlibGUgbGlicmFyeSBvciBmcmFtZXdvcmsuXCJcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpLFxuICAgICAgICAgICh0aGVuYWJsZSA9IGluZGV4KSk7XG4gICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICBjYXNlIFwiZnVsZmlsbGVkXCI6XG4gICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2godGhlbmFibGVTdGF0ZSksXG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlKVxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAgICAgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlID0gdGhlbmFibGU7XG4gICAgICAgICAgICB0aGVuYWJsZVN0YXRlLnN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgICAgICBmdW5jdGlvbiAoZnVsZmlsbGVkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAoKHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb24pLFxuICAgICAgICAgICAgICAgIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHRoZW5hYmxlU3RhdGUpLFxuICAgICAgICAgICAgICAgIHRoZW5hYmxlU3RhdGUpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMDtcbiAgICAgICAgICB0aHJvdyBTdXNwZW5zZUV4Y2VwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gICAgICBpZiAobnVsbCA9PT0gc3VzcGVuZGVkVGhlbmFibGUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gITE7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkUmVhc29uKSB7XG4gICAgICBpZiAocmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkhvb2tzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBhbiBhc3luYyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2hEZWJ1Z0luZm8oZGVidWdJbmZvKSB7XG4gICAgICB2YXIgcHJldmlvdXNEZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgbnVsbCAhPSBkZWJ1Z0luZm8gJiZcbiAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPVxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzRGVidWdJbmZvXG4gICAgICAgICAgICA/IGRlYnVnSW5mb1xuICAgICAgICAgICAgOiBwcmV2aW91c0RlYnVnSW5mby5jb25jYXQoZGVidWdJbmZvKSk7XG4gICAgICByZXR1cm4gcHJldmlvdXNEZWJ1Z0luZm87XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBmaWJlciwgcmV0dXJuRmliZXIpIHtcbiAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LnByb3BzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoXCJjaGlsZHJlblwiICE9PSBrZXkgJiYgXCJrZXlcIiAhPT0ga2V5KSB7XG4gICAgICAgICAgbnVsbCA9PT0gZmliZXIgJiZcbiAgICAgICAgICAgICgoZmliZXIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIDApKSxcbiAgICAgICAgICAgIChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAoZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yZWRLZXkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JlZEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyJDE7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxICs9IDE7XG4gICAgICBudWxsID09PSB0aGVuYWJsZVN0YXRlJDEgJiYgKHRoZW5hYmxlU3RhdGUkMSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSk7XG4gICAgICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSQxLCB0aGVuYWJsZSwgaW5kZXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VSZWYod29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnByb3BzLnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZiA9IHZvaWQgMCAhPT0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbi0gTXVsdGlwbGUgY29waWVzIG9mIHRoZSBcInJlYWN0XCIgcGFja2FnZSBpcyB1c2VkLlxcbi0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJ1xuICAgICAgICApO1xuICAgICAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgICAgKFwiW29iamVjdCBPYmplY3RdXCIgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgIDogcmV0dXJuRmliZXIpICtcbiAgICAgICAgICBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSB8fFxuICAgICAgICAoKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9XG4gICAgICAgICAgaW52YWxpZENoaWxkLmRpc3BsYXlOYW1lIHx8IGludmFsaWRDaGlsZC5uYW1lIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAzID09PSByZXR1cm5GaWJlci50YWdcbiAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGRcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmIHlvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuIE9yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbiAgPCVzPnslc308LyVzPlwiLFxuICAgICAgICAgICAgICBpbnZhbGlkQ2hpbGQsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgICAgICAgaW52YWxpZENoaWxkLFxuICAgICAgICAgICAgICBwYXJlbnROYW1lXG4gICAgICAgICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdIHx8XG4gICAgICAgICgob3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSA9ICEwKSxcbiAgICAgICAgKGludmFsaWRDaGlsZCA9IFN0cmluZyhpbnZhbGlkQ2hpbGQpKSxcbiAgICAgICAgMyA9PT0gcmV0dXJuRmliZXIudGFnXG4gICAgICAgICAgPyBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlN5bWJvbHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLlxcbiAgcm9vdC5yZW5kZXIoJXMpXCIsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4gIDwlcz4lczwvJXM+XCIsXG4gICAgICAgICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgICAgICAgIGludmFsaWRDaGlsZCxcbiAgICAgICAgICAgICAgcGFyZW50TmFtZVxuICAgICAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICAgICAgbnVsbCA9PT0gZGVsZXRpb25zXG4gICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2NoaWxkVG9EZWxldGVdKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICAgIDogZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZm9yICh2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZC5rZXlcbiAgICAgICAgICAgID8gZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQua2V5LCBjdXJyZW50Rmlyc3RDaGlsZClcbiAgICAgICAgICAgIDogZXhpc3RpbmdDaGlsZHJlbi5zZXQoY3VycmVudEZpcnN0Q2hpbGQuaW5kZXgsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgICAgZmliZXIgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICAgICAgZmliZXIuaW5kZXggPSAwO1xuICAgICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgICAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgICAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpXG4gICAgICAgICAgcmV0dXJuIChuZXdGaWJlci5mbGFncyB8PSAxMDQ4NTc2KSwgbGFzdFBsYWNlZEluZGV4O1xuICAgICAgICBuZXdJbmRleCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IG5ld0luZGV4KVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobmV3SW5kZXggPSBuZXdJbmRleC5pbmRleCksXG4gICAgICAgICAgICBuZXdJbmRleCA8IGxhc3RQbGFjZWRJbmRleFxuICAgICAgICAgICAgICA/ICgobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpLCBsYXN0UGxhY2VkSW5kZXgpXG4gICAgICAgICAgICAgIDogbmV3SW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICBuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCk7XG4gICAgICAgIHJldHVybiBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgNiAhPT0gY3VycmVudC50YWcpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGN1cnJlbnQsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIChjdXJyZW50LmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fFxuICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpIHx8XG4gICAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVsZW1lbnRUeXBlICYmXG4gICAgICAgICAgICAgIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgY2FsbExhenlJbml0SW5ERVYoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcykpLFxuICAgICAgICAgICAgY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpLFxuICAgICAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKGN1cnJlbnQuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgNCAhPT0gY3VycmVudC50YWcgfHxcbiAgICAgICAgICBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fFxuICAgICAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGN1cnJlbnQuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm87XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDcgIT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAoY3VycmVudC5fZGVidWdPd25lciA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgIChjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICBjdXJyZW50Ll9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICAgICAgXCJcIiArIG5ld0NoaWxkLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAobmV3Q2hpbGQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAobmV3Q2hpbGQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwoXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBfcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZC50aGVuKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKF9wcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIHVud3JhcFRoZW5hYmxlKG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnREZWJ1Z0luZm8gPSBfcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAgICAgdmFyIGtleSA9IG51bGwgIT09IG9sZEZpYmVyID8gb2xkRmliZXIua2V5IDogbnVsbDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/ICgoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGQua2V5ID09PSBrZXlcbiAgICAgICAgICAgICAgICA/IHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoa2V5ID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgICAgKG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGtleSksXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGtleSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSB1cGRhdGVGcmFnbWVudChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjdXJyZW50RGVidWdJbmZvID0ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0ga2V5KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmXG4gICAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG5ld0lkeCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIFwiXCIgKyBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChuZXdJZHggPVxuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgKSB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgdmFyIF9wcmV2RGVidWdJbmZvNyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIG5ld0NoaWxkID0gY2FsbExhenlJbml0SW5ERVYobmV3Q2hpbGQpO1xuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IF9wcmV2RGVidWdJbmZvNztcbiAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKG5ld0lkeCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHVwZGF0ZUZyYWdtZW50KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IGV4aXN0aW5nQ2hpbGRyZW4pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChfcHJldkRlYnVnSW5mbzcgPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gX3ByZXZEZWJ1Z0luZm83KSxcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIG5ld0lkeCxcbiAgICAgICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCwga25vd25LZXlzKSB7XG4gICAgICAgIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2YgY2hpbGQgfHwgbnVsbCA9PT0gY2hpbGQpIHJldHVybiBrbm93bktleXM7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBrZXkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGtub3duS2V5cykge1xuICAgICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYod29ya0luUHJvZ3Jlc3MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIkVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSBhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSBkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIFxcdTIwMTQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCBjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIixcbiAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAoY2hpbGQgPSBjYWxsTGF6eUluaXRJbkRFVihjaGlsZCkpLFxuICAgICAgICAgICAgICB3YXJuT25JbnZhbGlkS2V5KHJldHVybkZpYmVyLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgICAgIGxhbmVzXG4gICAgICApIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICBuZXdJZHgrK1xuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5ld0ZpYmVyKSB7XG4gICAgICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgIG5ld0ZpYmVyLFxuICAgICAgICAgICAgbmV3Q2hpbGRyZW5bbmV3SWR4XSxcbiAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICk7XG4gICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcilcbiAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpLFxuICAgICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBvbGRGaWJlcikge1xuICAgICAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgIG5ld0lkeCsrXG4gICAgICAgIClcbiAgICAgICAgICAobmV4dE9sZEZpYmVyID0gdXBkYXRlRnJvbU1hcChcbiAgICAgICAgICAgIG9sZEZpYmVyLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgICAgICAoKGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoXG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuW25ld0lkeF0sXG4gICAgICAgICAgICAgICAga25vd25LZXlzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dE9sZEZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAgIG9sZEZpYmVyLmRlbGV0ZShcbiAgICAgICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChcbiAgICAgICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmV3SWR4XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5leHRPbGRGaWJlcilcbiAgICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG5leHRPbGRGaWJlcikpO1xuICAgICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZHJlbixcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIik7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG51bGwsXG4gICAgICAgICAgICBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIgPSBudWxsLFxuICAgICAgICAgICAga25vd25LZXlzID0gbnVsbCxcbiAgICAgICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiYgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApIHtcbiAgICAgICAgICBvbGRGaWJlci5pbmRleCA+IG5ld0lkeFxuICAgICAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuICAgICAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdGaWJlcixcbiAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICApO1xuICAgICAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKVxuICAgICAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IG9sZEZpYmVyICYmXG4gICAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgICAgIHN0ZXAudmFsdWUsXG4gICAgICAgICAgICAgICAgICBrbm93bktleXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgICAocHJldmlvdXNOZXdGaWJlciA9IG9sZEZpYmVyKSk7XG4gICAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgb2xkRmliZXIgPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7XG4gICAgICAgICAgIXN0ZXAuZG9uZTtcbiAgICAgICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgbmV3SWR4LFxuICAgICAgICAgICAgc3RlcC52YWx1ZSxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIgJiZcbiAgICAgICAgICAgICAgKChrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIG5leHRPbGRGaWJlcixcbiAgICAgICAgICAgICAgICBzdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgIGtub3duS2V5c1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgICAgICBudWxsID09PSBuZXh0T2xkRmliZXIua2V5ID8gbmV3SWR4IDogbmV4dE9sZEZpYmVyLmtleVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgbmV4dE9sZEZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV4dE9sZEZpYmVyKSxcbiAgICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBuZXh0T2xkRmliZXIpKTtcbiAgICAgICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgICAgIG9sZEZpYmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgbGFuZXNcbiAgICAgICkge1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICBudWxsICE9PSBuZXdDaGlsZCAmJlxuICAgICAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgICAgICBudWxsID09PSBuZXdDaGlsZC5rZXkgJiZcbiAgICAgICAgICAodmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBudWxsLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgcHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgPSBuZXdDaGlsZC5rZXk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXdDaGlsZC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5lcy5fZGVidWdPd25lciA9IG5ld0NoaWxkLl9vd25lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKG5ld0NoaWxkLCBsYW5lcywgcmV0dXJuRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkXG4gICAgICAgICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBrZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsTGF6eUluaXRJbkRFVihrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZVJlZihsYW5lcywgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z093bmVyID0gbmV3Q2hpbGQuX293bmVyO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLl9kZWJ1Z0luZm8gPSBjdXJyZW50RGVidWdJbmZvO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAobGFuZXMuX2RlYnVnSW5mbyA9IGN1cnJlbnREZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIGxhbmVzLCByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm87XG4gICAgICAgICAgICAgIHJldHVybiByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBwcmV2RGVidWdJbmZvID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gcHJldkRlYnVnSW5mby5rZXk7XG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkLmtleSA9PT0gbmV3Q2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICA0ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWcgJiZcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8uY2hpbGRyZW4gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbmVzID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBsYW5lcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAgIChuZXdDaGlsZCA9IGNhbGxMYXp5SW5pdEluREVWKG5ld0NoaWxkKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAocHJldkRlYnVnSW5mbyA9IHB1c2hEZWJ1Z0luZm8obmV3Q2hpbGQuX2RlYnVnSW5mbykpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoY3VycmVudERlYnVnSW5mbyA9IHByZXZEZWJ1Z0luZm8pLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIHByZXZEZWJ1Z0luZm8gPSBwdXNoRGVidWdJbmZvKG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Yga2V5KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IGtleS5jYWxsKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZHJlbiA9PT0gbmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIDAgIT09IHJldHVybkZpYmVyLnRhZyB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIiAhPT1cbiAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSB8fFxuICAgICAgICAgICAgICAgIFwiW29iamVjdCBHZW5lcmF0b3JdXCIgIT09XG4gICAgICAgICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGRyZW4pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIHx8XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlVzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgdW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gWW91IG1heSBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggYEFycmF5LmZyb20oKWAgb3IgdGhlIGBbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiBJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9ICEwKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBuZXdDaGlsZC5lbnRyaWVzICE9PSBrZXkgfHxcbiAgICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dE1hcHMgPSAhMCkpO1xuICAgICAgICAgICAgcmV0dXJuRmliZXIgPSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0NoaWxkcmVuLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybkZpYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gcHVzaERlYnVnSW5mbyhuZXdDaGlsZC5fZGVidWdJbmZvKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICB1bndyYXBUaGVuYWJsZShuZXdDaGlsZCksXG4gICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChjdXJyZW50RGVidWdJbmZvID0gcHJldkRlYnVnSW5mbyksXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKVxuICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChwcmV2RGVidWdJbmZvID0gXCJcIiArIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkICYmIDYgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZ1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKGxhbmVzID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHByZXZEZWJ1Z0luZm8pKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMgPSBjcmVhdGVGaWJlckZyb21UZXh0KFxuICAgICAgICAgICAgICAgICAgcHJldkRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKGxhbmVzLl9kZWJ1Z093bmVyID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChsYW5lcy5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKSxcbiAgICAgICAgICAgIHBsYWNlU2luZ2xlQ2hpbGQocmV0dXJuRmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiZcbiAgICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgICAgIHZhciBwcmV2RGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbztcbiAgICAgICAgY3VycmVudERlYnVnSW5mbyA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgICAgICAgdmFyIGZpcnN0Q2hpbGRGaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBpZiAoeCA9PT0gU3VzcGVuc2VFeGNlcHRpb24pIHRocm93IHg7XG4gICAgICAgICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoMjksIHgsIG51bGwsIHJldHVybkZpYmVyLm1vZGUpO1xuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgdmFyIGRlYnVnSW5mbyA9IChmaWJlci5fZGVidWdJbmZvID0gY3VycmVudERlYnVnSW5mbyk7XG4gICAgICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICBpZiAobnVsbCAhPSBkZWJ1Z0luZm8pXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IDAgPD0gaTsgaS0tKVxuICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRlYnVnSW5mb1tpXS5zdGFjaykge1xuICAgICAgICAgICAgICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZGVidWdJbmZvW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGN1cnJlbnREZWJ1Z0luZm8gPSBwcmV2RGVidWdJbmZvO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICAgICAgdmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGVudGFuZ2xlZFJlbmRlckxhbmVzO1xuICAgICAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICAgICAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyB8IGNvbnRleHQuYmFzZUxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZW50YW5nbGVkUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgICAgIHB1c2goXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsXG4gICAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgZmliZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICBwb3AoY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgICAgIHB1c2goXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlciwgaGFuZGxlcik7XG4gICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5ICYmXG4gICAgICAgIChudWxsID09PSBjdXJyZW50IHx8IG51bGwgIT09IGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudFxuICAgICAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgICAgIDogbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmIChzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gICAgICBpZiAoMjIgPT09IGZpYmVyLnRhZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBmaWJlciksXG4gICAgICAgICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKSxcbiAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5KVxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgIChzaGVsbEJvdW5kYXJ5ID0gZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKGZpYmVyKSB7XG4gICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgZmliZXIpO1xuICAgICAgcHVzaChcbiAgICAgICAgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsXG4gICAgICAgIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQsXG4gICAgICAgIGZpYmVyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgICAgIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgICAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgICAgIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICBpZiAoMTMgPT09IG5vZGUudGFnKSB7XG4gICAgICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IHN0YXRlICYmXG4gICAgICAgICAgICAoKHN0YXRlID0gc3RhdGUuZGVoeWRyYXRlZCksXG4gICAgICAgICAgICBudWxsID09PSBzdGF0ZSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN0YXRlKSB8fFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdGF0ZSkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgMTkgPT09IG5vZGUudGFnICYmXG4gICAgICAgICAgdm9pZCAwICE9PSBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXJcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKDAgIT09IChub2RlLmZsYWdzICYgMTI4KSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gcm93KSBicmVhaztcbiAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHJldHVybiBudWxsO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gICAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcbiAgICAgIG51bGwgPT09IGhvb2tUeXBlc0RldlxuICAgICAgICA/IChob29rVHlwZXNEZXYgPSBbaG9va05hbWVdKVxuICAgICAgICA6IGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICAgICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IGhvb2tUeXBlc0RldiAmJlxuICAgICAgICAoaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKyxcbiAgICAgICAgaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKFxuICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDFcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpICYmXG4gICAgICAgICAgKGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSksXG4gICAgICAgICAgbnVsbCAhPT0gaG9va1R5cGVzRGV2KVxuICAgICAgICApIHtcbiAgICAgICAgICBmb3IgKHZhciB0YWJsZSA9IFwiXCIsIGkgPSAwOyBpIDw9IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXSxcbiAgICAgICAgICAgICAgbmV3SG9va05hbWUgPVxuICAgICAgICAgICAgICAgIGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gaG9va05hbWUgOiBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG9sZEhvb2tOYW1lID0gaSArIDEgKyBcIi4gXCIgKyBvbGRIb29rTmFtZTtcbiAgICAgICAgICAgICAgMzAgPiBvbGRIb29rTmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgb2xkSG9va05hbWUgKz0gXCIgXCI7XG4gICAgICAgICAgICBvbGRIb29rTmFtZSArPSBuZXdIb29rTmFtZSArIFwiXFxuXCI7XG4gICAgICAgICAgICB0YWJsZSArPSBvbGRIb29rTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuIFRoaXMgd2lsbCBsZWFkIHRvIGJ1Z3MgYW5kIGVycm9ycyBpZiBub3QgZml4ZWQuIEZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbiAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJXMgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG5cIixcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUsXG4gICAgICAgICAgICB0YWJsZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICAgICAgdm9pZCAwID09PSBkZXBzIHx8XG4gICAgICAgIG51bGwgPT09IGRlcHMgfHxcbiAgICAgICAgaXNBcnJheUltcGwoZGVwcykgfHxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIiVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuIHNwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuXCIsXG4gICAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYsXG4gICAgICAgICAgdHlwZW9mIGRlcHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG4gICAgICBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpIHx8XG4gICAgICAgIChkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVhY3RET00udXNlRm9ybVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVhY3QudXNlQWN0aW9uU3RhdGUuIFBsZWFzZSB1cGRhdGUgJXMgdG8gdXNlIFJlYWN0LnVzZUFjdGlvblN0YXRlLlwiLFxuICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICAgICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSByZXR1cm4gITE7XG4gICAgICBpZiAobnVsbCA9PT0gcHJldkRlcHMpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXCIsXG4gICAgICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldlxuICAgICAgICAgICksXG4gICAgICAgICAgITFcbiAgICAgICAgKTtcbiAgICAgIG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSBvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcblByZXZpb3VzOiAlc1xcbkluY29taW5nOiAlc1wiLFxuICAgICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2LFxuICAgICAgICAgIFwiW1wiICsgcHJldkRlcHMuam9pbihcIiwgXCIpICsgXCJdXCIsXG4gICAgICAgICAgXCJbXCIgKyBuZXh0RGVwcy5qb2luKFwiLCBcIikgKyBcIl1cIlxuICAgICAgICApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHJldHVybiAhMTtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICBuZXh0UmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgaG9va1R5cGVzRGV2ID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgaWYgKFxuICAgICAgICBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiA9PT1cbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSB8fFxuICAgICAgICBcIltvYmplY3QgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbl1cIiA9PT1cbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KVxuICAgICAgKVxuICAgICAgICAobmV4dFJlbmRlckxhbmVzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICAgICkpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50LmhhcyhuZXh0UmVuZGVyTGFuZXMpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuYWRkKG5leHRSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImFzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5IFNlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci5cIlxuICAgICAgICAgICAgKSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVlxuICAgICAgICAgIDogbnVsbCAhPT0gaG9va1R5cGVzRGV2XG4gICAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVZcbiAgICAgICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBuZXh0UmVuZGVyTGFuZXMgPVxuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpICE9PSBOb01vZGU7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITE7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiZcbiAgICAgICAgKGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIHNlY29uZEFyZ1xuICAgICAgICApKTtcbiAgICAgIGlmIChuZXh0UmVuZGVyTGFuZXMpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgc2Vjb25kQXJnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGhvb2tUeXBlc0RldjtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llc1xuICAgICAgICA/IG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgICAgICBmaXJzdENvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiB0aGVuYWJsZVN0YXRlXG4gICAgICAgICAgfSlcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzLl9kZWJ1Z1RoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZVN0YXRlKTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPVxuICAgICAgICBudWxsICE9PSBjdXJyZW50SG9vayAmJiBudWxsICE9PSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgcmVuZGVyTGFuZXMgPSAwO1xuICAgICAgaG9va1R5cGVzRGV2ID1cbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICBjdXJyZW50SG9vayA9XG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPVxuICAgICAgICAgIG51bGw7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAoY3VycmVudC5mbGFncyAmIDMxNDU3MjgwKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzE0NTcyODApICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSBub3RpZnkgdGhlIFJlYWN0IHRlYW0uXCJcbiAgICAgICAgKTtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgICAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCJcbiAgICAgICAgKTtcbiAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fFxuICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSk7XG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFVlxuICAgICAgICA/ICgobmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSAhMSksIChjdXJyZW50ID0gITApKVxuICAgICAgICA6IChjdXJyZW50ID0gITEpO1xuICAgICAgY3VycmVudCAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMod29ya0luUHJvZ3Jlc3MpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoLmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiYHVzZWAgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIHRyeS9jYXRjaCBibG9jay4gVGhpcyBpcyBub3QgYWxsb3dlZCBhbmQgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gVG8gaGFuZGxlIGVycm9ycyB0cmlnZ2VyZWQgYnkgYHVzZWAsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYSBlcnJvciBib3VuZGFyeS5cIlxuICAgICAgICAgICkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzICYmICh0aGVuYWJsZVN0YXRlID0gbnVsbCk7XG4gICAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcbiAgICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSAhMTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGNoaWxkcmVuLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIGNoaWxkcmVuLmV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgY2hpbGRyZW4uc3RvcmVzID0gbnVsbDtcbiAgICAgICAgICBudWxsICE9IGNoaWxkcmVuLm1lbW9DYWNoZSAmJiAoY2hpbGRyZW4ubWVtb0NhY2hlLmluZGV4ID0gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcbiAgICAgICAgY2hpbGRyZW4gPSBjYWxsQ29tcG9uZW50SW5ERVYoQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgsXG4gICAgICAgIG1heWJlVGhlbmFibGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICBtYXliZVRoZW5hYmxlID1cbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuXG4gICAgICAgICAgPyB1c2VUaGVuYWJsZShtYXliZVRoZW5hYmxlKVxuICAgICAgICAgIDogbWF5YmVUaGVuYWJsZTtcbiAgICAgIGRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gICAgICAobnVsbCAhPT0gY3VycmVudEhvb2sgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbCkgIT09XG4gICAgICAgIGRpc3BhdGNoZXIgJiYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMTAyNCk7XG4gICAgICByZXR1cm4gbWF5YmVUaGVuYWJsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gICAgICB2YXIgZGlkUmVuZGVySWRIb29rID0gMCAhPT0gbG9jYWxJZENvdW50ZXI7XG4gICAgICBsb2NhbElkQ291bnRlciA9IDA7XG4gICAgICByZXR1cm4gZGlkUmVuZGVySWRIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMTYpICE9PSBOb01vZGVcbiAgICAgICAgICA/IHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTIwMTMyODY0NVxuICAgICAgICAgIDogd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAtMjA1MztcbiAgICAgIGN1cnJlbnQubGFuZXMgJj0gfmxhbmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldEhvb2tzT25VbndpbmQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzO1xuXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnF1ZXVlO1xuICAgICAgICAgIG51bGwgIT09IHF1ZXVlICYmIChxdWV1ZS5wZW5kaW5nID0gbnVsbCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMTtcbiAgICAgIH1cbiAgICAgIHJlbmRlckxhbmVzID0gMDtcbiAgICAgIGhvb2tUeXBlc0RldiA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgIGN1cnJlbnRIb29rID1cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSAhMTtcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAgICAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgdmFyIGhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICAgICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgICAgICBxdWV1ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rKVxuICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2spO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRIb29rKSB7XG4gICAgICAgIHZhciBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICAgICAgbmV4dEN1cnJlbnRIb29rID1cbiAgICAgICAgICBudWxsICE9PSBuZXh0Q3VycmVudEhvb2sgPyBuZXh0Q3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICB9IGVsc2UgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID1cbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGVcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgICAgaWYgKG51bGwgIT09IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2spXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKSxcbiAgICAgICAgICAoY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2spO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChudWxsID09PSBuZXh0Q3VycmVudEhvb2spIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGUpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgXCJVcGRhdGUgaG9vayBjYWxsZWQgb24gaW5pdGlhbCByZW5kZXIuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgICAgIG5leHRDdXJyZW50SG9vayA9IHtcbiAgICAgICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgICAgID8gKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9XG4gICAgICAgICAgICAgIG5leHRDdXJyZW50SG9vaylcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5leHRDdXJyZW50SG9vayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgICAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciArPSAxO1xuICAgICAgbnVsbCA9PT0gdGhlbmFibGVTdGF0ZSAmJiAodGhlbmFibGVTdGF0ZSA9IGNyZWF0ZVRoZW5hYmxlU3RhdGUoKSk7XG4gICAgICB0aGVuYWJsZSA9IHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG4gICAgICBpbmRleCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gICAgICBudWxsID09PVxuICAgICAgICAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICAgICAgPyBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkgJiZcbiAgICAgICAgKChpbmRleCA9IGluZGV4LmFsdGVybmF0ZSksXG4gICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICAgICAgICBudWxsICE9PSBpbmRleCAmJiBudWxsICE9PSBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVZcbiAgICAgICAgICAgIDogSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWKSk7XG4gICAgICByZXR1cm4gdGhlbmFibGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgICAgIGlmIChudWxsICE9PSB1c2FibGUgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVzYWJsZSkge1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdXNhYmxlLnRoZW4pIHJldHVybiB1c2VUaGVuYWJsZSh1c2FibGUpO1xuICAgICAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6IFwiICsgU3RyaW5nKHVzYWJsZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VNZW1vQ2FjaGUoc2l6ZSkge1xuICAgICAgdmFyIG1lbW9DYWNoZSA9IG51bGwsXG4gICAgICAgIHVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgIT09IHVwZGF0ZVF1ZXVlICYmIChtZW1vQ2FjaGUgPSB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUpO1xuICAgICAgaWYgKG51bGwgPT0gbWVtb0NhY2hlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSBjdXJyZW50Lm1lbW9DYWNoZSksXG4gICAgICAgICAgICBudWxsICE9IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgKG1lbW9DYWNoZSA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdXJyZW50LmRhdGEubWFwKGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaW5kZXg6IDBcbiAgICAgICAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIG51bGwgPT0gbWVtb0NhY2hlICYmIChtZW1vQ2FjaGUgPSB7IGRhdGE6IFtdLCBpbmRleDogMCB9KTtcbiAgICAgIG51bGwgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgICAgICgodXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkpLFxuICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlKSk7XG4gICAgICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF07XG4gICAgICBpZiAodm9pZCAwID09PSB1cGRhdGVRdWV1ZSB8fCBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcylcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB1cGRhdGVRdWV1ZSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF0gPSBBcnJheShzaXplKSxcbiAgICAgICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgICAgIGN1cnJlbnQgPCBzaXplO1xuICAgICAgICAgIGN1cnJlbnQrK1xuICAgICAgICApXG4gICAgICAgICAgdXBkYXRlUXVldWVbY3VycmVudF0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICAgICAgZWxzZVxuICAgICAgICB1cGRhdGVRdWV1ZS5sZW5ndGggIT09IHNpemUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCBhIGNvbnN0YW50IHNpemUgYXJndW1lbnQgZm9yIGVhY2ggaW52b2NhdGlvbiBvZiB1c2VNZW1vQ2FjaGUuIFRoZSBwcmV2aW91cyBjYWNoZSB3YXMgYWxsb2NhdGVkIHdpdGggc2l6ZSAlcyBidXQgc2l6ZSAlcyB3YXMgcmVxdWVzdGVkLlwiLFxuICAgICAgICAgICAgdXBkYXRlUXVldWUubGVuZ3RoLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICAgICk7XG4gICAgICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgICAgIHJldHVybiB1cGRhdGVRdWV1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAodm9pZCAwICE9PSBpbml0KSB7XG4gICAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgICByZWR1Y2VyID0ge1xuICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICBsYW5lczogMCxcbiAgICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcmVkdWNlcjtcbiAgICAgIHJlZHVjZXIgPSByZWR1Y2VyLmRpc3BhdGNoID0gZGlzcGF0Y2hSZWR1Y2VyQWN0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgICk7XG4gICAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcikge1xuICAgICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50SG9vaywgcmVkdWNlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnQsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlLFxuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuICAgICAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgICAgICBpZiAobnVsbCAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICBwZW5kaW5nUXVldWUgPSBob29rLmJhc2VTdGF0ZTtcbiAgICAgIGlmIChudWxsID09PSBiYXNlUXVldWUpIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IChiYXNlRmlyc3QgPSBudWxsKSxcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbCxcbiAgICAgICAgICB1cGRhdGUgPSBjdXJyZW50LFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmUgJiAtNTM2ODcwOTEzO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lXG4gICAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJldmVydExhbmUgPSB1cGRhdGUucmV2ZXJ0TGFuZTtcbiAgICAgICAgICAgIGlmICgwID09PSByZXZlcnRMYW5lKVxuICAgICAgICAgICAgICBudWxsICE9PSBuZXdCYXNlUXVldWVMYXN0ICYmXG4gICAgICAgICAgICAgICAgKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITApO1xuICAgICAgICAgICAgZWxzZSBpZiAoKHJlbmRlckxhbmVzICYgcmV2ZXJ0TGFuZSkgPT09IHJldmVydExhbmUpIHtcbiAgICAgICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgICAgICAgIHJldmVydExhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgICAgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICh1cGRhdGVMYW5lID0ge1xuICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICAgICAgPyAoKG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAgICAgICAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHJldmVydExhbmUpO1xuICAgICAgICAgICAgdXBkYXRlTGFuZSA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViAmJlxuICAgICAgICAgICAgICByZWR1Y2VyKHBlbmRpbmdRdWV1ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICBwZW5kaW5nUXVldWUgPSB1cGRhdGUuaGFzRWFnZXJTdGF0ZVxuICAgICAgICAgICAgICA/IHVwZGF0ZS5lYWdlclN0YXRlXG4gICAgICAgICAgICAgIDogcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKHJldmVydExhbmUgPSB7XG4gICAgICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgICAgICAoYmFzZUZpcnN0ID0gcGVuZGluZ1F1ZXVlKSlcbiAgICAgICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHVwZGF0ZUxhbmUpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHVwZGF0ZUxhbmUpO1xuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChudWxsICE9PSB1cGRhdGUgJiYgdXBkYXRlICE9PSBjdXJyZW50KTtcbiAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgID8gKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhb2JqZWN0SXMocGVuZGluZ1F1ZXVlLCBob29rLm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITApLFxuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gJiZcbiAgICAgICAgICAgICgocmVkdWNlciA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSksIG51bGwgIT09IHJlZHVjZXIpKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgcmVkdWNlcjtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgICAgICBob29rLmJhc2VTdGF0ZSA9IGJhc2VGaXJzdDtcbiAgICAgICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgICAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICAgIH1cbiAgICAgIG51bGwgPT09IGJhc2VRdWV1ZSAmJiAocXVldWUubGFuZXMgPSAwKTtcbiAgICAgIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBxdWV1ZS5kaXNwYXRjaF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICAgICBpZiAobnVsbCA9PT0gcXVldWUpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gWW91IGFyZSBsaWtlbHkgY2FsbGluZyBIb29rcyBjb25kaXRpb25hbGx5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaW52YWxpZC1ob29rLWNhbGwpXCJcbiAgICAgICAgKTtcbiAgICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICAgICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2gsXG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmcsXG4gICAgICAgIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCk7XG4gICAgICAgIGRvXG4gICAgICAgICAgKG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgdXBkYXRlLmFjdGlvbikpLCAodXBkYXRlID0gdXBkYXRlLm5leHQpO1xuICAgICAgICB3aGlsZSAodXBkYXRlICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgICAgICBvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKTtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIG51bGwgPT09IGhvb2suYmFzZVF1ZXVlICYmIChob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIk1pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cIlxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCB8fFxuICAgICAgICAgIG5leHRTbmFwc2hvdCA9PT0gZ2V0U2VydmVyU25hcHNob3QoKSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgfHxcbiAgICAgICAgICAoKGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKSksXG4gICAgICAgICAgb2JqZWN0SXMobmV4dFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkgfHxcbiAgICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlRoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpKTtcbiAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjApIHx8XG4gICAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgICB9XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IHsgdmFsdWU6IG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH07XG4gICAgICBob29rLnF1ZXVlID0gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgICBtb3VudEVmZmVjdChcbiAgICAgICAgc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc3Vic2NyaWJlKSxcbiAgICAgICAgW3N1YnNjcmliZV1cbiAgICAgICk7XG4gICAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgICAgbmV4dFNuYXBzaG90LFxuICAgICAgICAgIGdldFNuYXBzaG90XG4gICAgICAgICksXG4gICAgICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV4dFNuYXBzaG90O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGdldFNuYXBzaG90LFxuICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICApIHtcbiAgICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgaXNIeWRyYXRpbmckanNjb21wJDAgPSBpc0h5ZHJhdGluZztcbiAgICAgIGlmIChpc0h5ZHJhdGluZyRqc2NvbXAkMCkge1xuICAgICAgICBpZiAodm9pZCAwID09PSBnZXRTZXJ2ZXJTbmFwc2hvdClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgKChnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNuYXBzaG90KCkpLCAhZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgICAgb2JqZWN0SXMoZ2V0U2VydmVyU25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSB8fFxuICAgICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSAhMCkpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICAoY2FjaGVkU25hcHNob3QgPSAhb2JqZWN0SXMoXG4gICAgICAgICAgKGN1cnJlbnRIb29rIHx8IGhvb2spLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKSlcbiAgICAgIClcbiAgICAgICAgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90KSwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICBob29rID0gaG9vay5xdWV1ZTtcbiAgICAgIHZhciBjcmVhdGUgPSBzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGhvb2ssIHN1YnNjcmliZSk7XG4gICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgW3N1YnNjcmliZV0pO1xuICAgICAgaWYgKFxuICAgICAgICBob29rLmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fFxuICAgICAgICBjYWNoZWRTbmFwc2hvdCB8fFxuICAgICAgICAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NIb29rICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KVxuICAgICAgKSB7XG4gICAgICAgIGZpYmVyLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgIHB1c2hFZmZlY3QoXG4gICAgICAgICAgSGFzRWZmZWN0IHwgUGFzc2l2ZSxcbiAgICAgICAgICB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBob29rLFxuICAgICAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgICAgICBnZXRTbmFwc2hvdFxuICAgICAgICAgICksXG4gICAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwIHx8XG4gICAgICAgICAgMCAhPT0gKHJlbmRlckxhbmVzICYgNjApIHx8XG4gICAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgICAgIGZpYmVyLmZsYWdzIHw9IDE2Mzg0O1xuICAgICAgZmliZXIgPSB7IGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCwgdmFsdWU6IHJlbmRlcmVkU25hcHNob3QgfTtcbiAgICAgIGdldFNuYXBzaG90ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgPT09IGdldFNuYXBzaG90XG4gICAgICAgID8gKChnZXRTbmFwc2hvdCA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBnZXRTbmFwc2hvdCksXG4gICAgICAgICAgKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pKVxuICAgICAgICA6ICgocmVuZGVyZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90LnN0b3JlcyksXG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyZWRTbmFwc2hvdFxuICAgICAgICAgICAgPyAoZ2V0U25hcHNob3Quc3RvcmVzID0gW2ZpYmVyXSlcbiAgICAgICAgICAgIDogcmVuZGVyZWRTbmFwc2hvdC5wdXNoKGZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgICAgIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gICAgICBpbnN0LmdldFNuYXBzaG90ID0gZ2V0U25hcHNob3Q7XG4gICAgICBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpICYmIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgICAgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gICAgICBpbnN0ID0gaW5zdC52YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBsYXRlc3RHZXRTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gIW9iamVjdElzKGluc3QsIG5leHRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgaG9vay5xdWV1ZSA9IHtcbiAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgbGFuZXM6IDAsXG4gICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBob29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgICAgaW5pdGlhbFN0YXRlID0gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKTtcbiAgICAgIHZhciBxdWV1ZSA9IGluaXRpYWxTdGF0ZS5xdWV1ZSxcbiAgICAgICAgZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAgIHF1ZXVlXG4gICAgICAgICk7XG4gICAgICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGUubWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICB2YXIgcXVldWUgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IG51bGxcbiAgICAgIH07XG4gICAgICBob29rLnF1ZXVlID0gcXVldWU7XG4gICAgICBob29rID0gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUuYmluZChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgICAgITAsXG4gICAgICAgIHF1ZXVlXG4gICAgICApO1xuICAgICAgcXVldWUuZGlzcGF0Y2ggPSBob29rO1xuICAgICAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgaG9va107XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gICAgICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGN1cnJlbnRIb29rLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWR1Y2VyID8gcmVkdWNlciA6IGJhc2ljU3RhdGVSZWR1Y2VyXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudEhvb2spXG4gICAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgICAgIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2sucXVldWUuZGlzcGF0Y2hdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaEFjdGlvblN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICBhY3Rpb25RdWV1ZSxcbiAgICAgIHNldFBlbmRpbmdTdGF0ZSxcbiAgICAgIHNldFN0YXRlLFxuICAgICAgcGF5bG9hZFxuICAgICkge1xuICAgICAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKVxuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgZm9ybSBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgZmliZXIgPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG4gICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICBhY3Rpb246IGZpYmVyLFxuICAgICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgICAgaXNUcmFuc2l0aW9uOiAhMCxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgICAgIHRoZW46IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgYWN0aW9uTm9kZS5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBudWxsICE9PSBSZWFjdFNoYXJlZEludGVybmFscy5UXG4gICAgICAgICAgPyBzZXRQZW5kaW5nU3RhdGUoITApXG4gICAgICAgICAgOiAoYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSAhMSk7XG4gICAgICAgIHNldFN0YXRlKGFjdGlvbk5vZGUpO1xuICAgICAgICBzZXRQZW5kaW5nU3RhdGUgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgICBudWxsID09PSBzZXRQZW5kaW5nU3RhdGVcbiAgICAgICAgICA/ICgoYWN0aW9uTm9kZS5uZXh0ID0gYWN0aW9uUXVldWUucGVuZGluZyA9IGFjdGlvbk5vZGUpLFxuICAgICAgICAgICAgcnVuQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIGFjdGlvbk5vZGUpKVxuICAgICAgICAgIDogKChhY3Rpb25Ob2RlLm5leHQgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCksXG4gICAgICAgICAgICAoYWN0aW9uUXVldWUucGVuZGluZyA9IHNldFBlbmRpbmdTdGF0ZS5uZXh0ID0gYWN0aW9uTm9kZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbm9kZSkge1xuICAgICAgdmFyIGFjdGlvbiA9IG5vZGUuYWN0aW9uLFxuICAgICAgICBwYXlsb2FkID0gbm9kZS5wYXlsb2FkLFxuICAgICAgICBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTtcbiAgICAgIGlmIChub2RlLmlzVHJhbnNpdGlvbikge1xuICAgICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVC5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKSxcbiAgICAgICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICAgICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcmV0dXJuVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICAgIG51bGwgPT09IHByZXZUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgICAgICgoYWN0aW9uUXVldWUgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplKSxcbiAgICAgICAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKSxcbiAgICAgICAgICAgICAgMTAgPCBhY3Rpb25RdWV1ZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiBJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiBPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuXCJcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgKGN1cnJlbnRUcmFuc2l0aW9uID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCkpLFxuICAgICAgICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIGN1cnJlbnRUcmFuc2l0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IkMikge1xuICAgICAgICAgIG9uQWN0aW9uRXJyb3IoYWN0aW9uUXVldWUsIG5vZGUsIGVycm9yJDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblJldHVyblZhbHVlKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICAgICA/IChyZXR1cm5WYWx1ZS50aGVuKFxuICAgICAgICAgICAgZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICAgICAgICBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIG5leHRTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICBub2RlLmlzVHJhbnNpdGlvbiB8fFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJBbiBhc3luYyBmdW5jdGlvbiB3YXMgcGFzc2VkIHRvIHVzZUFjdGlvblN0YXRlLCBidXQgaXQgd2FzIGRpc3BhdGNoZWQgb3V0c2lkZSBvZiBhbiBhY3Rpb24gY29udGV4dC4gVGhpcyBpcyBsaWtlbHkgbm90IHdoYXQgeW91IGludGVuZGVkLiBFaXRoZXIgcGFzcyB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24gdG8gYW4gYGFjdGlvbmAgcHJvcCwgb3IgZGlzcGF0Y2ggbWFudWFsbHkgaW5zaWRlIGBzdGFydFRyYW5zaXRpb25gXCJcbiAgICAgICAgICAgICkpXG4gICAgICAgIDogb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCByZXR1cm5WYWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgbmV4dFN0YXRlKSB7XG4gICAgICBhY3Rpb25Ob2RlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICBhY3Rpb25Ob2RlLnZhbHVlID0gbmV4dFN0YXRlO1xuICAgICAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICAgICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBhY3Rpb25Ob2RlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICAgIG51bGwgIT09IGFjdGlvbk5vZGUgJiZcbiAgICAgICAgKChuZXh0U3RhdGUgPSBhY3Rpb25Ob2RlLm5leHQpLFxuICAgICAgICBuZXh0U3RhdGUgPT09IGFjdGlvbk5vZGVcbiAgICAgICAgICA/IChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbClcbiAgICAgICAgICA6ICgobmV4dFN0YXRlID0gbmV4dFN0YXRlLm5leHQpLFxuICAgICAgICAgICAgKGFjdGlvbk5vZGUubmV4dCA9IG5leHRTdGF0ZSksXG4gICAgICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbmV4dFN0YXRlKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlLCBlcnJvcikge1xuICAgICAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICAgICAgYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gbGFzdCkge1xuICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICBkb1xuICAgICAgICAgIChhY3Rpb25Ob2RlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZS5yZWFzb24gPSBlcnJvciksXG4gICAgICAgICAgICBub3RpZnlBY3Rpb25MaXN0ZW5lcnMoYWN0aW9uTm9kZSksXG4gICAgICAgICAgICAoYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubmV4dCk7XG4gICAgICAgIHdoaWxlIChhY3Rpb25Ob2RlICE9PSBsYXN0KTtcbiAgICAgIH1cbiAgICAgIGFjdGlvblF1ZXVlLmFjdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSB7XG4gICAgICBhY3Rpb25Ob2RlID0gYWN0aW9uTm9kZS5saXN0ZW5lcnM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbk5vZGUubGVuZ3RoOyBpKyspICgwLCBhY3Rpb25Ob2RlW2ldKSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY3Rpb25TdGF0ZVJlZHVjZXIob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGVQcm9wKSB7XG4gICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHNzckZvcm1TdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdC5mb3JtU3RhdGU7XG4gICAgICAgIGlmIChudWxsICE9PSBzc3JGb3JtU3RhdGUpIHtcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICB2YXIgaXNNYXRjaGluZyA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gICAgICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VySW5zdGFuY2UgPSBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyKFxuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrZXJJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBpc01hdGNoaW5nID0gaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goaXNNYXRjaGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc01hdGNoaW5nID0gITE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzTWF0Y2hpbmcgJiYgKGluaXRpYWxTdGF0ZVByb3AgPSBzc3JGb3JtU3RhdGVbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzc3JGb3JtU3RhdGUgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgc3NyRm9ybVN0YXRlLm1lbW9pemVkU3RhdGUgPSBzc3JGb3JtU3RhdGUuYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcbiAgICAgIGlzTWF0Y2hpbmcgPSB7XG4gICAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICAgIGxhbmVzOiAwLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYWN0aW9uU3RhdGVSZWR1Y2VyLFxuICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlUHJvcFxuICAgICAgfTtcbiAgICAgIHNzckZvcm1TdGF0ZS5xdWV1ZSA9IGlzTWF0Y2hpbmc7XG4gICAgICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIGlzTWF0Y2hpbmdcbiAgICAgICk7XG4gICAgICBpc01hdGNoaW5nLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICAgICAgaXNNYXRjaGluZyA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgICAgIHZhciBzZXRQZW5kaW5nU3RhdGUgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgICAgICAhMSxcbiAgICAgICAgaXNNYXRjaGluZy5xdWV1ZVxuICAgICAgKTtcbiAgICAgIGlzTWF0Y2hpbmcgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgbWFya2VySW5zdGFuY2UgPSB7XG4gICAgICAgIHN0YXRlOiBpbml0aWFsU3RhdGVQcm9wLFxuICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIHBlbmRpbmc6IG51bGxcbiAgICAgIH07XG4gICAgICBpc01hdGNoaW5nLnF1ZXVlID0gbWFya2VySW5zdGFuY2U7XG4gICAgICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaEFjdGlvblN0YXRlLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIG1hcmtlckluc3RhbmNlLFxuICAgICAgICBzZXRQZW5kaW5nU3RhdGUsXG4gICAgICAgIHNzckZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIG1hcmtlckluc3RhbmNlLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICAgICAgaXNNYXRjaGluZy5tZW1vaXplZFN0YXRlID0gYWN0aW9uO1xuICAgICAgcmV0dXJuIFtpbml0aWFsU3RhdGVQcm9wLCBzc3JGb3JtU3RhdGUsICExXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudEhvb2ssIGFjdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbikge1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgICAgICBzdGF0ZUhvb2ssXG4gICAgICAgIGN1cnJlbnRTdGF0ZUhvb2ssXG4gICAgICAgIGFjdGlvblN0YXRlUmVkdWNlclxuICAgICAgKVswXTtcbiAgICAgIHN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdO1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vay50aGVuXG4gICAgICAgICAgPyB1c2VUaGVuYWJsZShjdXJyZW50U3RhdGVIb29rKVxuICAgICAgICAgIDogY3VycmVudFN0YXRlSG9vaztcbiAgICAgIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSxcbiAgICAgICAgYWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZUhvb2sucXVldWUsXG4gICAgICAgIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7XG4gICAgICBhY3Rpb24gIT09IGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgcHVzaEVmZmVjdChcbiAgICAgICAgICBIYXNFZmZlY3QgfCBQYXNzaXZlLFxuICAgICAgICAgIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0LmJpbmQobnVsbCwgYWN0aW9uUXVldWUsIGFjdGlvbiksXG4gICAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgICBudWxsXG4gICAgICAgICkpO1xuICAgICAgcmV0dXJuIFtjdXJyZW50U3RhdGVIb29rLCBkaXNwYXRjaCwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QoYWN0aW9uUXVldWUsIGFjdGlvbikge1xuICAgICAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbikge1xuICAgICAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgICAgICBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFN0YXRlSG9vaylcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gICAgICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHN0YXRlSG9vayA9IHN0YXRlSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgdmFyIGRpc3BhdGNoID0gY3VycmVudFN0YXRlSG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgICAgIGN1cnJlbnRTdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgICAgIHJldHVybiBbc3RhdGVIb29rLCBkaXNwYXRjaCwgITFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBpbnN0LCBkZXBzKSB7XG4gICAgICB0YWcgPSB7IHRhZzogdGFnLCBjcmVhdGU6IGNyZWF0ZSwgaW5zdDogaW5zdCwgZGVwczogZGVwcywgbmV4dDogbnVsbCB9O1xuICAgICAgY3JlYXRlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcbiAgICAgIG51bGwgPT09IGNyZWF0ZSAmJlxuICAgICAgICAoKGNyZWF0ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY3JlYXRlKSk7XG4gICAgICBpbnN0ID0gY3JlYXRlLmxhc3RFZmZlY3Q7XG4gICAgICBudWxsID09PSBpbnN0XG4gICAgICAgID8gKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnLm5leHQgPSB0YWcpXG4gICAgICAgIDogKChkZXBzID0gaW5zdC5uZXh0KSxcbiAgICAgICAgICAoaW5zdC5uZXh0ID0gdGFnKSxcbiAgICAgICAgICAodGFnLm5leHQgPSBkZXBzKSxcbiAgICAgICAgICAoY3JlYXRlLmxhc3RFZmZlY3QgPSB0YWcpKTtcbiAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgaW5pdGlhbFZhbHVlID0geyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfTtcbiAgICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KFxuICAgICAgICBIYXNFZmZlY3QgfCBob29rRmxhZ3MsXG4gICAgICAgIGNyZWF0ZSxcbiAgICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgaW5zdCA9IGhvb2subWVtb2l6ZWRTdGF0ZS5pbnN0O1xuICAgICAgbnVsbCAhPT0gY3VycmVudEhvb2sgJiZcbiAgICAgIG51bGwgIT09IGRlcHMgJiZcbiAgICAgIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLmRlcHMpXG4gICAgICAgID8gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIGRlcHMpKVxuICAgICAgICA6ICgoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzKSxcbiAgICAgICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChcbiAgICAgICAgICAgIEhhc0VmZmVjdCB8IGhvb2tGbGFncyxcbiAgICAgICAgICAgIGNyZWF0ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBkZXBzXG4gICAgICAgICAgKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIDY0KSA9PT0gTm9Nb2RlXG4gICAgICAgID8gbW91bnRFZmZlY3RJbXBsKDE0MjYwODM4NCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKVxuICAgICAgICA6IG1vdW50RWZmZWN0SW1wbCg4MzkwNjU2LCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBmaWJlckZsYWdzID0gNDE5NDMwODtcbiAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiAxNikgIT09IE5vTW9kZSAmJlxuICAgICAgICAoZmliZXJGbGFncyB8PSA2NzEwODg2NCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgdmFyIHJlZkNsZWFudXAgPSByZWYoY3JlYXRlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwID8gcmVmQ2xlYW51cCgpIDogcmVmKG51bGwpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG51bGwgIT09IHJlZiAmJiB2b2lkIDAgIT09IHJlZilcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICByZWYuaGFzT3duUHJvcGVydHkoXCJjdXJyZW50XCIpIHx8XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSByZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgICAgXCJhbiBvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKHJlZikuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNyZWF0ZSA9IGNyZWF0ZSgpKSxcbiAgICAgICAgICAocmVmLmN1cnJlbnQgPSBjcmVhdGUpLFxuICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY3JlYXRlICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICBudWxsICE9PSBjcmVhdGUgPyB0eXBlb2YgY3JlYXRlIDogXCJudWxsXCJcbiAgICAgICAgKTtcbiAgICAgIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gICAgICB2YXIgZmliZXJGbGFncyA9IDQxOTQzMDg7XG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgMTYpICE9PSBOb01vZGUgJiZcbiAgICAgICAgKGZpYmVyRmxhZ3MgfD0gNjcxMDg4NjQpO1xuICAgICAgbW91bnRFZmZlY3RJbXBsKFxuICAgICAgICBmaWJlckZsYWdzLFxuICAgICAgICBMYXlvdXQsXG4gICAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICAgIGRlcHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNyZWF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuXCIsXG4gICAgICAgICAgbnVsbCAhPT0gY3JlYXRlID8gdHlwZW9mIGNyZWF0ZSA6IFwibnVsbFwiXG4gICAgICAgICk7XG4gICAgICBkZXBzID0gbnVsbCAhPT0gZGVwcyAmJiB2b2lkIDAgIT09IGRlcHMgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICAgICAgdXBkYXRlRWZmZWN0SW1wbChcbiAgICAgICAgNCxcbiAgICAgICAgTGF5b3V0LFxuICAgICAgICBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLFxuICAgICAgICBkZXBzXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSBbXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwc1xuICAgICAgXTtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIGRlcHNdO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICAgICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgICAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV4dENyZWF0ZSgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgZGVwc107XG4gICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICBkZXBzID0gdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHM7XG4gICAgICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGRlcHMgJiYgYXJlSG9va0lucHV0c0VxdWFsKGRlcHMsIHByZXZTdGF0ZVsxXSkpXG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICBwcmV2U3RhdGUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5leHRDcmVhdGUoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtwcmV2U3RhdGUsIGRlcHNdO1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICAgIGhvb2ssXG4gICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbml0aWFsVmFsdWVcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGN1cnJlbnRIb29rXG4gICAgICAgID8gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKVxuICAgICAgICA6IHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKFxuICAgICAgICAgICAgaG9vayxcbiAgICAgICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGluaXRpYWxWYWx1ZVxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gaW5pdGlhbFZhbHVlIHx8IDAgIT09IChyZW5kZXJMYW5lcyAmIDEwNzM3NDE4MjQpKVxuICAgICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgIGhvb2sgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IGhvb2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgaWYgKG9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChob29rID0gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSksXG4gICAgICAgICAgb2JqZWN0SXMoaG9vaywgcHJldlZhbHVlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgICAgICBob29rXG4gICAgICAgICk7XG4gICAgICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpKVxuICAgICAgICByZXR1cm4gKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksIChob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZSk7XG4gICAgICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGhvb2s7XG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KFxuICAgICAgICAwICE9PSBwcmV2aW91c1ByaW9yaXR5ICYmIDggPiBwcmV2aW91c1ByaW9yaXR5ID8gcHJldmlvdXNQcmlvcml0eSA6IDhcbiAgICAgICk7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgICAgZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoZmliZXIsICExLCBxdWV1ZSwgcGVuZGluZ1N0YXRlKTtcbiAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gY2FsbGJhY2soKSxcbiAgICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICAgIG51bGwgIT09IG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICYmXG4gICAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlID0gY2hhaW5UaGVuYWJsZVZhbHVlKFxuICAgICAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgICAgICBmaW5pc2hlZFN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlLFxuICAgICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICBxdWV1ZSxcbiAgICAgICAgICAgIGZpbmlzaGVkU3RhdGUsXG4gICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKFxuICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgIHsgdGhlbjogZnVuY3Rpb24gKCkge30sIHN0YXR1czogXCJyZWplY3RlZFwiLCByZWFzb246IGVycm9yIH0sXG4gICAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgbnVsbCA9PT0gcHJldlRyYW5zaXRpb24gJiZcbiAgICAgICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzICYmXG4gICAgICAgICAgICAoKGZpYmVyID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZSksXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpLFxuICAgICAgICAgICAgMTAgPCBmaWJlciAmJlxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uIElmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuIE90aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS5cIlxuICAgICAgICAgICAgICApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gICAgICB2YXIgZXhpc3RpbmdTdGF0ZUhvb2sgPSBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChudWxsICE9PSBleGlzdGluZ1N0YXRlSG9vaykgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2sgPSB7XG4gICAgICAgIG1lbW9pemVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgICAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgICAgIHF1ZXVlOiB7XG4gICAgICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb25cbiAgICAgICAgfSxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICAgICAgZXhpc3RpbmdTdGF0ZUhvb2submV4dCA9IHtcbiAgICAgICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICAgICAgcXVldWU6IHtcbiAgICAgICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgICAgIGxhbmVzOiAwLFxuICAgICAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vaztcbiAgICAgIGZvcm1GaWJlciA9IGZvcm1GaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBmb3JtRmliZXIgJiYgKGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gZXhpc3RpbmdTdGF0ZUhvb2spO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgc3RhdGVIb29rID0gbW91bnRTdGF0ZUltcGwoITEpO1xuICAgICAgc3RhdGVIb29rID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQoXG4gICAgICAgIG51bGwsXG4gICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICAgIHN0YXRlSG9vay5xdWV1ZSxcbiAgICAgICAgITAsXG4gICAgICAgICExXG4gICAgICApO1xuICAgICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICAgICAgcmV0dXJuIFshMSwgc3RhdGVIb29rXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgICBzdGFydCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgICAgPyBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgIDogdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpLFxuICAgICAgICBzdGFydFxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIGJvb2xlYW5PclRoZW5hYmxlID0gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKVswXSxcbiAgICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZVxuICAgICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgICA6IHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKSxcbiAgICAgICAgc3RhcnRcbiAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KEhvc3RUcmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50SWQoKSB7XG4gICAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggPSB3b3JrSW5Qcm9ncmVzc1Jvb3QuaWRlbnRpZmllclByZWZpeDtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgdHJlZUlkID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgICAgdmFyIGlkV2l0aExlYWRpbmdCaXQgPSB0cmVlQ29udGV4dElkO1xuICAgICAgICB0cmVlSWQgPVxuICAgICAgICAgIChcbiAgICAgICAgICAgIGlkV2l0aExlYWRpbmdCaXQgJiB+KDEgPDwgKDMyIC0gY2x6MzIoaWRXaXRoTGVhZGluZ0JpdCkgLSAxKSlcbiAgICAgICAgICApLnRvU3RyaW5nKDMyKSArIHRyZWVJZDtcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCA9IFwiOlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiUlwiICsgdHJlZUlkO1xuICAgICAgICB0cmVlSWQgPSBsb2NhbElkQ291bnRlcisrO1xuICAgICAgICAwIDwgdHJlZUlkICYmIChpZGVudGlmaWVyUHJlZml4ICs9IFwiSFwiICsgdHJlZUlkLnRvU3RyaW5nKDMyKSk7XG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCI6XCI7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRyZWVJZCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrKSxcbiAgICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgICBcIjpcIiArIGlkZW50aWZpZXJQcmVmaXggKyBcInJcIiArIHRyZWVJZC50b1N0cmluZygzMikgKyBcIjpcIik7XG4gICAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGlkZW50aWZpZXJQcmVmaXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFJlZnJlc2goKSB7XG4gICAgICByZXR1cm4gKG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHJlZnJlc2hDYWNoZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgICApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVmcmVzaENhY2hlKGZpYmVyLCBzZWVkS2V5KSB7XG4gICAgICBmb3IgKHZhciBwcm92aWRlciA9IGZpYmVyLnJldHVybjsgbnVsbCAhPT0gcHJvdmlkZXI7ICkge1xuICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyLnRhZykge1xuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShwcm92aWRlcik7XG4gICAgICAgICAgICBmaWJlciA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShwcm92aWRlciwgZmliZXIsIGxhbmUpO1xuICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIHByb3ZpZGVyLCBsYW5lKSxcbiAgICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBwcm92aWRlciwgbGFuZSkpO1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBjcmVhdGVDYWNoZSgpO1xuICAgICAgICAgICAgbnVsbCAhPT0gc2VlZEtleSAmJlxuICAgICAgICAgICAgICB2b2lkIDAgIT09IHNlZWRLZXkgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhlIHNlZWQgYXJndW1lbnQgaXMgbm90IGVuYWJsZWQgb3V0c2lkZSBleHBlcmltZW50YWwgY2hhbm5lbHMuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZpYmVyLnBheWxvYWQgPSB7IGNhY2hlOiBwcm92aWRlciB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uLFxuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgKSB7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIHNlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS5cIlxuICAgICAgICApO1xuICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgYWN0aW9uID0ge1xuICAgICAgICBsYW5lOiBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDAsXG4gICAgICAgIHJldmVydExhbmU6IDAsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpXG4gICAgICAgID8gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCBhY3Rpb24pXG4gICAgICAgIDogKChhY3Rpb24gPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwXG4gICAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gYWN0aW9uICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKFxuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDBcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoXG4gICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgcXVldWUsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMFxuICAgICAgICAgICAgKSkpO1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBKU0NvbXBpbGVyX09wdGltaXplQXJndW1lbnRzQXJyYXlfcDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKFxuICAgICAgZmliZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvbixcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMVxuICAgICkge1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuXCJcbiAgICAgICAgKTtcbiAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgICAgZmliZXIsXG4gICAgICAgIHF1ZXVlLFxuICAgICAgICBhY3Rpb24sXG4gICAgICAgIEpTQ29tcGlsZXJfT3B0aW1pemVBcmd1bWVudHNBcnJheV9wMVxuICAgICAgKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZUludGVybmFsKGZpYmVyLCBxdWV1ZSwgYWN0aW9uLCBsYW5lKSB7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBsYW5lOiBsYW5lLFxuICAgICAgICByZXZlcnRMYW5lOiAwLFxuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgMCA9PT0gZmliZXIubGFuZXMgJiZcbiAgICAgICAgICAobnVsbCA9PT0gYWx0ZXJuYXRlIHx8IDAgPT09IGFsdGVybmF0ZS5sYW5lcykgJiZcbiAgICAgICAgICAoKGFsdGVybmF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIpLCBudWxsICE9PSBhbHRlcm5hdGUpXG4gICAgICAgICkge1xuICAgICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGUgPSBhbHRlcm5hdGUoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSAhMDtcbiAgICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcbiAgICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKVxuICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgMCksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgICAgICAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgIGlmIChudWxsICE9PSBhY3Rpb24pXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihhY3Rpb24sIGZpYmVyLCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShhY3Rpb24sIHF1ZXVlLCBsYW5lKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIHRocm93SWZEdXJpbmdSZW5kZXIsXG4gICAgICBxdWV1ZSxcbiAgICAgIGFjdGlvblxuICAgICkge1xuICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCAmJlxuICAgICAgICAwID09PSBjdXJyZW50RW50YW5nbGVkTGFuZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQW4gb3B0aW1pc3RpYyBzdGF0ZSB1cGRhdGUgb2NjdXJyZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyBmaXgsIG1vdmUgdGhlIHVwZGF0ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uXCJcbiAgICAgICAgKTtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgbGFuZTogMixcbiAgICAgICAgcmV2ZXJ0TGFuZTogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCksXG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBoYXNFYWdlclN0YXRlOiAhMSxcbiAgICAgICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgICAgICBpZiAodGhyb3dJZkR1cmluZ1JlbmRlcilcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuXCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2Fubm90IGNhbGwgc3RhcnRUcmFuc2l0aW9uIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgKHRocm93SWZEdXJpbmdSZW5kZXIgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICAgICAgZmliZXIsXG4gICAgICAgICAgcXVldWUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIDJcbiAgICAgICAgKSksXG4gICAgICAgICAgbnVsbCAhPT0gdGhyb3dJZkR1cmluZ1JlbmRlciAmJlxuICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHRocm93SWZEdXJpbmdSZW5kZXIsIGZpYmVyLCAyKTtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fFxuICAgICAgICAobnVsbCAhPT0gYWx0ZXJuYXRlICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPVxuICAgICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITA7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUocm9vdCwgcXVldWUsIGxhbmUpIHtcbiAgICAgIGlmICgwICE9PSAobGFuZSAmIDQxOTQxNzYpKSB7XG4gICAgICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7XG4gICAgICAgIHF1ZXVlTGFuZXMgJj0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gICAgICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICAgICAgcXVldWUubGFuZXMgPSBsYW5lO1xuICAgICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICBpZiAobnVsbCAhPT0gY2FsbGJhY2sgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG4gICAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSB8fFxuICAgICAgICAgIChkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBjdG9yLFxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICAgICAgbmV4dFByb3BzXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZvaWQgMCA9PT0gcGFydGlhbFN0YXRlICYmXG4gICAgICAgICgoY3RvciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjdG9yKSB8fFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGN0b3IpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgY3RvclxuICAgICAgICAgICkpKTtcbiAgICAgIHByZXZTdGF0ZSA9XG4gICAgICAgIG51bGwgPT09IHBhcnRpYWxTdGF0ZSB8fCB2b2lkIDAgPT09IHBhcnRpYWxTdGF0ZVxuICAgICAgICAgID8gcHJldlN0YXRlXG4gICAgICAgICAgOiBhc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U3RhdGU7XG4gICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN0b3IsXG4gICAgICBvbGRQcm9wcyxcbiAgICAgIG5ld1Byb3BzLFxuICAgICAgb2xkU3RhdGUsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKSB7XG4gICAgICAgIG9sZFByb3BzID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgIG5leHRDb250ZXh0XG4gICAgICAgICk7XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2xkUHJvcHMgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dENvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdm9pZCAwID09PSBvbGRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhIGJvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG9sZFByb3BzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50XG4gICAgICAgID8gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKVxuICAgICAgICA6ICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaW5zdGFuY2UsXG4gICAgICBuZXdQcm9wcyxcbiAgICAgIG5leHRDb250ZXh0XG4gICAgKSB7XG4gICAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyh3b3JrSW5Qcm9ncmVzcykgfHxcbiAgICAgICAgICAoZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSksXG4gICAgICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKFxuICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgIGluc3RhbmNlLnN0YXRlLFxuICAgICAgICAgIG51bGxcbiAgICAgICAgKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG4gICAgICBpZiAoXCJyZWZcIiBpbiBiYXNlUHJvcHMpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKVxuICAgICAgICAgIFwicmVmXCIgIT09IHByb3BOYW1lICYmIChuZXdQcm9wc1twcm9wTmFtZV0gPSBiYXNlUHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIGlmICgoQ29tcG9uZW50ID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcykpIHtcbiAgICAgICAgbmV3UHJvcHMgPT09IGJhc2VQcm9wcyAmJiAobmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzKSk7XG4gICAgICAgIGZvciAodmFyIF9wcm9wTmFtZSBpbiBDb21wb25lbnQpXG4gICAgICAgICAgdm9pZCAwID09PSBuZXdQcm9wc1tfcHJvcE5hbWVdICYmXG4gICAgICAgICAgICAobmV3UHJvcHNbX3Byb3BOYW1lXSA9IENvbXBvbmVudFtfcHJvcE5hbWVdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlXG4gICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpXG4gICAgICAgICAgOiBudWxsO1xuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgICAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlKVxuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIG9uVW5jYXVnaHRFcnJvciA9IHJvb3Qub25VbmNhdWdodEVycm9yO1xuICAgICAgICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvciwgeyBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZVxuICAgICAgICAgID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KTtcbiAgICAgICAgdmFyIG9uQ2F1Z2h0RXJyb3IgPSByb290Lm9uQ2F1Z2h0RXJyb3I7XG4gICAgICAgIG9uQ2F1Z2h0RXJyb3IoZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayxcbiAgICAgICAgICBlcnJvckJvdW5kYXJ5OiAxID09PSBib3VuZGFyeS50YWcgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3QsIGVycm9ySW5mbywgbGFuZSkge1xuICAgICAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgIGxhbmUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgICAgIGxhbmUucGF5bG9hZCA9IHsgZWxlbWVudDogbnVsbCB9O1xuICAgICAgbGFuZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSwgbG9nVW5jYXVnaHRFcnJvciwgcm9vdCwgZXJyb3JJbmZvKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gICAgICBsYW5lID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgICAgbGFuZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICAgICAgcmV0dXJuIGxhbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgZmliZXIsIGVycm9ySW5mbykge1xuICAgICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgbnVsbCAhPT0gaW5zdCAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICh1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgZXJyb3JJbmZvLnNvdXJjZSxcbiAgICAgICAgICAgIGxvZ0NhdWdodEVycm9yLFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgZXJyb3JJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZFxuICAgICAgICAgICAgICA/IChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW3RoaXNdKSlcbiAgICAgICAgICAgICAgOiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5hZGQodGhpcykpO1xuICAgICAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWKHRoaXMsIGVycm9ySW5mbyk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAoMCA9PT0gKGZpYmVyLmxhbmVzICYgMikgJiZcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIiVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuIEluIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gICAgICByb290LFxuICAgICAgcmV0dXJuRmliZXIsXG4gICAgICBzb3VyY2VGaWJlcixcbiAgICAgIHZhbHVlLFxuICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSAzMjc2ODtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlLnRoZW5cbiAgICAgICkge1xuICAgICAgICByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIGlzSHlkcmF0aW5nICYmIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKTtcbiAgICAgICAgc291cmNlRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAobnVsbCAhPT0gc291cmNlRmliZXIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHNvdXJjZUZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBudWxsID09PSBzaGVsbEJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgICA/IHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKVxuICAgICAgICAgICAgICAgICAgOiBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgJj0gLTI1NyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDE2Mzg0KVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICAgID8gKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJldHVybkZpYmVyLmFkZCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXJJbnN0YW5jZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5UXVldWU6IG5ldyBTZXQoW3ZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgICAgIDogKChzb3VyY2VGaWJlciA9IHJldHVybkZpYmVyLnJldHJ5UXVldWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogc291cmNlRmliZXIuYWRkKHZhbHVlKSksXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICtcbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgaWYgKGlzSHlkcmF0aW5nKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICEwKSxcbiAgICAgICAgICAocmV0dXJuRmliZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgPyAoMCA9PT0gKHJldHVybkZpYmVyLmZsYWdzICYgNjU1MzYpICYmIChyZXR1cm5GaWJlci5mbGFncyB8PSAyNTYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocmV0dXJuRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICB2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICAgIEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgZnJvbSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS5cIixcbiAgICAgICAgICAgICAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgICAgICAgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5IGluc3RlYWQgY2xpZW50IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgeyBjYXVzZTogdmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIChyb290ID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIChyb290LmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyAmPSAtcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHJvb3QubGFuZXMgfD0gcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKSksXG4gICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgcm9vdC5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQpKSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgdmFyIGVycm9yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgIEVycm9yKFxuICAgICAgICAgIFwiVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb25jdXJyZW50IHJlbmRlcmluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSBpbnN0ZWFkIHN5bmNocm9ub3VzbHkgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC5cIixcbiAgICAgICAgICB7IGNhdXNlOiB2YWx1ZSB9XG4gICAgICAgICksXG4gICAgICAgIHNvdXJjZUZpYmVyXG4gICAgICApO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9yc1xuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gW2Vycm9yXSlcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkKTtcbiAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgcmV0dXJuICEwO1xuICAgICAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgc291cmNlRmliZXIgPSByZXR1cm5GaWJlcjtcbiAgICAgIGRvIHtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VGaWJlci50YWcpIHtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAocm9vdCA9IHJvb3RSZW5kZXJMYW5lcyAmIC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgfD0gcm9vdCksXG4gICAgICAgICAgICAgIChyb290ID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKFxuICAgICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICByb290XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUoc291cmNlRmliZXIsIHJvb3QpLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBzb3VyY2VGaWJlci50eXBlKSxcbiAgICAgICAgICAgICAgKGVycm9yID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgMCA9PT0gKHNvdXJjZUZpYmVyLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgIChudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlcnJvci5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAhbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGVycm9yKSkpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc291cmNlRmliZXIuZmxhZ3MgfD0gNjU1MzYpLFxuICAgICAgICAgICAgICAgIChyb290UmVuZGVyTGFuZXMgJj0gLXJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUocm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoXG4gICAgICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gICAgICB9IHdoaWxlIChudWxsICE9PSBzb3VyY2VGaWJlcik7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID1cbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcylcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucmVuZGVyO1xuICAgICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGlmIChcInJlZlwiIGluIG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHNXaXRob3V0UmVmID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgXCJyZWZcIiAhPT0ga2V5ICYmIChwcm9wc1dpdGhvdXRSZWZba2V5XSA9IG5leHRQcm9wc1trZXldKTtcbiAgICAgIH0gZWxzZSBwcm9wc1dpdGhvdXRSZWYgPSBuZXh0UHJvcHM7XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3MoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHByb3BzV2l0aG91dFJlZixcbiAgICAgICAgcmVmLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICAgIGtleSA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gICAgICBpc0h5ZHJhdGluZyAmJiBrZXkgJiYgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgbmV4dFByb3BzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgIHZhciB0eXBlID0gQ29tcG9uZW50LnR5cGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlICYmXG4gICAgICAgICAgIXNob3VsZENvbnN0cnVjdCh0eXBlKSAmJlxuICAgICAgICAgIHZvaWQgMCA9PT0gdHlwZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgICAgICBudWxsID09PSBDb21wb25lbnQuY29tcGFyZVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDE1KSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50KSxcbiAgICAgICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSksXG4gICAgICAgICAgICB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICBDb21wb25lbnQudHlwZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gY3VycmVudC5jaGlsZDtcbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIHZhciBwcmV2UHJvcHMgPSB0eXBlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgICAgICBDb21wb25lbnQgPSBudWxsICE9PSBDb21wb25lbnQgPyBDb21wb25lbnQgOiBzaGFsbG93RXF1YWw7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBDb21wb25lbnQocHJldlByb3BzLCBuZXh0UHJvcHMpICYmXG4gICAgICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICAgICAgY3VycmVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHR5cGUsIG5leHRQcm9wcyk7XG4gICAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICAgIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiZcbiAgICAgICAgICBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlXG4gICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzKSxcbiAgICAgICAgICAgIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgJiYgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuLFxuICAgICAgICBuZXh0SXNEZXRhY2hlZCA9XG4gICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyKSxcbiAgICAgICAgcHJldlN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChcImhpZGRlblwiID09PSBuZXh0UHJvcHMubW9kZSB8fCBuZXh0SXNEZXRhY2hlZCkge1xuICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIHwgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgOiByZW5kZXJMYW5lcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgICAgICAgICAgZm9yIChuZXh0SXNEZXRhY2hlZCA9IDA7IG51bGwgIT09IG5leHRDaGlsZHJlbjsgKVxuICAgICAgICAgICAgICAobmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgICAgICAgIG5leHRJc0RldGFjaGVkIHwgbmV4dENoaWxkcmVuLmxhbmVzIHwgbmV4dENoaWxkcmVuLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW4uc2libGluZyk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbmV4dElzRGV0YWNoZWQgJiB+bmV4dFByb3BzO1xuICAgICAgICAgIH0gZWxzZSAod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDApLCAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKTtcbiAgICAgICAgICByZXR1cm4gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7IGJhc2VMYW5lczogMCwgY2FjaGVQb29sOiBudWxsIH0pLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBwdXNoVHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGUgPyBwcmV2U3RhdGUuY2FjaGVQb29sIDogbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlXG4gICAgICAgICAgICAgID8gcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSlcbiAgICAgICAgICAgICAgOiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICAgICAgZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICAgICAgICA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgIDogcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICA/IChwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlLmNhY2hlUG9vbCksXG4gICAgICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKSxcbiAgICAgICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpKVxuICAgICAgICAgIDogKG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpLFxuICAgICAgICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0QmFzZUxhbmVzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgbnVsbCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgICA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsXG4gICAgICAgICAgICAgIHBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICAgICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICAgIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgITApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgICBpZiAobnVsbCA9PT0gcmVmKVxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5yZWYgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA5NzY2NCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHJlZiAmJiBcIm9iamVjdFwiICE9PSB0eXBlb2YgcmVmKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciB1bmRlZmluZWQvbnVsbC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA5NzY2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyXG4gICAgICApIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIjtcbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgOCAmJlxuICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICh2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICBDb21wb25lbnQuY29udGV4dFR5cGVzICYmXG4gICAgICAgICAgKChjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJVbmtub3duXCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlc1tjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgICAgKChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZXNbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiBVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuIChodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0KVwiLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApKSkpO1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgQ29tcG9uZW50ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBuZXh0UHJvcHMgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgbmV4dFByb3BzICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBzZWNvbmRBcmcsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICBuZXh0UHJvcHMgPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICBzZWNvbmRBcmdcbiAgICAgICk7XG4gICAgICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBDb21wb25lbnQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgICApO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgQ29tcG9uZW50ICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBuZXh0UHJvcHMsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgc3dpdGNoIChzaG91bGRFcnJvckltcGwod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIGNhc2UgITE6XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSxcbiAgICAgICAgICAgIHN0YXRlID0gbmV3IHdvcmtJblByb2dyZXNzLnR5cGUoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZS5jb250ZXh0XG4gICAgICAgICAgICApLnN0YXRlO1xuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAhMDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjg7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjU1MzY7XG4gICAgICAgICAgX2luc3RhbmNlID0gRXJyb3IoXCJTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHNcIik7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyB8PSBsYW5lO1xuICAgICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICAgICAgICAgIGlmIChudWxsID09PSBzdGF0ZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBsYW5lID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKTtcbiAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoX2luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICApO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgbGFuZSk7XG4gICAgICB9XG4gICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIHN0YXRlID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBfaW5zdGFuY2UgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgICAgIFwiY29udGV4dFR5cGVcIiBpbiBDb21wb25lbnQgJiZcbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAodm9pZCAwID09PSBfaW5zdGFuY2UgfHwgX2luc3RhbmNlLiQkdHlwZW9mICE9PSBSRUFDVF9DT05URVhUX1RZUEUpICYmXG4gICAgICAgICAgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoQ29tcG9uZW50KSAmJlxuICAgICAgICAgIChkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgKGxhbmUgPVxuICAgICAgICAgICAgdm9pZCAwID09PSBfaW5zdGFuY2VcbiAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiBUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiBUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyB0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuXCJcbiAgICAgICAgICAgICAgOiBcIm9iamVjdFwiICE9PSB0eXBlb2YgX2luc3RhbmNlXG4gICAgICAgICAgICAgICAgPyBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSBcIiArIHR5cGVvZiBfaW5zdGFuY2UgKyBcIi5cIlxuICAgICAgICAgICAgICAgIDogX2luc3RhbmNlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFXG4gICAgICAgICAgICAgICAgICA/IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD9cIlxuICAgICAgICAgICAgICAgICAgOiBcIiBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7XCIgK1xuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfaW5zdGFuY2UpLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwifS5cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiBjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lc1wiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIixcbiAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICApKTtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIF9pbnN0YW5jZSAmJlxuICAgICAgICAgIG51bGwgIT09IF9pbnN0YW5jZSAmJlxuICAgICAgICAgIChzdGF0ZSA9IHJlYWRDb250ZXh0KF9pbnN0YW5jZSkpO1xuICAgICAgICBfaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgc3RhdGUpO1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDgpIHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobmV4dFByb3BzLCBzdGF0ZSk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICBudWxsICE9PSBfaW5zdGFuY2Uuc3RhdGUgJiYgdm9pZCAwICE9PSBfaW5zdGFuY2Uuc3RhdGVcbiAgICAgICAgICAgID8gX2luc3RhbmNlLnN0YXRlXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIF9pbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBfaW5zdGFuY2U7XG4gICAgICAgIF9pbnN0YW5jZS5fcmVhY3RJbnRlcm5hbHMgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgX2luc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAmJlxuICAgICAgICAgIG51bGwgPT09IHN0YXRlICYmXG4gICAgICAgICAgKChzdGF0ZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiQ29tcG9uZW50XCIpLFxuICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoc3RhdGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChzdGF0ZSksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcImAlc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuIFRoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS5cIixcbiAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgIG51bGwgPT09IF9pbnN0YW5jZS5zdGF0ZSA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAobGFuZSA9IHN0YXRlID0gbnVsbCk7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICEwICE9PSBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICAgID8gKHN0YXRlID0gXCJjb21wb25lbnRXaWxsTW91bnRcIilcbiAgICAgICAgICAgIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgKHN0YXRlID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50XCIpO1xuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgITAgIT09XG4gICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChsYW5lID0gXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICAgIChsYW5lID0gXCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiKTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICEwICE9PSBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgICA/IChmb3VuZFdpbGxVcGRhdGVOYW1lID0gXCJjb21wb25lbnRXaWxsVXBkYXRlXCIpXG4gICAgICAgICAgICA6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9IFwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVcIik7XG4gICAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlIHx8IG51bGwgIT09IGxhbmUgfHwgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSkge1xuICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgICAgIHZhciBuZXdBcGlOYW1lID1cbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuICAgICAgICAgICAgICAgID8gXCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKVwiXG4gICAgICAgICAgICAgICAgOiBcImdldFNuYXBzaG90QmVmb3JlVXBkYXRlKClcIjtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9pbnN0YW5jZSkgfHxcbiAgICAgICAgICAgICAgKGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9pbnN0YW5jZSksXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4lcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXNcIixcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgbmV3QXBpTmFtZSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBzdGF0ZSA/IFwiXFxuICBcIiArIHN0YXRlIDogXCJcIixcbiAgICAgICAgICAgICAgICBudWxsICE9PSBsYW5lID8gXCJcXG4gIFwiICsgbGFuZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiBcIlwiXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBfaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHN0YXRlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJDb21wb25lbnRcIjtcbiAgICAgICAgX2luc3RhbmNlLnJlbmRlciB8fFxuICAgICAgICAgIChDb21wb25lbnQucHJvdG90eXBlICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJcbiAgICAgICAgICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/XCIsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyBpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICFfaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8XG4gICAgICAgICAgX2luc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fFxuICAgICAgICAgIF9pbnN0YW5jZS5zdGF0ZSB8fFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcImdldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiBUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuIERpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkP1wiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmXG4gICAgICAgICAgIV9pbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBfaW5zdGFuY2UuY29udGV4dFR5cGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q2hpbGRDb250ZXh0VHlwZXMuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dClcIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKSk7XG4gICAgICAgIENvbXBvbmVudC5jb250ZXh0VHlwZXMgJiZcbiAgICAgICAgICAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuaGFzKENvbXBvbmVudCkgJiZcbiAgICAgICAgICAoZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEuYWRkKENvbXBvbmVudCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIFVzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBzdGF0aWMgY29udGV4dFR5cGUgaW5zdGVhZC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvbGVnYWN5LWNvbnRleHQpXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyBUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIENvbXBvbmVudC5wcm90b3R5cGUgJiZcbiAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmXG4gICAgICAgICAgXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiBzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuIFBsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgXCJBIHB1cmUgY29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuIElmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCB1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciBydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlcyBoYXMgYSBtZXRob2QgY2FsbGVkIGNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT9cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgbGFuZSA9IF9pbnN0YW5jZS5wcm9wcyAhPT0gbmV4dFByb3BzO1xuICAgICAgICB2b2lkIDAgIT09IF9pbnN0YW5jZS5wcm9wcyAmJlxuICAgICAgICAgIGxhbmUgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyB1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIixcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgKTtcbiAgICAgICAgX2luc3RhbmNlLmRlZmF1bHRQcm9wcyAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlNldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy5cIixcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhDb21wb25lbnQpIHx8XG4gICAgICAgICAgKGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoQ29tcG9uZW50KSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiBUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpXG4gICAgICAgICAgKSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kIGFuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kLlwiLFxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICApO1xuICAgICAgICAobGFuZSA9IF9pbnN0YW5jZS5zdGF0ZSkgJiZcbiAgICAgICAgICAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGxhbmUgfHwgaXNBcnJheUltcGwobGFuZSkpICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIiVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbFwiLCBzdGF0ZSk7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgJiZcbiAgICAgICAgICBcIm9iamVjdFwiICE9PSB0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuXCIsXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfaW5zdGFuY2UucmVmcyA9IHt9O1xuICAgICAgICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBzdGF0ZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgX2luc3RhbmNlLmNvbnRleHQgPVxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBzdGF0ZSAmJiBudWxsICE9PSBzdGF0ZVxuICAgICAgICAgICAgPyByZWFkQ29udGV4dChzdGF0ZSlcbiAgICAgICAgICAgIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBfaW5zdGFuY2Uuc3RhdGUgPT09IG5leHRQcm9wcyAmJlxuICAgICAgICAgICgoc3RhdGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIkNvbXBvbmVudFwiKSxcbiAgICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoc3RhdGUpIHx8XG4gICAgICAgICAgICAoZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKHN0YXRlKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS5cIixcbiAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICkpKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSAmIDggJiZcbiAgICAgICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgX2luc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgX2luc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHN0YXRlID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc3RhdGUgJiZcbiAgICAgICAgICAoYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoX2luc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KSB8fFxuICAgICAgICAgICgoc3RhdGUgPSBfaW5zdGFuY2Uuc3RhdGUpLFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICBzdGF0ZSAhPT0gX2luc3RhbmNlLnN0YXRlICYmXG4gICAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCIlcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShcbiAgICAgICAgICAgICAgX2luc3RhbmNlLFxuICAgICAgICAgICAgICBfaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKSxcbiAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCksXG4gICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKTtcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpO1xuICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDY3MTA4ODY0KTtcbiAgICAgICAgX2luc3RhbmNlID0gITA7XG4gICAgICB9IGVsc2UgaWYgKG51bGwgPT09IGN1cnJlbnQkanNjb21wJDApIHtcbiAgICAgICAgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgbGFuZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgICAgICAgX2luc3RhbmNlLnByb3BzID0gbGFuZTtcbiAgICAgICAgdmFyIG9sZENvbnRleHQgPSBfaW5zdGFuY2UuY29udGV4dDtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IENvbXBvbmVudC5jb250ZXh0VHlwZTtcbiAgICAgICAgc3RhdGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBmb3VuZFdpbGxVcGRhdGVOYW1lICYmXG4gICAgICAgICAgbnVsbCAhPT0gZm91bmRXaWxsVXBkYXRlTmFtZSAmJlxuICAgICAgICAgIChzdGF0ZSA9IHJlYWRDb250ZXh0KGZvdW5kV2lsbFVwZGF0ZU5hbWUpKTtcbiAgICAgICAgbmV3QXBpTmFtZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgfHxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyAhPT0gdW5yZXNvbHZlZE9sZFByb3BzO1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHx8XG4gICAgICAgICAgKCh1bnJlc29sdmVkT2xkUHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gc3RhdGUpICYmXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIF9pbnN0YW5jZSxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9pbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgX2luc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgb2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkQ29udGV4dCB8fCBoYXNGb3JjZVVwZGF0ZVxuICAgICAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0FwaU5hbWUgJiZcbiAgICAgICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBuZXdBcGlOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAob2xkQ29udGV4dCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpKSxcbiAgICAgICAgICAgIChsYW5lID1cbiAgICAgICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGxhbmUsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZENvbnRleHQsXG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgPyAoZm91bmRXaWxsVXBkYXRlTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCksXG4gICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgICAgICAgICAgICBfaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpKVxuICAgICAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgJiZcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNjcxMDg4NjQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG9sZENvbnRleHQpKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5zdGF0ZSA9IG9sZENvbnRleHQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZS5jb250ZXh0ID0gc3RhdGUpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9IGxhbmUpKVxuICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDE2KSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA2NzEwODg2NCksXG4gICAgICAgICAgICAoX2luc3RhbmNlID0gITEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50JGpzY29tcCQwLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgc3RhdGUpO1xuICAgICAgICBfaW5zdGFuY2UucHJvcHMgPSBmb3VuZFdpbGxVcGRhdGVOYW1lO1xuICAgICAgICBuZXdBcGlOYW1lID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICBvbGRTdGF0ZSA9IF9pbnN0YW5jZS5jb250ZXh0O1xuICAgICAgICBvbGRDb250ZXh0ID0gQ29tcG9uZW50LmNvbnRleHRUeXBlO1xuICAgICAgICBsYW5lID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2xkQ29udGV4dCAmJlxuICAgICAgICAgIG51bGwgIT09IG9sZENvbnRleHQgJiZcbiAgICAgICAgICAobGFuZSA9IHJlYWRDb250ZXh0KG9sZENvbnRleHQpKTtcbiAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICAgICAgKG9sZENvbnRleHQgPVxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyB8fFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkgfHxcbiAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICAgICAoKHN0YXRlICE9PSBuZXdBcGlOYW1lIHx8IG9sZFN0YXRlICE9PSBsYW5lKSAmJlxuICAgICAgICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgKSk7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgICAgIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX2luc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBfaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBzdGF0ZSAhPT0gbmV3QXBpTmFtZSB8fFxuICAgICAgICBvbGRTdGF0ZSAhPT0gbmV3U3RhdGUgfHxcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgKG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcykpXG4gICAgICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdW5yZXNvbHZlZE9sZFByb3BzICYmXG4gICAgICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAobmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgICAgICAoZm91bmRXaWxsVXBkYXRlTmFtZSA9XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICBsYW5lXG4gICAgICAgICAgICAgICkgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcyAmJlxuICAgICAgICAgICAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50JGpzY29tcCQwLmRlcGVuZGVuY2llcykpKVxuICAgICAgICAgICAgICA/IChvbGRDb250ZXh0IHx8XG4gICAgICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV3U3RhdGUsIGxhbmUpLFxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAgIF9pbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZVxuICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCkpXG4gICAgICAgICAgICAgIDogKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIF9pbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgfHxcbiAgICAgICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50JGpzY29tcCQwLm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgICAoc3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlKSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZSksXG4gICAgICAgICAgICAoX2luc3RhbmNlLmNvbnRleHQgPSBsYW5lKSxcbiAgICAgICAgICAgIChfaW5zdGFuY2UgPSBmb3VuZFdpbGxVcGRhdGVOYW1lKSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBfaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgX2luc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHx8XG4gICAgICAgICAgICAgIChzdGF0ZSA9PT0gY3VycmVudCRqc2NvbXAkMC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUgPT09IGN1cnJlbnQkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgKF9pbnN0YW5jZSA9ICExKSk7XG4gICAgICB9XG4gICAgICBsYW5lID0gX2luc3RhbmNlO1xuICAgICAgbWFya1JlZihjdXJyZW50JGpzY29tcCQwLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzdGF0ZSA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gICAgICBpZiAobGFuZSB8fCBzdGF0ZSkge1xuICAgICAgICBsYW5lID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPVxuICAgICAgICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgICAgIGlzUmVuZGVyaW5nID0gITE7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgaWYgKHN0YXRlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IpXG4gICAgICAgICAgKENvbXBvbmVudCA9IG51bGwpLCAocHJvZmlsZXJTdGFydFRpbWUgPSAtMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBDb21wb25lbnQgPSBjYWxsUmVuZGVySW5ERVYobGFuZSk7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiA4KSB7XG4gICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYWxsUmVuZGVySW5ERVYobGFuZSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCRqc2NvbXAkMCAmJiBzdGF0ZVxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudCRqc2NvbXAkMC5jaGlsZCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSlcbiAgICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGxhbmUuc3RhdGU7XG4gICAgICAgIGN1cnJlbnQkanNjb21wJDAgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjdXJyZW50JGpzY29tcCQwID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgICBjdXJyZW50JGpzY29tcCQwLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIF9pbnN0YW5jZSAmJlxuICAgICAgICByZW5kZXJMYW5lcy5wcm9wcyAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgIChkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuXCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCBcImEgY29tcG9uZW50XCJcbiAgICAgICAgICApLFxuICAgICAgICAoZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICEwKSk7XG4gICAgICByZXR1cm4gY3VycmVudCRqc2NvbXAkMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICBuZXh0Q2hpbGRyZW4sXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjU2O1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICAgICAgQ29tcG9uZW50ICYmXG4gICAgICAgIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuXFxuICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLlwiLFxuICAgICAgICAgIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCBcIkNvbXBvbmVudFwiXG4gICAgICAgICk7XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoQ29tcG9uZW50KSB8fCBcIlVua25vd25cIiksXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbd29ya0luUHJvZ3Jlc3NdIHx8XG4gICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIiVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5cIixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFt3b3JrSW5Qcm9ncmVzc10gPVxuICAgICAgICAgICAgITApKSk7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlICYmXG4gICAgICAgIG51bGwgIT09IENvbXBvbmVudC5jb250ZXh0VHlwZSAmJlxuICAgICAgICAoKENvbXBvbmVudCA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8IFwiVW5rbm93blwiKSxcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W0NvbXBvbmVudF0gfHxcbiAgICAgICAgICAoY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuXCIsXG4gICAgICAgICAgICBDb21wb25lbnRcbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbQ29tcG9uZW50XSA9ICEwKSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIHtcbiAgICAgIHJldHVybiB7IGJhc2VMYW5lczogcmVuZGVyTGFuZXMsIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwcmltYXJ5VHJlZURpZERlZmVyLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5jaGlsZExhbmVzICYgfnJlbmRlckxhbmVzIDogMDtcbiAgICAgIHByaW1hcnlUcmVlRGlkRGVmZXIgJiYgKGN1cnJlbnQgfD0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsKHdvcmtJblByb2dyZXNzKSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgICAgIHZhciBzaG93RmFsbGJhY2sgPSAhMSxcbiAgICAgICAgZGlkU3VzcGVuZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCksXG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcDtcbiAgICAgIChKU0NvbXBpbGVyX3RlbXAgPSBkaWRTdXNwZW5kKSB8fFxuICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgPyAhMVxuICAgICAgICAgICAgOiAwICE9PSAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgJiYgKChzaG93RmFsbGJhY2sgPSAhMCksICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMTI5KSk7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAzMik7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgID8gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgOiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMDtcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSAhbmV4dEluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgICAgICA/ICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBkZWh5ZHJhdGVkOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAsXG4gICAgICAgICAgICAgICAgICAgIHRyZWVDb250ZXh0OlxuICAgICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHRyZWVDb250ZXh0UHJvdmlkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogdHJlZUNvbnRleHRJZCwgb3ZlcmZsb3c6IHRyZWVDb250ZXh0T3ZlcmZsb3cgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXRyeUxhbmU6IDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZCA9IGNyZWF0ZUZpYmVyKDE4LCBudWxsLCBudWxsLCBOb01vZGUpKSxcbiAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kLnN0YXRlTm9kZSA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCksXG4gICAgICAgICAgICAgICAgICAoZGlkU3VzcGVuZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBkaWRTdXNwZW5kKSxcbiAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gITApKVxuICAgICAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICExKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICFKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKTtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCAmJlxuICAgICAgICAgICAgICAod2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0SW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgKChuZXh0SW5zdGFuY2UgPSBuZXh0SW5zdGFuY2UuZGVoeWRyYXRlZCksIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhuZXh0SW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAxNilcbiAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0SW5zdGFuY2UgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgaWYgKHNob3dGYWxsYmFjaylcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgIHsgbW9kZTogXCJoaWRkZW5cIiwgY2hpbGRyZW46IG5leHRJbnN0YW5jZSB9LFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgIHNob3dGYWxsYmFjayxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZS5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dFByb3BzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXh0SW5zdGFuY2Uuc2libGluZyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2subWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgICAgICAgIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgJiZcbiAgICAgICAgKChuZXh0SW5zdGFuY2UgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuZGVoeWRyYXRlZCksXG4gICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgICAgICkge1xuICAgICAgICBpZiAoZGlkU3VzcGVuZClcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICAgICAgPyAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0yNTcpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKVxuICAgICAgICAgICAgOiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgICAgIDogKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoXG4gICAgICAgICAgICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuIH0sXG4gICAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0UHJvcHMuc2libGluZyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAobmV4dFByb3BzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcy5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHNob3dGYWxsYmFjaykpO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJXZSBzaG91bGQgbm90IGJlIGh5ZHJhdGluZyBoZXJlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhIGJ1Zy5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhuZXh0SW5zdGFuY2UpKVxuICAgICAgICApXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9XG4gICAgICAgICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMobmV4dEluc3RhbmNlKSksXG4gICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gbmV4dEluc3RhbmNlLmRpZ2VzdCksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dEluc3RhbmNlLm1lc3NhZ2UpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IG5leHRJbnN0YW5jZS5zdGFjayksXG4gICAgICAgICAgICAobmV4dEluc3RhbmNlID0gbmV4dEluc3RhbmNlLmNvbXBvbmVudFN0YWNrKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBzaG93RmFsbGJhY2tcbiAgICAgICAgICAgICAgPyBFcnJvcihzaG93RmFsbGJhY2spXG4gICAgICAgICAgICAgIDogRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlRoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgZHVlIHRvIGFuIGVycm9yIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLiBTd2l0Y2hlZCB0byBjbGllbnQgcmVuZGVyaW5nLlwiXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAoc2hvd0ZhbGxiYWNrLnN0YWNrID0gbmV4dFByb3BzIHx8IFwiXCIpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5kaWdlc3QgPSBKU0NvbXBpbGVyX3RlbXApLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IHZvaWQgMCA9PT0gbmV4dEluc3RhbmNlID8gbnVsbCA6IG5leHRJbnN0YW5jZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0ge1xuICAgICAgICAgICAgICB2YWx1ZTogc2hvd0ZhbGxiYWNrLFxuICAgICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICAgIHN0YWNrOiBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICBDYXB0dXJlZFN0YWNrcy5zZXQoc2hvd0ZhbGxiYWNrLCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihuZXh0UHJvcHMpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgICAgICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSB8fCBKU0NvbXBpbGVyX3RlbXApXG4gICAgICAgICkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gSlNDb21waWxlcl90ZW1wKSB7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSByZW5kZXJMYW5lcyAmIC1yZW5kZXJMYW5lcztcbiAgICAgICAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgNDIpKSBuZXh0UHJvcHMgPSAxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDE2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgY2FzZSAyNTY6XG4gICAgICAgICAgICAgICAgY2FzZSA1MTI6XG4gICAgICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgICAgIGNhc2UgMjA0ODpcbiAgICAgICAgICAgICAgICBjYXNlIDQwOTY6XG4gICAgICAgICAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICAgICAgICAgIGNhc2UgMTYzODQ6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjc2ODpcbiAgICAgICAgICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICAgICAgICAgIGNhc2UgMTMxMDcyOlxuICAgICAgICAgICAgICAgIGNhc2UgMjYyMTQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICAgICAgICAgIGNhc2UgMTA0ODU3NjpcbiAgICAgICAgICAgICAgICBjYXNlIDIwOTcxNTI6XG4gICAgICAgICAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICAgICAgICAgIGNhc2UgODM4ODYwODpcbiAgICAgICAgICAgICAgICBjYXNlIDE2Nzc3MjE2OlxuICAgICAgICAgICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMgPSA2NDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTM0MjE3NzI4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyA9IDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgICAgIDAgIT09IChuZXh0UHJvcHMgJiAoSlNDb21waWxlcl90ZW1wLnN1c3BlbmRlZExhbmVzIHwgcmVuZGVyTGFuZXMpKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogbmV4dFByb3BzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAwICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgbmV4dFByb3BzICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucmV0cnlMYW5lXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihKU0NvbXBpbGVyX3RlbXAsIGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKG5leHRJbnN0YW5jZSkgfHxcbiAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKG5leHRJbnN0YW5jZSlcbiAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkobmV4dEluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICAgICAgOiAoKGN1cnJlbnQgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAudHJlZUNvbnRleHQpLFxuICAgICAgICAgICAgICBzdXBwb3J0c0h5ZHJhdGlvbiAmJlxuICAgICAgICAgICAgICAgICgobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKSksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChpc0h5ZHJhdGluZyA9ICEwKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGRpZFN1c3BlbmRPckVycm9yREVWID0gITEpLFxuICAgICAgICAgICAgICAgIChoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICh3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQpLFxuICAgICAgICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdyksXG4gICAgICAgICAgICAgICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyKSxcbiAgICAgICAgICAgICAgICAgICh0cmVlQ29udGV4dElkID0gY3VycmVudC5pZCksXG4gICAgICAgICAgICAgICAgICAodHJlZUNvbnRleHRPdmVyZmxvdyA9IGN1cnJlbnQub3ZlcmZsb3cpLFxuICAgICAgICAgICAgICAgICAgKHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MDk2KSk7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cbiAgICAgIGlmIChzaG93RmFsbGJhY2spXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gbmV4dFByb3BzLmZhbGxiYWNrKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgICAgIChkaWRTdXNwZW5kID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnNpYmxpbmcpLFxuICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAsIHtcbiAgICAgICAgICAgIG1vZGU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgfSkpLFxuICAgICAgICAgIChuZXh0UHJvcHMuc3VidHJlZUZsYWdzID1cbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZFxuICAgICAgICAgICAgPyAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZGlkU3VzcGVuZCwgc2hvd0ZhbGxiYWNrKSlcbiAgICAgICAgICAgIDogKChzaG93RmFsbGJhY2sgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChzaG93RmFsbGJhY2suZmxhZ3MgfD0gMikpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgIChuZXh0UHJvcHMuc2libGluZyA9IHNob3dGYWxsYmFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAobmV4dFByb3BzID0gc2hvd0ZhbGxiYWNrKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgIChuZXh0SW5zdGFuY2UgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgIG51bGwgPT09IG5leHRJbnN0YW5jZVxuICAgICAgICAgICAgPyAobmV4dEluc3RhbmNlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgIDogKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBuZXh0SW5zdGFuY2UuY2FjaGVQb29sKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgPyAoKGRpZFN1c3BlbmQgPSBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgICAgICA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyKSxcbiAgICAgICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAucGFyZW50ICE9PSBkaWRTdXNwZW5kXG4gICAgICAgICAgICAgICAgICAgICAgPyB7IHBhcmVudDogZGlkU3VzcGVuZCwgcG9vbDogZGlkU3VzcGVuZCB9XG4gICAgICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKVxuICAgICAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGdldFN1c3BlbmRlZENhY2hlKCkpLFxuICAgICAgICAgICAgICAobmV4dEluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgIGJhc2VMYW5lczogbmV4dEluc3RhbmNlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIGNhY2hlUG9vbDogSlNDb21waWxlcl90ZW1wJGpzY29tcCQwXG4gICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAgIChzaG93RmFsbGJhY2suY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgKTtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICBjdXJyZW50ID0gcmVuZGVyTGFuZXMuc2libGluZztcbiAgICAgIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICAgICAgbW9kZTogXCJ2aXNpYmxlXCIsXG4gICAgICAgIGNoaWxkcmVuOiBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgICAgcmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMpLFxuICAgICAgICBudWxsID09PSBKU0NvbXBpbGVyX3RlbXBcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRdKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxNikpXG4gICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAucHVzaChjdXJyZW50KSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVuZGVyTGFuZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbikge1xuICAgICAgcHJpbWFyeUNoaWxkcmVuID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuIH0sXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1vZGVcbiAgICAgICk7XG4gICAgICBwcmltYXJ5Q2hpbGRyZW4ucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkcmVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCAwLCBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICBjdXJyZW50LFxuICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICByZW5kZXJMYW5lc1xuICAgICkge1xuICAgICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgIGN1cnJlbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuXG4gICAgICApO1xuICAgICAgY3VycmVudC5mbGFncyB8PSAyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGZpYmVyLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBmaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5sYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICBmaWJlci5yZXR1cm4sXG4gICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICAgICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXlJbXBsKGNoaWxkU2xvdCk7XG4gICAgICBjaGlsZFNsb3QgPSAhaXNBbkFycmF5ICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KTtcbiAgICAgIHJldHVybiBpc0FuQXJyYXkgfHwgY2hpbGRTbG90XG4gICAgICAgID8gKChpc0FuQXJyYXkgPSBpc0FuQXJyYXkgPyBcImFycmF5XCIgOiBcIml0ZXJhYmxlXCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkEgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluIGFuIGFkZGl0aW9uYWwgU3VzcGVuc2VMaXN0IHRvIGNvbmZpZ3VyZSBpdHMgcmV2ZWFsT3JkZXI6IDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gPC9TdXNwZW5zZUxpc3Q+XCIsXG4gICAgICAgICAgICBpc0FuQXJyYXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGlzQW5BcnJheVxuICAgICAgICAgICksXG4gICAgICAgICAgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgaXNCYWNrd2FyZHMsXG4gICAgICB0YWlsLFxuICAgICAgbGFzdENvbnRlbnRSb3csXG4gICAgICB0YWlsTW9kZVxuICAgICkge1xuICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgPT09IHJlbmRlclN0YXRlXG4gICAgICAgID8gKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICAgICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICAgICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICAgICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgICAgICAgIHRhaWw6IHRhaWwsXG4gICAgICAgICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICAgICAgICB9KVxuICAgICAgICA6ICgocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcyksXG4gICAgICAgICAgKHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93KSxcbiAgICAgICAgICAocmVuZGVyU3RhdGUudGFpbCA9IHRhaWwpLFxuICAgICAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyLFxuICAgICAgICB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKFxuICAgICAgICB2b2lkIDAgIT09IHJldmVhbE9yZGVyICYmXG4gICAgICAgIFwiZm9yd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgXCJ0b2dldGhlclwiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdXG4gICAgICApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9ICEwKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcmV2ZWFsT3JkZXIpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b2dldGhlclwiOlxuICAgICAgICAgICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICAgICAgICBjYXNlIFwiYmFja3dhcmRzXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZm9yd2FyZFwiOlxuICAgICAgICAgICAgY2FzZSBcImJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgICAgIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uIERpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsXG4gICAgICAgICAgICAgICAgcmV2ZWFsT3JkZXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHZvaWQgMCA9PT0gdGFpbE1vZGUgfHxcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdIHx8XG4gICAgICAgIChcImNvbGxhcHNlZFwiICE9PSB0YWlsTW9kZSAmJiBcImhpZGRlblwiICE9PSB0YWlsTW9kZVxuICAgICAgICAgID8gKChkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSAhMCksXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAnXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiBEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKVxuICAgICAgICAgIDogXCJmb3J3YXJkc1wiICE9PSByZXZlYWxPcmRlciAmJlxuICAgICAgICAgICAgXCJiYWNrd2FyZHNcIiAhPT0gcmV2ZWFsT3JkZXIgJiZcbiAgICAgICAgICAgICgoZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsXG4gICAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgICApKSk7XG4gICAgICBhOiBpZiAoXG4gICAgICAgIChcImZvcndhcmRzXCIgPT09IHJldmVhbE9yZGVyIHx8IFwiYmFja3dhcmRzXCIgPT09IHJldmVhbE9yZGVyKSAmJlxuICAgICAgICB2b2lkIDAgIT09IG5leHRQcm9wcyAmJlxuICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgITEgIT09IG5leHRQcm9wc1xuICAgICAgKVxuICAgICAgICBpZiAoaXNBcnJheUltcGwobmV4dFByb3BzKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5leHRQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKG5leHRQcm9wc1tpXSwgaSkpIGJyZWFrIGE7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKGkgPSBnZXRJdGVyYXRvckZuKG5leHRQcm9wcykpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpKSkge1xuICAgICAgICAgIGlmICgoaSA9IGkuY2FsbChuZXh0UHJvcHMpKSlcbiAgICAgICAgICAgIGZvciAodmFyIHN0ZXAgPSBpLm5leHQoKSwgX2kgPSAwOyAhc3RlcC5kb25lOyBzdGVwID0gaS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKHN0ZXAudmFsdWUsIF9pKSkgYnJlYWsgYTtcbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHNpbmdsZSByb3cgd2FzIHBhc3NlZCB0byBhIDxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9XCIlc1wiIC8+LiBUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JyxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyXG4gICAgICAgICAgKTtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIG5leHRQcm9wcyA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSlcbiAgICAgICAgKG5leHRQcm9wcyA9XG4gICAgICAgICAgKG5leHRQcm9wcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8IEZvcmNlU3VzcGVuc2VGYWxsYmFjayksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgIGE6IGZvciAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSBjdXJyZW50OyApIHtcbiAgICAgICAgICAgIGlmICgxMyA9PT0gY3VycmVudC50YWcpXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IHdvcmtJblByb2dyZXNzKSBicmVhayBhO1xuICAgICAgICAgICAgZm9yICg7IG51bGwgPT09IGN1cnJlbnQuc2libGluZzsgKSB7XG4gICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudC5zaWJsaW5nLnJldHVybiA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIG5leHRQcm9wcyAmPSBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbiAgICAgIH1cbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICAgIGNhc2UgXCJmb3J3YXJkc1wiOlxuICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgICAgICAoY3VycmVudCA9IHJlbmRlckxhbmVzLmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgICAgICAocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gKChyZXZlYWxPcmRlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbCkpXG4gICAgICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMSxcbiAgICAgICAgICAgIHJldmVhbE9yZGVyLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICB0YWlsTW9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IG51bGw7XG4gICAgICAgICAgcmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICBmb3IgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDsgbnVsbCAhPT0gcmV2ZWFsT3JkZXI7ICkge1xuICAgICAgICAgICAgY3VycmVudCA9IHJldmVhbE9yZGVyLmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgPT09IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5zaWJsaW5nO1xuICAgICAgICAgICAgcmV2ZWFsT3JkZXIuc2libGluZyA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSByZXZlYWxPcmRlcjtcbiAgICAgICAgICAgIHJldmVhbE9yZGVyID0gY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAhMCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHRhaWxNb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRvZ2V0aGVyXCI6XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCAhMSwgbnVsbCwgbnVsbCwgdm9pZCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKSB7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyk7XG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuICAgICAgaWYgKDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIDAgPT09IChyZW5kZXJMYW5lcyAmIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIG51bGw7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIGZvciAocmVuZGVyTGFuZXMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7IG51bGwgIT09IGN1cnJlbnQuc2libGluZzsgKVxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcgPVxuICAgICAgICAgICAgICBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcykpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ICYmIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSA/ICEwIDogITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKFxuICAgICAgY3VycmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgcmVuZGVyTGFuZXNcbiAgICApIHtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICApO1xuICAgICAgICAgIHB1c2hQcm92aWRlcihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ2FjaGVDb250ZXh0LFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDg7XG4gICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gLTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc3RhdGVOb2RlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgY3VycmVudCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgICAgICBzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcbiAgICAgICAgICBzdGF0ZU5vZGUgfHxcbiAgICAgICAgICAgIChwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIChzdGF0ZU5vZGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGVOb2RlKVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlkU3VzcGVuZEJlZm9yZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAgICAgKChkaWRTdXNwZW5kQmVmb3JlLnJlbmRlcmluZyA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUudGFpbCA9IG51bGwpLFxuICAgICAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoc3RhdGVOb2RlKSBicmVhaztcbiAgICAgICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwKSxcbiAgICAgICAgICAgIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENhY2hlQ29udGV4dCxcbiAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5rZXksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lc1xuICAgICAgICApO1xuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgICAgIGlmIChudWxsID09PSByZXR1cm5GaWJlcikgdGhyb3cgRXJyb3IoXCJDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci5cIik7XG4gICAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICAgICAgcmVuZGVyTGFuZXMuaW5kZXggPSB3b3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICAgICAgcmVuZGVyTGFuZXMuc2libGluZyA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgICAgIHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAgICAgcmVuZGVyTGFuZXMucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgICAgICByZW5kZXJMYW5lcy5fZGVidWdJbmZvID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbztcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZClcbiAgICAgICAgICByZXR1cm5GaWJlci5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcHJldlNpYmxpbmcpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuXCIpO1xuICAgICAgICAgIGZvciAoOyBwcmV2U2libGluZy5zaWJsaW5nICE9PSB3b3JrSW5Qcm9ncmVzczsgKVxuICAgICAgICAgICAgaWYgKCgocHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nKSwgbnVsbCA9PT0gcHJldlNpYmxpbmcpKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuXCIpO1xuICAgICAgICAgIHByZXZTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJMYW5lcztcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcbiAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICA/ICgocmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdKSwgKHJldHVybkZpYmVyLmZsYWdzIHw9IDE2KSlcbiAgICAgICAgICA6IHdvcmtJblByb2dyZXNzLnB1c2goY3VycmVudCk7XG4gICAgICAgIHJlbmRlckxhbmVzLmZsYWdzIHw9IDI7XG4gICAgICAgIHJldHVybiByZW5kZXJMYW5lcztcbiAgICAgIH1cbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50KVxuICAgICAgICBpZiAoXG4gICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgfHxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGVcbiAgICAgICAgKVxuICAgICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSAhMDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAgICAgICBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSA/ICEwIDogITE7XG4gICAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gITE7XG4gICAgICAgIGlmICgocmV0dXJuRmliZXIgPSBpc0h5ZHJhdGluZykpXG4gICAgICAgICAgd2FybklmTm90SHlkcmF0aW5nKCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMDQ4NTc2KSk7XG4gICAgICAgIHJldHVybkZpYmVyICYmXG4gICAgICAgICAgKChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLmluZGV4KSxcbiAgICAgICAgICB3YXJuSWZOb3RIeWRyYXRpbmcoKSxcbiAgICAgICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0cmVlRm9ya0NvdW50LCByZXR1cm5GaWJlcikpO1xuICAgICAgfVxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICBhOiBpZiAoXG4gICAgICAgICAgICAoKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChjdXJyZW50ID0gY2FsbExhenlJbml0SW5ERVYod29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50KVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHNob3VsZENvbnN0cnVjdChjdXJyZW50KVxuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQgPVxuICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogKCh3b3JrSW5Qcm9ncmVzcy50YWcgPSAwKSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudCkpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApKSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0gY3VycmVudC4kJHR5cGVvZiksXG4gICAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IDExO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50ID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTaWJsaW5nID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBcIlwiO1xuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudCAmJlxuICAgICAgICAgICAgICBjdXJyZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgICAgICBcIiBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlP1wiKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3VycmVudCkgfHwgY3VycmVudDtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgK1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgK1xuICAgICAgICAgICAgICAgIFwiLiBMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgcHVzaEhvc3RDb250YWluZXIoXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgIHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcHJldlNpYmxpbmcuZWxlbWVudDtcbiAgICAgICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgIT09IHByZXZTaWJsaW5nLmNhY2hlICYmXG4gICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICEwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgICAgICAgICBuZXh0UHJvcHMgPSBuZXh0U3RhdGUuZWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c0h5ZHJhdGlvbiAmJiBwcmV2U2libGluZy5pc0RlaHlkcmF0ZWQpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHByZXZTaWJsaW5nID0ge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudDogbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgaXNEZWh5ZHJhdGVkOiAhMSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFByb3BzICE9PSByZXR1cm5GaWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoXG4gICAgICAgICAgICAgICAgICBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIHJvb3QgcmVjZWl2ZWQgYW4gZWFybHkgdXBkYXRlLCBiZWZvcmUgYW55dGhpbmcgd2FzIGFibGUgaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgKChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID1cbiAgICAgICAgICAgICAgICAgICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKGlzSHlkcmF0aW5nID0gITApLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChkaWRTdXNwZW5kT3JFcnJvckRFViA9ICExKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITApKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG1vdW50Q2hpbGRGaWJlcnMoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgY3VycmVudDtcblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50LmZsYWdzID0gKGN1cnJlbnQuZmxhZ3MgJiAtMykgfCA0MDk2KSxcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmcpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgICAgICAgaWYgKG5leHRQcm9wcyA9PT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyAoY3VycmVudCA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudClcbiAgICAgICAgICAgICAgICAgIDogaXNIeWRyYXRpbmcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBnZXRSZXNvdXJjZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucylcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSByZXF1aXJlZENvbnRleHQoXG4gICAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKHJldHVybkZpYmVyID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBkaWRTdXNwZW5kT3JFcnJvckRFViB8fFxuICAgICAgICAgICAgICAgICAgKChyZXR1cm5GaWJlciA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIpKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocHJldlNpYmxpbmcpKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgfHwgaXNIeWRyYXRpbmdcbiAgICAgICAgICAgICAgICA/IHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgICAgICgobmV4dFByb3BzID0gZ2V0SG9zdENvbnRleHQoKSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wc1xuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSksXG4gICAgICAgICAgICAgIChuZXh0U3RhdGUgPSAhcHJldlNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICAgKChuZXh0U3RhdGUgPSBjYW5IeWRyYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFN0YXRlXG4gICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV4dFN0YXRlKSxcbiAgICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgfHxcbiAgICAgICAgICAgICAgICAgICAgICAoKG5leHRQcm9wcyA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVpbGRIeWRyYXRpb25EaWZmTm9kZSh3b3JrSW5Qcm9ncmVzcywgMCkuc2VydmVyUHJvcHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHMpKSxcbiAgICAgICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dFN0YXRlKSksXG4gICAgICAgICAgICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgICAgICAgICAgICAobmV4dFByb3BzID0gITApKVxuICAgICAgICAgICAgICAgICAgOiAobmV4dFByb3BzID0gITEpLFxuICAgICAgICAgICAgICAgIChuZXh0U3RhdGUgPSAhbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgIG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByZXZTaWJsaW5nKSxcbiAgICAgICAgICAgICAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpKSksXG4gICAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChuZXh0U3RhdGUgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbCksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBuZXh0UHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQocHJldlNpYmxpbmcsIG5leHRQcm9wcylcbiAgICAgICAgICAgICAgPyAocmV0dXJuRmliZXIgPSBudWxsKVxuICAgICAgICAgICAgICA6IG51bGwgIT09IG5leHRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KHByZXZTaWJsaW5nLCBuZXh0U3RhdGUpICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDMyKSxcbiAgICAgICAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgKChwcmV2U2libGluZyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICAgICAgICAgID8gKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gcHJldlNpYmxpbmcpXG4gICAgICAgICAgICAgICAgOiAoSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gcHJldlNpYmxpbmcpKSxcbiAgICAgICAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UoY3VycmVudCwgcmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSksXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICFyZW5kZXJMYW5lcykgfHxcbiAgICAgICAgICAgICAgICAoKHJldHVybkZpYmVyID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICEwKSlcbiAgICAgICAgICAgICAgICAgIDogKHJldHVybkZpYmVyID0gITEpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9ICFyZXR1cm5GaWJlcikpLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICAgIChjdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaCh3b3JrSW5Qcm9ncmVzcykpKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgIDogcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlci5lZmZlY3REdXJhdGlvbiA9IC0wKSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlci5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnR5cGUpLFxuICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMgPSBwcmV2U2libGluZy52YWx1ZSksXG4gICAgICAgICAgICBcInZhbHVlXCIgaW4gcHJldlNpYmxpbmcgfHxcbiAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgfHxcbiAgICAgICAgICAgICAgKChoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9ICEwKSxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlRoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD9cIlxuICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgcmV0dXJuRmliZXIsIG5leHRQcm9wcyksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHByZXZTaWJsaW5nLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0KSxcbiAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbiksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiByZXR1cm5GaWJlciAmJlxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkIHRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgdGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlIGlzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChwcmV2U2libGluZyA9IHJlYWRDb250ZXh0KHByZXZTaWJsaW5nKSksXG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBjYWxsQ29tcG9uZW50SW5ERVYoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgdm9pZCAwXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpKSxcbiAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAoKHByZXZTaWJsaW5nID0gcGVla0NhY2hlRnJvbVBvb2woKSksXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gcHJldlNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAgICgocHJldlNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QpLFxuICAgICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUNhY2hlKCkpLFxuICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nLnBvb2xlZENhY2hlID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgICAgICAgIHJldGFpbkNhY2hlKG5leHRQcm9wcyksXG4gICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nLnBvb2xlZENhY2hlTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAgICAgKHByZXZTaWJsaW5nID0gbmV4dFByb3BzKSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQ6IHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgY2FjaGU6IHByZXZTaWJsaW5nXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcHJldlNpYmxpbmcpKVxuICAgICAgICAgICAgICA6ICgwICE9PSAoY3VycmVudC5sYW5lcyAmIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgICAgICAgKGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBudWxsLCBudWxsLCByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkpLFxuICAgICAgICAgICAgICAgIChwcmV2U2libGluZyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLnBhcmVudCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgID8gKChwcmV2U2libGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGNhY2hlOiByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBwcmV2U2libGluZyksXG4gICAgICAgICAgICAgICAgICAgIDAgPT09IHdvcmtJblByb2dyZXNzLmxhbmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlNpYmxpbmcpLFxuICAgICAgICAgICAgICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmV0dXJuRmliZXIpKVxuICAgICAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gbmV4dFByb3BzLmNhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IHByZXZTaWJsaW5nLmNhY2hlICYmXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICAgICAgICAgICkpKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICB0aHJvdyB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgK1xuICAgICAgICAgIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCkge1xuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICAgICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gICAgICBpc1ByaW1hcnlSZW5kZXJlclxuICAgICAgICA/IChwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXJDdXJzb3JERVYsIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgdm9pZCAwICE9PSBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAmJlxuICAgICAgICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkRldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSBzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsKSlcbiAgICAgICAgOiAocHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWUpLFxuICAgICAgICAgIHB1c2gocmVuZGVyZXIyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyLCBwcm92aWRlckZpYmVyKSxcbiAgICAgICAgICB2b2lkIDAgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgJiZcbiAgICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlIHNhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICAgICAgaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyAoKGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgKGN1cnJlbnRWYWx1ZSA9IHJlbmRlcmVyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlckN1cnNvckRFViwgcHJvdmlkZXJGaWJlciksXG4gICAgICAgICAgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IGN1cnJlbnRWYWx1ZSkpXG4gICAgICAgIDogKChjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlKSxcbiAgICAgICAgICAoY3VycmVudFZhbHVlID0gcmVuZGVyZXIyQ3Vyc29yREVWLmN1cnJlbnQpLFxuICAgICAgICAgIHBvcChyZW5kZXJlcjJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpLFxuICAgICAgICAgIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gY3VycmVudFZhbHVlKSk7XG4gICAgICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgcGFyZW50LFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBwcm9wYWdhdGlvblJvb3RcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICB2YXIgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgICAgKHBhcmVudC5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgID8gKChwYXJlbnQuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSlcbiAgICAgICAgICA6IG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKGFsdGVybmF0ZS5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHJvcGFnYXRpb25Sb290KSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudCAhPT0gcHJvcGFnYXRpb25Sb290ICYmXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIHRoZSBwcm9wYWdhdGlvbiByb290IHdoZW4gc2NoZWR1bGluZyBjb250ZXh0IHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGNvbnRleHRzLFxuICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgbnVsbCAhPT0gZmliZXIgJiYgKGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGZvciAoOyBudWxsICE9PSBmaWJlcjsgKSB7XG4gICAgICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuICAgICAgICBpZiAobnVsbCAhPT0gbGlzdCkge1xuICAgICAgICAgIHZhciBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgICBsaXN0ID0gbGlzdC5maXJzdENvbnRleHQ7XG4gICAgICAgICAgYTogZm9yICg7IG51bGwgIT09IGxpc3Q7ICkge1xuICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0O1xuICAgICAgICAgICAgbGlzdCA9IGZpYmVyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZXh0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dHNbaV0pIHtcbiAgICAgICAgICAgICAgICBsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSBsaXN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmN5ICYmIChkZXBlbmRlbmN5LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKFxuICAgICAgICAgICAgICAgICAgbGlzdC5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUgfHwgKG5leHRGaWJlciA9IG51bGwpO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKDE4ID09PSBmaWJlci50YWcpIHtcbiAgICAgICAgICBuZXh0RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5leHRGaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIldlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgbmV4dEZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgICAgIGxpc3QgPSBuZXh0RmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIG51bGwgIT09IGxpc3QgJiYgKGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICBuZXh0RmliZXIsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2UgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXh0RmliZXIpIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobmV4dEZpYmVyID0gZmliZXI7IG51bGwgIT09IG5leHRGaWJlcjsgKSB7XG4gICAgICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpYmVyID0gbmV4dEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgZmliZXIucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgIGN1cnJlbnQsXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgKSB7XG4gICAgICBjdXJyZW50ID0gbnVsbDtcbiAgICAgIGZvciAoXG4gICAgICAgIHZhciBwYXJlbnQgPSB3b3JrSW5Qcm9ncmVzcywgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMTtcbiAgICAgICAgbnVsbCAhPT0gcGFyZW50O1xuXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dClcbiAgICAgICAgICBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDUyNDI4OCkpIGlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0ID0gITA7XG4gICAgICAgICAgZWxzZSBpZiAoMCAhPT0gKHBhcmVudC5mbGFncyAmIDI2MjE0NCkpIGJyZWFrO1xuICAgICAgICBpZiAoMTAgPT09IHBhcmVudC50YWcpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBwYXJlbnQudHlwZTtcbiAgICAgICAgICAgIG9iamVjdElzKHBhcmVudC5wZW5kaW5nUHJvcHMudmFsdWUsIGN1cnJlbnRQYXJlbnQudmFsdWUpIHx8XG4gICAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50XG4gICAgICAgICAgICAgICAgPyBjdXJyZW50LnB1c2goY29udGV4dClcbiAgICAgICAgICAgICAgICA6IChjdXJyZW50ID0gW2NvbnRleHRdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCA9PT0gaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5tZW1vaXplZFN0YXRlLm1lbW9pemVkU3RhdGUgIT09XG4gICAgICAgICAgICBwYXJlbnQubWVtb2l6ZWRTdGF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IGN1cnJlbnQucHVzaChIb3N0VHJhbnNpdGlvbkNvbnRleHQpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnQgPSBbSG9zdFRyYW5zaXRpb25Db250ZXh0XSkpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4gICAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyNjIxNDQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50RGVwZW5kZW5jaWVzKSB7XG4gICAgICBmb3IgKFxuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG4gICAgICAgIG51bGwgIT09IGN1cnJlbnREZXBlbmRlbmNpZXM7XG5cbiAgICAgICkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGN1cnJlbnREZXBlbmRlbmNpZXMuY29udGV4dDtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvYmplY3RJcyhcbiAgICAgICAgICAgIGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgIGN1cnJlbnREZXBlbmRlbmNpZXMubWVtb2l6ZWRWYWx1ZVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG4gICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcyAmJiAod29ya0luUHJvZ3Jlc3MuZmlyc3RDb250ZXh0ID0gbnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgJiZcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24oY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgICAgIG51bGwgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICYmIHByZXBhcmVUb1JlYWRDb250ZXh0KGNvbnN1bWVyKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICAgICAgdmFyIHZhbHVlID0gaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgPyBjb250ZXh0Ll9jdXJyZW50VmFsdWVcbiAgICAgICAgOiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgY29udGV4dCA9IHsgY29udGV4dDogY29udGV4dCwgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsIG5leHQ6IG51bGwgfTtcbiAgICAgIGlmIChudWxsID09PSBsYXN0Q29udGV4dERlcGVuZGVuY3kpIHtcbiAgICAgICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiBJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS5cIlxuICAgICAgICAgICk7XG4gICAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgICBsYW5lczogMCxcbiAgICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgX2RlYnVnVGhlbmFibGVTdGF0ZTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdW1lci5mbGFncyB8PSA1MjQyODg7XG4gICAgICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgICAgICBkYXRhOiBuZXcgTWFwKCksXG4gICAgICAgIHJlZkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCAmJlxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICBjYWNoZS5yZWZDb3VudCsrO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnJlZkNvdW50LS07XG4gICAgICAwID4gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuIFRoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQxKE5vcm1hbFByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVla0NhY2hlRnJvbVBvb2woKSB7XG4gICAgICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCAhPT0gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgID8gY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyXG4gICAgICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoVHJhbnNpdGlvbihvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCkge1xuICAgICAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgICAgICA/IHB1c2gocmVzdW1lZENhY2hlLCByZXN1bWVkQ2FjaGUuY3VycmVudCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgICAgIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgICAgIHJldHVybiBudWxsID09PSBjYWNoZUZyb21Qb29sXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICAgICAgICAgIHBvb2w6IGNhY2hlRnJvbVBvb2xcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQpIHJldHVybiAhMTtcbiAgICAgIGlmICgwICE9PSAoY29tcGxldGVkV29yay5mbGFncyAmIDE2KSkgcmV0dXJuICEwO1xuICAgICAgZm9yIChjdXJyZW50ID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzODc4KSB8fFxuICAgICAgICAgIDAgIT09IChjdXJyZW50LnN1YnRyZWVGbGFncyAmIDEzODc4KVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihcbiAgICAgIHBhcmVudCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgaXNIaWRkZW5cbiAgICApIHtcbiAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIG51bGwgIT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZTtcblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICA1ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnIHx8XG4gICAgICAgICAgICA2ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICA0ID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUudGFnIHx8XG4gICAgICAgICAgICAgIChzdXBwb3J0c1NpbmdsZXRvbnMgJiYgMjcgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS50YWcpXG4gICAgICAgICAgICApICYmXG4gICAgICAgICAgICBudWxsICE9PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5jaGlsZC5yZXR1cm4gPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuY2hpbGQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG51bGwgPT09IG5lZWRzVmlzaWJpbGl0eVRvZ2dsZS5yZXR1cm4gfHxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnNpYmxpbmcucmV0dXJuID0gbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLnJldHVybjtcbiAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSBuZWVkc1Zpc2liaWxpdHlUb2dnbGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSlcbiAgICAgICAgZm9yICh2YXIgX25vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gX25vZGU7ICkge1xuICAgICAgICAgIGlmICg1ID09PSBfbm9kZS50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICBpc0hpZGRlbiAmJlxuICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIF9ub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgX25vZGUubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IF9ub2RlLnRhZylcbiAgICAgICAgICAgIChpbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZSksXG4gICAgICAgICAgICAgIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJlxuICAgICAgICAgICAgICAgIGlzSGlkZGVuICYmXG4gICAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgIF9ub2RlLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIGVsc2UgaWYgKDQgIT09IF9ub2RlLnRhZylcbiAgICAgICAgICAgIGlmICgyMiA9PT0gX25vZGUudGFnICYmIG51bGwgIT09IF9ub2RlLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IF9ub2RlLmNoaWxkKSxcbiAgICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJiAoaW5zdGFuY2UucmV0dXJuID0gX25vZGUpLFxuICAgICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgX25vZGUsICEwLCAhMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChudWxsICE9PSBfbm9kZS5jaGlsZCkge1xuICAgICAgICAgICAgICBfbm9kZS5jaGlsZC5yZXR1cm4gPSBfbm9kZTtcbiAgICAgICAgICAgICAgX25vZGUgPSBfbm9kZS5jaGlsZDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9ub2RlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IF9ub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IF9ub2RlLnJldHVybiB8fCBfbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBfbm9kZSA9IF9ub2RlLnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX25vZGUuc2libGluZy5yZXR1cm4gPSBfbm9kZS5yZXR1cm47XG4gICAgICAgICAgX25vZGUgPSBfbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoXG4gICAgICBjb250YWluZXJDaGlsZFNldCxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgaXNIaWRkZW5cbiAgICApIHtcbiAgICAgIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKVxuICAgICAgICBmb3IgKHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IG5vZGU7ICkge1xuICAgICAgICAgIGlmICg1ID09PSBub2RlLnRhZykge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiZcbiAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgKGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICg2ID09PSBub2RlLnRhZylcbiAgICAgICAgICAgIChpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmXG4gICAgICAgICAgICAgICAgaXNIaWRkZW4gJiZcbiAgICAgICAgICAgICAgICAoaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgbm9kZS5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgICAgIGVsc2UgaWYgKDQgIT09IG5vZGUudGFnKVxuICAgICAgICAgICAgaWYgKDIyID09PSBub2RlLnRhZyAmJiBudWxsICE9PSBub2RlLm1lbW9pemVkU3RhdGUpXG4gICAgICAgICAgICAgIChpbnN0YW5jZSA9IG5vZGUuY2hpbGQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGluc3RhbmNlICYmIChpbnN0YW5jZS5yZXR1cm4gPSBub2RlKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICAgICAgY29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gbm9kZS5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICAgIFwibWFudWFsXCIgPT09IG5vZGUubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gbm9kZS5jaGlsZCkge1xuICAgICAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrO1xuICAgICAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IG5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29udGFpbmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gY3VycmVudC5jb250YWluZXJJbmZvLFxuICAgICAgICAgIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKTtcbiAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsICExLCAhMSk7XG4gICAgICAgIGN1cnJlbnQucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcykge1xuICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pXG4gICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZSxcbiAgICAgICAgICBfb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoY3VycmVudCA9IGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpKSB8fFxuICAgICAgICAgIF9vbGRQcm9wcyAhPT0gbmV3UHJvcHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgX29sZFByb3BzID0gY2xvbmVJbnN0YW5jZShcbiAgICAgICAgICAgIGN1cnJlbnRJbnN0YW5jZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBfb2xkUHJvcHMsXG4gICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICFjdXJyZW50LFxuICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgX29sZFByb3BzID09PSBjdXJyZW50SW5zdGFuY2VcbiAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZSlcbiAgICAgICAgICAgIDogKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKFxuICAgICAgICAgICAgICAgIF9vbGRQcm9wcyxcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIb3N0Q29udGV4dFxuICAgICAgICAgICAgICApICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX29sZFByb3BzKSxcbiAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgID8gYXBwZW5kQWxsQ2hpbGRyZW4oX29sZFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgITEsICExKVxuICAgICAgICAgICAgICAgIDogbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICB9IGVsc2Ugd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAobWF5U3VzcGVuZENvbW1pdCh0eXBlLCBwcm9wcykpIHtcbiAgICAgICAgaWYgKCgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLCAhcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKSkpXG4gICAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCByZXNvdXJjZSkge1xuICAgICAgaWYgKG1heVJlc291cmNlU3VzcGVuZENvbW1pdChyZXNvdXJjZSkpIHtcbiAgICAgICAgaWYgKCgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTY3NzcyMTYpLCAhcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSkpXG4gICAgICAgICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAgICgoc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUpLFxuICAgICAgICAgICAgICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pXG4gICAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICAgICAgbnVsbCAhPT0gcmV0cnlRdWV1ZSAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgICAgICgocmV0cnlRdWV1ZSA9XG4gICAgICAgICAgMjIgIT09IHdvcmtJblByb2dyZXNzLnRhZyA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogNTM2ODcwOTEyKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzIHw9IHJldHJ5UXVldWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgICAgIGlmICghaXNIeWRyYXRpbmcpXG4gICAgICAgIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgICAgICBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgICAgZm9yICh2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDsgbnVsbCAhPT0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrOyApXG4gICAgICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAobGFzdFRhaWxOb2RlID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSxcbiAgICAgICAgICAgICAgICAoaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrID0gaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrLnNpYmxpbmcpO1xuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICA6IChsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNvbGxhcHNlZFwiOlxuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICAgIGZvciAodmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbGFzdFRhaWxOb2RlLmFsdGVybmF0ZSAmJiAoX2xhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZSksXG4gICAgICAgICAgICAgICAgKGxhc3RUYWlsTm9kZSA9IGxhc3RUYWlsTm9kZS5zaWJsaW5nKTtcbiAgICAgICAgICAgIG51bGwgPT09IF9sYXN0VGFpbE5vZGVcbiAgICAgICAgICAgICAgPyBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgfHwgbnVsbCA9PT0gcmVuZGVyU3RhdGUudGFpbFxuICAgICAgICAgICAgICAgID8gKHJlbmRlclN0YXRlLnRhaWwgPSBudWxsKVxuICAgICAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgICAgIDogKF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICAgICAgdmFyIGRpZEJhaWxvdXQgPVxuICAgICAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQsXG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSAwLFxuICAgICAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICAgICAgaWYgKGRpZEJhaWxvdXQpXG4gICAgICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICB2YXIgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb24sXG4gICAgICAgICAgICAgIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICAgICAgICAgICAgbnVsbCAhPT0gX2NoaWxkMjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9IF9jaGlsZDIubGFuZXMgfCBfY2hpbGQyLmNoaWxkTGFuZXMpLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuZmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiArPSBfY2hpbGQyLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgICAoX2NoaWxkMiA9IF9jaGlsZDIuc2libGluZyk7XG4gICAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIChuZXdDaGlsZExhbmVzIHw9XG4gICAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gX3RyZWVCYXNlRHVyYXRpb24uc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAgICAgICAoX3RyZWVCYXNlRHVyYXRpb24ucmV0dXJuID0gY29tcGxldGVkV29yayksXG4gICAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgZWxzZSBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIDIpICE9PSBOb01vZGUpIHtcbiAgICAgICAgX3RyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICBfY2hpbGQyID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgICBmb3IgKHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7IG51bGwgIT09IGNoaWxkOyApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD0gY2hpbGQubGFuZXMgfCBjaGlsZC5jaGlsZExhbmVzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzKSxcbiAgICAgICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3MpLFxuICAgICAgICAgICAgKF90cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSxcbiAgICAgICAgICAgIChfY2hpbGQyICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb24pLFxuICAgICAgICAgICAgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX2NoaWxkMjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgICAgICAgICBudWxsICE9PSBfdHJlZUJhc2VEdXJhdGlvbjtcblxuICAgICAgICApXG4gICAgICAgICAgKG5ld0NoaWxkTGFuZXMgfD1cbiAgICAgICAgICAgIF90cmVlQmFzZUR1cmF0aW9uLmxhbmVzIHwgX3RyZWVCYXNlRHVyYXRpb24uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLnN1YnRyZWVGbGFncyksXG4gICAgICAgICAgICAoc3VidHJlZUZsYWdzIHw9IF90cmVlQmFzZUR1cmF0aW9uLmZsYWdzKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgICAgIChfdHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uLnNpYmxpbmcpO1xuICAgICAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICAgICAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbiAgICAgIHJldHVybiBkaWRCYWlsb3V0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKG5ld1Byb3BzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwNDgpO1xuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJlbmRlckxhbmVzLnBlbmRpbmdDb250ZXh0ICYmXG4gICAgICAgICAgICAoKHJlbmRlckxhbmVzLmNvbnRleHQgPSByZW5kZXJMYW5lcy5wZW5kaW5nQ29udGV4dCksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQgfHwgbnVsbCA9PT0gY3VycmVudC5jaGlsZClcbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICA/IChlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCksIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICA6IG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMjU2KSkgfHxcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEwMjQpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgICAgIChoeWRyYXRpb25FcnJvcnMgPSBudWxsKSkpO1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgICAgdmFyIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgICAgID8gKG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZVxuICAgICAgICAgICAgICAgICAgPyAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogKGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICAgIDogbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgPyBuZXh0UmVzb3VyY2UgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQoXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICA6IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpXG4gICAgICAgICAgICAgICAgOiAoc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICA6IHVwZGF0ZUhvc3RDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZW5kZXJMYW5lcyA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgICAgID8gY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZUhvc3RDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgPyBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KVxuICAgICAgICAgICAgICAgIDogKChjdXJyZW50ID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICBuZXh0UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMsIG5ld1Byb3BzKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgID8gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudClcbiAgICAgICAgICAgICAgOiAoKG5leHRSZXNvdXJjZSA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gY3JlYXRlSW5zdGFuY2UoXG4gICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLFxuICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLFxuICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV4dFJlc291cmNlLCB3b3JrSW5Qcm9ncmVzcywgITEsICExKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV4dFJlc291cmNlKSxcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSxcbiAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICAgICAgKSAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZChcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgICAgIHN1cHBvcnRzTXV0YXRpb25cbiAgICAgICAgICAgICAgICA/IHJlbmRlckxhbmVzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIDogc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzICE9PSBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICA/ICgoY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBnZXRIb3N0Q29udGV4dCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiZcbiAgICAgICAgICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY3VycmVudCA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgICAgICAgIHJlbmRlckxhbmVzID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9ICFkaWRTdXNwZW5kT3JFcnJvckRFVjtcbiAgICAgICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKHdvcmtJblByb2dyZXNzLCAwKS5zZXJ2ZXJQcm9wcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChuZXh0UmVzb3VyY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICApLnNlcnZlclByb3BzID0gbmV4dFJlc291cmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoeWRyYXRlVGV4dEluc3RhbmNlKFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNcbiAgICAgICAgICAgICAgKSB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShcbiAgICAgICAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dFJlc291cmNlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IG5ld1Byb3BzICYmIG51bGwgIT09IG5ld1Byb3BzLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgd2FzIGNvbXBsZXRlZCB3aXRob3V0IGEgaHlkcmF0ZWQgbm9kZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgbmV4dFJlc291cmNlID1cbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSA/IG5leHRSZXNvdXJjZS5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShuZXh0UmVzb3VyY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAoKG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgIG5leHRSZXNvdXJjZS50cmVlQmFzZUR1cmF0aW9uKSk7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKSxcbiAgICAgICAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzICYmXG4gICAgICAgICAgICAgICAgICAgICgobmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBuZXh0UmVzb3VyY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJlc291cmNlLnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgbmV4dFJlc291cmNlID0gITE7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgbnVsbCAhPT0gaHlkcmF0aW9uRXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSxcbiAgICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpLFxuICAgICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UgPSAhMCk7XG4gICAgICAgICAgICBpZiAoIW5leHRSZXNvdXJjZSkge1xuICAgICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSlcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIHJlbmRlckxhbmVzID0gbnVsbCAhPT0gbmV3UHJvcHM7XG4gICAgICAgICAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKG5leHRSZXNvdXJjZSA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV4dFJlc291cmNlID0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbnVsbCksXG4gICAgICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IG5ld1Byb3BzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIgIT09IG5leHRSZXNvdXJjZSAmJiAobmV3UHJvcHMuZmxhZ3MgfD0gMjA0OCkpO1xuICAgICAgICAgIHJlbmRlckxhbmVzICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkLmZsYWdzIHw9IDgxOTIpO1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgIHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbikpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gbmV4dFJlc291cmNlKVxuICAgICAgICAgICAgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICAgIG5ld1Byb3BzID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KTtcbiAgICAgICAgICByZXR1cm5GaWJlciA9IG5leHRSZXNvdXJjZS5yZW5kZXJpbmc7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgaWYgKG5ld1Byb3BzKSBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RJblByb2dyZXNzIHx8XG4gICAgICAgICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIgPSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gcmV0dXJuRmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4O1xuICAgICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQobmV4dFJlc291cmNlLCAhMSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXR1cm5GaWJlci51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgICAoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50ICZcbiAgICAgICAgICAgICAgICAgICAgICAgIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG51bGwgIT09IG5leHRSZXNvdXJjZS50YWlsICYmXG4gICAgICAgICAgICAgICAgbm93JDEoKSA+IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgJiZcbiAgICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmluZEZpcnN0U3VzcGVuZGVkKHJldHVybkZpYmVyKSksIG51bGwgIT09IGN1cnJlbnQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKG5leHRSZXNvdXJjZSwgITApLFxuICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV4dFJlc291cmNlLnRhaWwgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJoaWRkZW5cIiA9PT0gbmV4dFJlc291cmNlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZXR1cm5GaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSHlkcmF0aW5nKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgMiAqIG5vdyQxKCkgLSBuZXh0UmVzb3VyY2UucmVuZGVyaW5nU3RhcnRUaW1lID5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgJiZcbiAgICAgICAgICAgICAgICAgIDUzNjg3MDkxMiAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChuZXh0UmVzb3VyY2UsICExKSxcbiAgICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDQxOTQzMDQpKTtcbiAgICAgICAgICAgIG5leHRSZXNvdXJjZS5pc0JhY2t3YXJkc1xuICAgICAgICAgICAgICA/ICgocmV0dXJuRmliZXIuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgIDogKChjdXJyZW50ID0gbmV4dFJlc291cmNlLmxhc3QpLFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgID8gKGN1cnJlbnQuc2libGluZyA9IHJldHVybkZpYmVyKVxuICAgICAgICAgICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAgICAgKG5leHRSZXNvdXJjZS5sYXN0ID0gcmV0dXJuRmliZXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bGwgIT09IG5leHRSZXNvdXJjZS50YWlsKVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBuZXh0UmVzb3VyY2UudGFpbCksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UucmVuZGVyaW5nID0gY3VycmVudCksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UudGFpbCA9IGN1cnJlbnQuc2libGluZyksXG4gICAgICAgICAgICAgIChuZXh0UmVzb3VyY2UucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93JDEoKSksXG4gICAgICAgICAgICAgIChjdXJyZW50LnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gbmV3UHJvcHNcbiAgICAgICAgICAgICAgICA/IChyZW5kZXJMYW5lcyAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrKSB8XG4gICAgICAgICAgICAgICAgICBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgICAgICAgICAgICA6IHJlbmRlckxhbmVzICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2spLFxuICAgICAgICAgICAgICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgICAgICA/IChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKVxuICAgICAgICAgICAgICA6IG5ld1Byb3BzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSxcbiAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICAgID8gMCAhPT0gKHJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSAmJlxuICAgICAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgICAgICAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgNiAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpKVxuICAgICAgICAgICAgICA6IGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAgICAgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgICAgIG5ld1Byb3BzICE9PSByZW5kZXJMYW5lcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAocmVuZGVyTGFuZXMgPSBudWxsKSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGUgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgK1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyArXG4gICAgICAgICAgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1vZGUgJiAyKSAhPT0gTm9Nb2RlICYmXG4gICAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgICAgICAwICE9PSAoY3VycmVudCAmIDY1NTM2KSAmJiAwID09PSAoY3VycmVudCAmIDEyOClcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50LmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhyZXcgaW4gbmV3bHkgbW91bnRlZCBkZWh5ZHJhdGVkIGNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcbiAgICAgICAgICByZXR1cm4gY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubW9kZSAmIDIpICE9PSBOb01vZGUgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmV0dXJuIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgICAgIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLFxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmV0dXJuIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKSB7XG4gICAgICBwb3BUcmVlQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmsudHlwZSwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgICBwb3BIaWRkZW5Db250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlLCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2hvdWxkUHJvZmlsZShjdXJyZW50KSB7XG4gICAgICByZXR1cm4gKGN1cnJlbnQubW9kZSAmIDIpICE9PSBOb01vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBob29rRmxhZ3NcbiAgICApIHtcbiAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICBob29rRmxhZ3MsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChmbGFncywgZmluaXNoZWRXb3JrKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgICAgIGlmIChudWxsICE9PSBsYXN0RWZmZWN0KSB7XG4gICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSB2b2lkIDApLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICEwKSxcbiAgICAgICAgICAgICAgKGxhc3RFZmZlY3QgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY2FsbENyZWF0ZUluREVWLFxuICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXVlXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgKGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExKSxcbiAgICAgICAgICAgICAgKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3NcbiAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKVxuICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkICYmXG4gICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSxcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBsYXN0RWZmZWN0ICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGxhc3RFZmZlY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuICAgICAgICAgICAgICBob29rTmFtZSA9XG4gICAgICAgICAgICAgICAgMCAhPT0gKHVwZGF0ZVF1ZXVlLnRhZyAmIExheW91dClcbiAgICAgICAgICAgICAgICAgID8gXCJ1c2VMYXlvdXRFZmZlY3RcIlxuICAgICAgICAgICAgICAgICAgOiAwICE9PSAodXBkYXRlUXVldWUudGFnICYgSW5zZXJ0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInVzZUVmZmVjdFwiO1xuICAgICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID1cbiAgICAgICAgICAgICAgICBudWxsID09PSBsYXN0RWZmZWN0XG4gICAgICAgICAgICAgICAgICA/IFwiIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuIHVwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS5cIlxuICAgICAgICAgICAgICAgICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsYXN0RWZmZWN0LnRoZW5cbiAgICAgICAgICAgICAgICAgICAgPyBcIlxcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBob29rTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuIEluc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIGhvb2tOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICBcIigoKSA9PiB7XFxuICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE15QVBJLmdldERhdGEoc29tZUlkKTtcXG4gICAgLy8gLi4uXFxuICB9XFxuICBmZXRjaERhdGEoKTtcXG59LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2Vzbid0IG5lZWQgcHJvcHMgb3Igc3RhdGVcXG5cXG5MZWFybiBtb3JlIGFib3V0IGRhdGEgZmV0Y2hpbmcgd2l0aCBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ob29rcy1kYXRhLWZldGNoaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiBZb3UgcmV0dXJuZWQ6IFwiICsgbGFzdEVmZmVjdDtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChuLCBhKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIiVzIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sIHdoaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzXCIsXG4gICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBob29rTmFtZSxcbiAgICAgICAgICAgICAgICBhZGRlbmR1bVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgICAgIH0gd2hpbGUgKHVwZGF0ZVF1ZXVlICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICBmbGFncyxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSxcbiAgICAgICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICAgICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoKHVwZGF0ZVF1ZXVlLnRhZyAmIGZsYWdzKSA9PT0gZmxhZ3MpIHtcbiAgICAgICAgICAgICAgdmFyIGluc3QgPSB1cGRhdGVRdWV1ZS5pbnN0LFxuICAgICAgICAgICAgICAgIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG4gICAgICAgICAgICAgIHZvaWQgMCAhPT0gZGVzdHJveSAmJlxuICAgICAgICAgICAgICAgICgoaW5zdC5kZXN0cm95ID0gdm9pZCAwKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFnc1xuICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkICYmXG4gICAgICAgICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgOiAoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITApLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY2FsbERlc3Ryb3lJbkRFVixcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzICYmXG4gICAgICAgICAgICAgICAgICAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEpLFxuICAgICAgICAgICAgICAgIChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzXG4gICAgICAgICAgICAgICAgICA/IG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKClcbiAgICAgICAgICAgICAgICAgIDogKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncyAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgaG9va0ZsYWdzXG4gICAgKSB7XG4gICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgICAgICAgICAgIGhvb2tGbGFncyxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICAgICAgICApLFxuICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgIDogY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KFxuICAgICAgICAgICAgaG9va0ZsYWdzLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvclxuICAgICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yaykge1xuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKG51bGwgIT09IHVwZGF0ZVF1ZXVlKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyB8fFxuICAgICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIHx8XG4gICAgICAgICAgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICAgKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsR2V0U25hcHNob3RCZWZvcmVVcGRhdGVzKGluc3RhbmNlLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0Q2xhc3NTbmFwc2hvdChmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgIFwicmVmXCIgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAoY3VycmVudC5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuIFRoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIixcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICApLFxuICAgICAgICBjdXJyZW50LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8IFwiaW5zdGFuY2VcIlxuICAgICAgICAgICkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc29sdmVkUHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGVcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHNuYXBzaG90ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNhbGxHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXMsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICByZXNvbHZlZFByZXZQcm9wcyxcbiAgICAgICAgICBwcmV2U3RhdGVcbiAgICAgICAgKTtcbiAgICAgICAgcHJldlByb3BzID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgIHZvaWQgMCAhPT0gc25hcHNob3QgfHxcbiAgICAgICAgICBwcmV2UHJvcHMuaGFzKGZpbmlzaGVkV29yay50eXBlKSB8fFxuICAgICAgICAgIChwcmV2UHJvcHMuYWRkKGZpbmlzaGVkV29yay50eXBlKSxcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLlwiLFxuICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICBjdXJyZW50Ll9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gc25hcHNob3Q7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgY3VycmVudCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBpbnN0YW5jZVxuICAgICkge1xuICAgICAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgY3VycmVudC50eXBlLFxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICk7XG4gICAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHNob3VsZFByb2ZpbGUoY3VycmVudClcbiAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVjb3JkRWZmZWN0RHVyYXRpb24oKSlcbiAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRJbkRFVixcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgaW5zdGFuY2VcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICAgIGlmIChudWxsICE9PSByZWYpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgKGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gcmVmKGluc3RhbmNlKSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2UpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHJlZlxuICAgICAgICAgICAgPyBjb25zb2xlLmVycm9yKFwiU3RyaW5nIHJlZnMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuXCIpXG4gICAgICAgICAgICA6IHJlZi5oYXNPd25Qcm9wZXJ0eShcImN1cnJlbnRcIikgfHxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuIFVzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHJlZi5jdXJyZW50ID0gaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgY29tbWl0QXR0YWNoUmVmLCBjdXJyZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgICAgIHZhciByZWYgPSBjdXJyZW50LnJlZixcbiAgICAgICAgcmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgICAgIGlmIChudWxsICE9PSByZWYpXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWZDbGVhbnVwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSlcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGFydEVmZmVjdFRpbWVyKCksIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHJ1bldpdGhGaWJlckluREVWKGN1cnJlbnQsIHJlZkNsZWFudXApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RWZmZWN0VGltZXIoKSwgcnVuV2l0aEZpYmVySW5ERVYoY3VycmVudCwgcmVmLCBudWxsKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBydW5XaXRoRmliZXJJbkRFVihjdXJyZW50LCByZWYsIG51bGwpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yJDMpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyKFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgIGVmZmVjdER1cmF0aW9uXG4gICAgKSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLFxuICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vbkNvbW1pdDtcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblJlbmRlcjtcbiAgICAgIGN1cnJlbnQgPSBudWxsID09PSBjdXJyZW50ID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIjtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCAmJiAoY3VycmVudCA9IFwibmVzdGVkLXVwZGF0ZVwiKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9maW5pc2hlZFdvcmskbWVtb2l6ZSAmJlxuICAgICAgICBfZmluaXNoZWRXb3JrJG1lbW9pemUoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSxcbiAgICAgICAgICBjb21taXRTdGFydFRpbWVcbiAgICAgICAgKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9uQ29tbWl0ICYmXG4gICAgICAgIG9uQ29tbWl0KFxuICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFByb2ZpbGVyUG9zdENvbW1pdEltcGwoXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWl0U3RhcnRUaW1lLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uXG4gICAgKSB7XG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5pZDtcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUG9zdENvbW1pdDtcbiAgICAgIGN1cnJlbnQgPSBudWxsID09PSBjdXJyZW50ID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIjtcbiAgICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCAmJiAoY3VycmVudCA9IFwibmVzdGVkLXVwZGF0ZVwiKTtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgJiZcbiAgICAgICAgX2ZpbmlzaGVkV29yayRtZW1vaXplMihcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24sXG4gICAgICAgICAgY29tbWl0U3RhcnRUaW1lXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXRNb3VudCxcbiAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEhvc3RVcGRhdGUoZmluaXNoZWRXb3JrLCBuZXdQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXRVcGRhdGUsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICBvbGRQcm9wcyxcbiAgICAgICAgICBuZXdQcm9wcyxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDUgPT09IGZpYmVyLnRhZyB8fFxuICAgICAgICAzID09PSBmaWJlci50YWcgfHxcbiAgICAgICAgKHN1cHBvcnRzUmVzb3VyY2VzID8gMjYgPT09IGZpYmVyLnRhZyA6ICExKSB8fFxuICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zID8gMjcgPT09IGZpYmVyLnRhZyA6ICExKSB8fFxuICAgICAgICA0ID09PSBmaWJlci50YWdcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gICAgICBhOiBmb3IgKDs7KSB7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBmaWJlci5zaWJsaW5nOyApIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIucmV0dXJuIHx8IGlzSG9zdFBhcmVudChmaWJlci5yZXR1cm4pKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaWJlci5zaWJsaW5nLnJldHVybiA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgNSAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgNiAhPT0gZmliZXIudGFnICYmXG4gICAgICAgICAgKHN1cHBvcnRzU2luZ2xldG9ucyA/IDI3ICE9PSBmaWJlci50YWcgOiAxKSAmJlxuICAgICAgICAgIDE4ICE9PSBmaWJlci50YWc7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGZpYmVyLmZsYWdzICYgMikgY29udGludWUgYTtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gZmliZXIuY2hpbGQgfHwgNCA9PT0gZmliZXIudGFnKSBjb250aW51ZSBhO1xuICAgICAgICAgIGVsc2UgKGZpYmVyLmNoaWxkLnJldHVybiA9IGZpYmVyKSwgKGZpYmVyID0gZmliZXIuY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZpYmVyLmZsYWdzICYgMikpIHJldHVybiBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgICAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgID8gaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICA6IGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAhKDQgPT09IHRhZyB8fCAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSB0YWcpKSAmJlxuICAgICAgICAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSlcbiAgICAgIClcbiAgICAgICAgZm9yIChcbiAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCksXG4gICAgICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICAgICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICAgICAgaWYgKDUgPT09IHRhZyB8fCA2ID09PSB0YWcpXG4gICAgICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgICAgIGJlZm9yZVxuICAgICAgICAgICAgPyBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCBiZWZvcmUpXG4gICAgICAgICAgICA6IGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZSk7XG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgISg0ID09PSB0YWcgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyAmJiAyNyA9PT0gdGFnKSkgJiZcbiAgICAgICAgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpXG4gICAgICApXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgICAgICApXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSxcbiAgICAgICAgICAgIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgICAgaWYgKFxuICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICghc3VwcG9ydHNTaW5nbGV0b25zIHx8IDI3ICE9PSBmaW5pc2hlZFdvcmsudGFnKVxuICAgICAgKSB7XG4gICAgICAgIGE6IHtcbiAgICAgICAgICBmb3IgKHZhciBwYXJlbnQgPSBmaW5pc2hlZFdvcmsucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBwYXJlbnRGaWJlciA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIHBhcmVudEZpYmVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBwYXJlbnRGaWJlci5mbGFncyAmIDMyICYmXG4gICAgICAgICAgICAgIChyZXNldFRleHRDb250ZW50KHBhcmVudCksIChwYXJlbnRGaWJlci5mbGFncyAmPSAtMzMpKTtcbiAgICAgICAgICAgIHBhcmVudEZpYmVyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIHBhcmVudEZpYmVyLCBwYXJlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgcGFyZW50RmliZXIgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgICAgcGFyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgcG9ydGFsLFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgcGVuZGluZ0NoaWxkcmVuXG4gICAgKSB7XG4gICAgICBwb3J0YWwgPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgcG9ydGFsLFxuICAgICAgICAgIHBlbmRpbmdDaGlsZHJlblxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gICAgICBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICBmb3IgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkOyBudWxsICE9PSBuZXh0RWZmZWN0OyApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHJvb3QgPSBuZXh0RWZmZWN0KSxcbiAgICAgICAgICAoZmlyc3RDaGlsZCA9IHJvb3QuY2hpbGQpLFxuICAgICAgICAgIDAgIT09IChyb290LnN1YnRyZWVGbGFncyAmIDEwMjgpICYmIG51bGwgIT09IGZpcnN0Q2hpbGQpXG4gICAgICAgIClcbiAgICAgICAgICAoZmlyc3RDaGlsZC5yZXR1cm4gPSByb290KSwgKG5leHRFZmZlY3QgPSBmaXJzdENoaWxkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSByb290ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZmlyc3RDaGlsZC5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgIGZsYWdzID0gZmlyc3RDaGlsZC5mbGFncztcbiAgICAgICAgICAgIHN3aXRjaCAoZmlyc3RDaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgMCAhPT0gKGZsYWdzICYgMTAyNCkgJiZcbiAgICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAgIGNvbW1pdENsYXNzU25hcHNob3QoZmlyc3RDaGlsZCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAwICE9PSAoZmxhZ3MgJiAxMDI0KSAmJlxuICAgICAgICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXIoZmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKDAgIT09IChmbGFncyAmIDEwMjQpKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaXJzdENoaWxkID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgZmlyc3RDaGlsZC5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgIHJvb3QgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0IHwgSGFzRWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICAgICAgaWYgKCgoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSksIG51bGwgPT09IGN1cnJlbnQpKVxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcInJlZlwiIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzIHx8XG4gICAgICAgICAgICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyB8fFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFJvb3QucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkV4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSBjb21wb25lbnREaWRNb3VudC4gVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSBhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgXCJpbnN0YW5jZVwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlIGNvbXBvbmVudERpZE1vdW50LiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICAgIHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgPyAoc3RhcnRFZmZlY3RUaW1lcigpLFxuICAgICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICByZWNvcmRFZmZlY3REdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYsXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzIHx8XG4gICAgICAgICAgICAgICAgXCJyZWZcIiBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyB8fFxuICAgICAgICAgICAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgfHxcbiAgICAgICAgICAgICAgICAoZmluaXNoZWRSb290LnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgY29tcG9uZW50RGlkVXBkYXRlLiBUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlIGEgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCBcImluc3RhbmNlXCJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgICBzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaylcbiAgICAgICAgICAgICAgICA/IChzdGFydEVmZmVjdFRpbWVyKCksXG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHJlY29yZEVmZmVjdER1cmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDY0ICYmIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiYgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjdXJyZW50ID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSwgbnVsbCAhPT0gZmxhZ3MpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmV2UHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGZpbmlzaGVkV29yay5jaGlsZClcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBwcmV2UHJvcHMgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgIHByZXZQcm9wcyA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWRSb290LmVmZmVjdER1cmF0aW9uICs9IHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhjdXJyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgJiYgZmxhZ3MgJiA0ICYmIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5lZmZlY3REdXJhdGlvbiArPSBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QuZWZmZWN0RHVyYXRpb25cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZQcm9wcyA9XG4gICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgaWYgKCFwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbixcbiAgICAgICAgICAgICAgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldlByb3BzO1xuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBjdXJyZW50KSAmJlxuICAgICAgICAgICAgIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuXG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChcIm1hbnVhbFwiID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgICAgID8gc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybilcbiAgICAgICAgICAgICAgOiBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcikge1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAoKGZpYmVyLmFsdGVybmF0ZSA9IG51bGwpLCBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpKTtcbiAgICAgIGZpYmVyLmNoaWxkID0gbnVsbDtcbiAgICAgIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICAgIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICAgICAoKGFsdGVybmF0ZSA9IGZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgIG51bGwgIT09IGFsdGVybmF0ZSAmJiBkZXRhY2hEZWxldGVkSW5zdGFuY2UoYWx0ZXJuYXRlKSk7XG4gICAgICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICAgICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgICAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgICAgIGZpYmVyLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgICAgIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICBmaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgcGFyZW50XG4gICAgKSB7XG4gICAgICBmb3IgKHBhcmVudCA9IHBhcmVudC5jaGlsZDsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgcGFyZW50XG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICBkZWxldGVkRmliZXJcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgaW5qZWN0ZWRIb29rICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudFxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciB8fFxuICAgICAgICAgICAgKChoYXNMb2dnZWRFcnJvciA9ICEwKSxcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlc1wiLFxuICAgICAgICAgICAgICBlcnJcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICBzd2l0Y2ggKGRlbGV0ZWRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gcmVsZWFzZVJlc291cmNlKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKVxuICAgICAgICAgICAgICA6IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgICB2YXIgcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50LFxuICAgICAgICAgICAgICBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyO1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICgocHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXIpLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IG51bGwpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXIpLFxuICAgICAgICAgICAgICBudWxsICE9PSBob3N0UGFyZW50KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gaG9zdFBhcmVudCAmJlxuICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lclxuICAgICAgICAgICAgICA/IGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoXG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50LFxuICAgICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBjbGVhclN1c3BlbnNlQm91bmRhcnkoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc3VwcG9ydHNNdXRhdGlvblxuICAgICAgICAgICAgPyAoKHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyID0gaG9zdFBhcmVudElzQ29udGFpbmVyKSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudElzQ29udGFpbmVyID0gITApLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAoaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50KSxcbiAgICAgICAgICAgICAgKGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXIpKVxuICAgICAgICAgICAgOiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbixcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBMYXlvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgKHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpLFxuICAgICAgICAgICAgKHByZXZIb3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoXG4gICAgICAgICAgICAgICAgZGVsZXRlZEZpYmVyLFxuICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgICAgcHJldkhvc3RQYXJlbnRcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHx8XG4gICAgICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGlmIChcbiAgICAgICAgc3VwcG9ydHNIeWRyYXRpb24gJiZcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRSb290ICYmXG4gICAgICAgICAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdC5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gZmluaXNoZWRSb290KSkpXG4gICAgICApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3RcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKSB7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpKTtcbiAgICAgICAgICByZXR1cm4gcmV0cnlDYWNoZTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUpLFxuICAgICAgICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5fcmV0cnlDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKSksXG4gICAgICAgICAgICByZXRyeUNhY2hlXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5zZSBoYW5kbGVyIHRhZyAoXCIgK1xuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudGFnICtcbiAgICAgICAgICAgICAgXCIpLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHdha2VhYmxlcykge1xuICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yayk7XG4gICAgICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAgICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcbiAgICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh3YWtlYWJsZSkpIHtcbiAgICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KVxuICAgICAgICAgICAgaWYgKG51bGwgIT09IGluUHJvZ3Jlc3NMYW5lcyAmJiBudWxsICE9PSBpblByb2dyZXNzUm9vdClcbiAgICAgICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhpblByb2dyZXNzUm9vdCwgaW5Qcm9ncmVzc0xhbmVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCk7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCRqc2NvbXAkMCwgcGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIHJldHVybkZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBkZWxldGVkRmliZXIgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIGE6IGZvciAoOyBudWxsICE9PSBwYXJlbnQ7ICkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bGwgPT09IGhvc3RQYXJlbnQpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMTtcbiAgICAgICAgICB9IGVsc2UgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICByb290ID0gZGVsZXRlZEZpYmVyO1xuICAgICAgICAgIHJldHVybkZpYmVyID0gcm9vdC5hbHRlcm5hdGU7XG4gICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXIgJiYgKHJldHVybkZpYmVyLnJldHVybiA9IG51bGwpO1xuICAgICAgICAgIHJvb3QucmV0dXJuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEzODc4KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihwYXJlbnRGaWJlciwgcm9vdCRqc2NvbXAkMCksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIChjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoXG4gICAgICAgICAgICAgIEluc2VydGlvbiB8IEhhc0VmZmVjdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICBjb21taXRIb29rTGF5b3V0VW5tb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgTGF5b3V0IHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gJiZcbiAgICAgICAgICAgICgoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yayAmJlxuICAgICAgICAgICAgICAoKGZsYWdzID0gZmluaXNoZWRXb3JrLmNhbGxiYWNrcyksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MpLFxuICAgICAgICAgICAgICAgIChmaW5pc2hlZFdvcmsuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9XG4gICAgICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ID8gZmxhZ3MgOiBjdXJyZW50LmNvbmNhdChmbGFncykpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGhvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICAgKChmbGFncyA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsKSxcbiAgICAgICAgICAgICAgKHJvb3QgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gbnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICA/IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gaHlkcmF0ZUhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgOiBtb3VudEhvaXN0YWJsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGVcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgICAgIDogZmxhZ3MgIT09IHJvb3RcbiAgICAgICAgICAgICAgICAgID8gKG51bGwgPT09IGZsYWdzXG4gICAgICAgICAgICAgICAgICAgICAgPyBudWxsICE9PSBjdXJyZW50LnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShjdXJyZW50LnN0YXRlTm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHJlbGVhc2VSZXNvdXJjZShmbGFncyksXG4gICAgICAgICAgICAgICAgICAgIG51bGwgPT09IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgICA/IG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogYWNxdWlyZVJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgIDogbnVsbCA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdEhvc3RVcGRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzdXBwb3J0c1NpbmdsZXRvbnMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNsZWFyU2luZ2xldG9uKGhvaXN0YWJsZVJvb3QpLFxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmluaXNoZWRXb3JrLCByZXNldFRleHRDb250ZW50LCByb290KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgICBudWxsICE9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgKChyb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiByb290XG4gICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgZmxhZ3MgJiAxMDI0ICYmXG4gICAgICAgICAgICAgICgobmVlZHNGb3JtUmVzZXQgPSAhMCksXG4gICAgICAgICAgICAgIFwiZm9ybVwiICE9PSBmaW5pc2hlZFdvcmsudHlwZSAmJlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgaG9zdCBjb21wb25lbnQgdHlwZS4gRXhwZWN0ZWQgYSBmb3JtLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGlmIChmbGFncyAmIDQgJiYgc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKG51bGwgPT09IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpXG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZmxhZ3MgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGN1cnJlbnQgPSBudWxsICE9PSBjdXJyZW50ID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogZmxhZ3M7XG4gICAgICAgICAgICByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjb21taXRUZXh0VXBkYXRlLFxuICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgICBmbGFnc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAocHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcygpLFxuICAgICAgICAgICAgICAocHJvcHMgPSBjdXJyZW50SG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3Qocm9vdC5jb250YWluZXJJbmZvKSksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJvcHMpKVxuICAgICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzdXBwb3J0c011dGF0aW9uICYmXG4gICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICByb290LmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgICAgZmxhZ3MgPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSByb290LnBlbmRpbmdDaGlsZHJlbjtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ICYmXG4gICAgICAgICAgICAoKG5lZWRzRm9ybVJlc2V0ID0gITEpLCByZWN1cnNpdmVseVJlc2V0Rm9ybXMoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBwb3BOZXN0ZWRFZmZlY3REdXJhdGlvbnMoaG9pc3RhYmxlUm9vdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzdXBwb3J0c1Jlc291cmNlc1xuICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSBjdXJyZW50SG9pc3RhYmxlUm9vdCksXG4gICAgICAgICAgICAgIChjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgICAoY3VycmVudEhvaXN0YWJsZVJvb3QgPSBjdXJyZW50KSlcbiAgICAgICAgICAgIDogKHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgc3VwcG9ydHNQZXJzaXN0ZW5jZSAmJlxuICAgICAgICAgICAgY29tbWl0SG9zdFBvcnRhbENvbnRhaW5lckNoaWxkcmVuKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGVuZGluZ0NoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGZsYWdzID0gcHVzaE5lc3RlZEVmZmVjdER1cmF0aW9ucygpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9XG4gICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsuY2hpbGQuZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICAgICAobnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpICE9PVxuICAgICAgICAgICAgICAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAgICAgICAoZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCkpO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdCA9IG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4sXG4gICAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID1cbiAgICAgICAgICAgIHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IHdhc0hpZGRlbjtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgcm9vdC5fY3VycmVudCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICByb290Ll92aXNpYmlsaXR5ICY9IC0zO1xuICAgICAgICAgIHJvb3QuX3Zpc2liaWxpdHkgfD0gcm9vdC5fcGVuZGluZ1Zpc2liaWxpdHkgJiAyO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGZsYWdzICYgODE5MiAmJlxuICAgICAgICAgICAgKChyb290Ll92aXNpYmlsaXR5ID0gaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICA/IHJvb3QuX3Zpc2liaWxpdHkgJiAtMlxuICAgICAgICAgICAgICA6IHJvb3QuX3Zpc2liaWxpdHkgfCAxKSxcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QgJiZcbiAgICAgICAgICAgICAgKChyb290ID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pLFxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgd2FzSGlkZGVuIHx8XG4gICAgICAgICAgICAgICAgcm9vdCB8fFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykpLFxuICAgICAgICAgICAgc3VwcG9ydHNNdXRhdGlvbiAmJlxuICAgICAgICAgICAgICAobnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICAgICAgICBcIm1hbnVhbFwiICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlKSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBhOiBpZiAoKChjdXJyZW50ID0gbnVsbCksIHN1cHBvcnRzTXV0YXRpb24pKVxuICAgICAgICAgICAgICBmb3IgKHJvb3QgPSBmaW5pc2hlZFdvcms7IDsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgNSA9PT0gcm9vdC50YWcgfHxcbiAgICAgICAgICAgICAgICAgIChzdXBwb3J0c1Jlc291cmNlcyAmJiAyNiA9PT0gcm9vdC50YWcpIHx8XG4gICAgICAgICAgICAgICAgICAoc3VwcG9ydHNTaW5nbGV0b25zICYmIDI3ID09PSByb290LnRhZylcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbiA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIChwcm9wcyA9IHdhc0hpZGRlbi5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKHdhc0hpZGRlbiwgaGlkZUluc3RhbmNlLCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaGlkZUluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLnN0YXRlTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5tZW1vaXplZFByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKDYgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4gPSByb290O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdhc0hpZGRlbi5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNIaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzSGlkZGVuLm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0hpZGRlbi5yZXR1cm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgKCgyMiAhPT0gcm9vdC50YWcgJiYgMjMgIT09IHJvb3QudGFnKSB8fFxuICAgICAgICAgICAgICAgICAgICBudWxsID09PSByb290Lm1lbW9pemVkU3RhdGUgfHxcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9PT0gZmluaXNoZWRXb3JrKSAmJlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdC5jaGlsZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgcm9vdC5jaGlsZC5yZXR1cm4gPSByb290O1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QuY2hpbGQ7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgPT09IGZpbmlzaGVkV29yaykgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgbnVsbCA9PT0gcm9vdC5zaWJsaW5nOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChudWxsID09PSByb290LnJldHVybiB8fCByb290LnJldHVybiA9PT0gZmluaXNoZWRXb3JrKVxuICAgICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID09PSByb290ICYmIChjdXJyZW50ID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgcm9vdC5zaWJsaW5nLnJldHVybiA9IHJvb3QucmV0dXJuO1xuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgICgoZmxhZ3MgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MucmV0cnlRdWV1ZSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAoKGZsYWdzLnJldHJ5UXVldWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgY3VycmVudCkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgICAgICBudWxsICE9PSBmbGFncyAmJlxuICAgICAgICAgICAgICAoKGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaW5pc2hlZFdvcmssIGNvbW1pdFBsYWNlbWVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gLTM7XG4gICAgICB9XG4gICAgICBmbGFncyAmIDQwOTYgJiYgKGZpbmlzaGVkV29yay5mbGFncyAmPSAtNDA5Nyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjQpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG4gICAgICAgICAgNSA9PT0gZmliZXIudGFnICYmXG4gICAgICAgICAgICBmaWJlci5mbGFncyAmIDEwMjQgJiZcbiAgICAgICAgICAgIHJlc2V0Rm9ybUluc3RhbmNlKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICAgICAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICBpblByb2dyZXNzUm9vdCA9IGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3MilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgcGFyZW50RmliZXIuYWx0ZXJuYXRlLCBwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgY29tbWl0SG9va0xheW91dFVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIExheW91dFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgJiZcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICBjYXNlIDI3OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKHBhcmVudEZpYmVyKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgY3VycmVudCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50LmNvbXBvbmVudERpZE1vdW50ICYmXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnRJbkRFVixcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0SGlkZGVuQ2FsbGJhY2tzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiA2NCAmJlxuICAgICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgNCkge1xuICAgICAgICAgICAgZmxhZ3MgPSBwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zKCk7XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cy5lZmZlY3REdXJhdGlvbiArPVxuICAgICAgICAgICAgICBidWJibGVOZXN0ZWRFZmZlY3REdXJhdGlvbnMoZmxhZ3MpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdFByb2ZpbGVyLFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIGNvbW1pdFN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzLmVmZmVjdER1cmF0aW9uXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgKSB7XG4gICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAwICE9PSAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgODc3Mik7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgcGFyZW50RmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKSxcbiAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICBjdXJyZW50ICE9PSBwcmV2aW91c0NhY2hlICYmXG4gICAgICAgIChudWxsICE9IGN1cnJlbnQgJiYgcmV0YWluQ2FjaGUoY3VycmVudCksXG4gICAgICAgIG51bGwgIT0gcHJldmlvdXNDYWNoZSAmJiByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgIGZpbmlzaGVkV29yayAhPT0gY3VycmVudCAmJlxuICAgICAgICAocmV0YWluQ2FjaGUoZmluaXNoZWRXb3JrKSwgbnVsbCAhPSBjdXJyZW50ICYmIHJlbGVhc2VDYWNoZShjdXJyZW50KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgcm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICkge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICBmaW5pc2hlZFdvcmssXG4gICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDExOlxuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgKChjb21taXR0ZWRMYW5lcyA9IG51bGwpLFxuICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgICAoY29tbWl0dGVkTGFuZXMgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpLFxuICAgICAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayAhPT0gY29tbWl0dGVkTGFuZXMgJiZcbiAgICAgICAgICAgICAgKHJldGFpbkNhY2hlKGZpbmlzaGVkV29yayksXG4gICAgICAgICAgICAgIG51bGwgIT0gY29tbWl0dGVkTGFuZXMgJiYgcmVsZWFzZUNhY2hlKGNvbW1pdHRlZExhbmVzKSkpO1xuICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmIChmbGFncyAmIDIwNDgpIHtcbiAgICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgICAgYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zKHByZXZFZmZlY3REdXJhdGlvbik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICBjb21taXRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgICAgPyByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6ICgocHJldkVmZmVjdER1cmF0aW9uLl92aXNpYmlsaXR5IHw9IDQpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1Nik7XG4gICAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBwYXJlbnRGaWJlcixcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgZmluaXNoZWRSb290LFxuICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICApIHtcbiAgICAgIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICA/IF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgJiA0XG4gICAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiAoKF9pbnN0YW5jZTIuX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICApO1xuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgIHBhcmVudEZpYmVyXG4gICAgKSB7XG4gICAgICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNTYpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KFxuICAgICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29ya1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChwYXJlbnRGaWJlcikge1xuICAgICAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmliZXIpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgICAgIChudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICAgID8gc3VzcGVuZFJlc291cmNlKFxuICAgICAgICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICAgICAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiBzdXNwZW5kSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgICAgIHN1c3BlbmRJbnN0YW5jZShmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoXG4gICAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICAgIH0gZWxzZSByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIG51bGwgPT09IGZpYmVyLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICAgICgocHJldmlvdXNIb2lzdGFibGVSb290ID0gZmliZXIuYWx0ZXJuYXRlKSxcbiAgICAgICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNIb2lzdGFibGVSb290Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgICAgICAgPyAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IHN1c3BlbnNleUNvbW1pdEZsYWcpLFxuICAgICAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gMTY3NzcyMTYpLFxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlciksXG4gICAgICAgICAgICAgICAgKHN1c3BlbnNleUNvbW1pdEZsYWcgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3QpKVxuICAgICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gcHJldmlvdXNGaWJlciAmJlxuICAgICAgICAoKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlci5jaGlsZCksIG51bGwgIT09IHBhcmVudEZpYmVyKVxuICAgICAgKSB7XG4gICAgICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuICAgICAgICBkb1xuICAgICAgICAgIChwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyksXG4gICAgICAgICAgICAocGFyZW50RmliZXIuc2libGluZyA9IG51bGwpLFxuICAgICAgICAgICAgKHBhcmVudEZpYmVyID0gcHJldmlvdXNGaWJlcik7XG4gICAgICAgIHdoaWxlIChudWxsICE9PSBwYXJlbnRGaWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gICAgICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgICAgIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgICAgICBwYXJlbnRGaWJlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuLFxuICAgICAgICAgICAgICBQYXNzaXZlIHwgSGFzRWZmZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdmFyIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIHBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IHB1c2hOZXN0ZWRFZmZlY3REdXJhdGlvbnMoKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz1cbiAgICAgICAgICAgIGJ1YmJsZU5lc3RlZEVmZmVjdER1cmF0aW9ucyhwcmV2RWZmZWN0RHVyYXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHByZXZFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBwcmV2RWZmZWN0RHVyYXRpb24uX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAgICAgKG51bGwgPT09IGZpbmlzaGVkV29yay5yZXR1cm4gfHwgMTMgIT09IGZpbmlzaGVkV29yay5yZXR1cm4udGFnKVxuICAgICAgICAgICAgPyAoKHByZXZFZmZlY3REdXJhdGlvbi5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSlcbiAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAgICAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcbiAgICAgIGlmICgwICE9PSAocGFyZW50RmliZXIuZmxhZ3MgJiAxNikpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oXG4gICAgICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChwYXJlbnRGaWJlciksXG4gICAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpbmlzaGVkV29yaykge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIFBhc3NpdmVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGluc3RhbmNlLl92aXNpYmlsaXR5ICYgNCAmJlxuICAgICAgICAgICAgKChpbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSAtNSksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgIGRlbGV0ZWRTdWJ0cmVlUm9vdCxcbiAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3JcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdCxcbiAgICAgICAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgUGFzc2l2ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgICAgICAgIG51bGwgIT0gY3VycmVudCAmJiByZXRhaW5DYWNoZShjdXJyZW50KSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgcmVsZWFzZUNhY2hlKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGZpYmVyLmNoaWxkO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkgKGN1cnJlbnQucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGN1cnJlbnQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYTogZm9yIChmaWJlciA9IGRlbGV0ZWRTdWJ0cmVlUm9vdDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dEVmZmVjdDtcbiAgICAgICAgICAgIHZhciBzaWJsaW5nID0gY3VycmVudC5zaWJsaW5nLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGN1cnJlbnQucmV0dXJuO1xuICAgICAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoY3VycmVudCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAgICAgICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykge1xuICAgICAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCkge1xuICAgICAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcbiAgICAgIGlmIChudWxsICE9IG1heWJlRmliZXIpIHtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgIT09IHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbXCJkYXRhLXRlc3RuYW1lXCJdKVxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIGhvc3Qgcm9vdCBzcGVjaWZpZWQuIFNob3VsZCBiZSBlaXRoZXIgYSBSZWFjdCBjb250YWluZXIgb3IgYSBub2RlIHdpdGggYSB0ZXN0bmFtZSBhdHRyaWJ1dGUuXCJcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gbWF5YmVGaWJlcjtcbiAgICAgIH1cbiAgICAgIGhvc3RSb290ID0gZmluZEZpYmVyUm9vdChob3N0Um9vdCk7XG4gICAgICBpZiAobnVsbCA9PT0gaG9zdFJvb3QpXG4gICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgIFwiQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLlwiXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gaG9zdFJvb3Quc3RhdGVOb2RlLmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIkanNjb21wJDAsIHNlbGVjdG9yKSB7XG4gICAgICB2YXIgdGFnID0gZmliZXIkanNjb21wJDAudGFnO1xuICAgICAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgICAgIGlmIChmaWJlciRqc2NvbXAkMC50eXBlID09PSBzZWxlY3Rvci52YWx1ZSkgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnZhbHVlO1xuICAgICAgICAgICAgZmliZXIkanNjb21wJDAgPSBbZmliZXIkanNjb21wJDAsIDBdO1xuICAgICAgICAgICAgZm9yICh0YWcgPSAwOyB0YWcgPCBmaWJlciRqc2NvbXAkMC5sZW5ndGg7ICkge1xuICAgICAgICAgICAgICB2YXIgZmliZXIgPSBmaWJlciRqc2NvbXAkMFt0YWcrK10sXG4gICAgICAgICAgICAgICAgdGFnJGpzY29tcCQwID0gZmliZXIudGFnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSBmaWJlciRqc2NvbXAkMFt0YWcrK10sXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IkanNjb21wJDAgPSBzZWxlY3RvcltzZWxlY3RvckluZGV4XTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICg1ICE9PSB0YWckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIDI2ICE9PSB0YWckanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIDI3ICE9PSB0YWckanNjb21wJDApIHx8XG4gICAgICAgICAgICAgICAgIWlzSGlkZGVuU3VidHJlZShmaWJlcilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgIG51bGwgIT0gc2VsZWN0b3IkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICAgIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yJGpzY29tcCQwKTtcblxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdG9yJGpzY29tcCQwID0gc2VsZWN0b3Jbc2VsZWN0b3JJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3Rvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gITA7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgZm9yIChmaWJlciA9IGZpYmVyLmNoaWxkOyBudWxsICE9PSBmaWJlcjsgKVxuICAgICAgICAgICAgICAgICAgICBmaWJlciRqc2NvbXAkMC5wdXNoKGZpYmVyLCBzZWxlY3RvckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAoZmliZXIgPSBmaWJlci5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0b3IgPSAhMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdG9yO1xuICAgICAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZykgJiZcbiAgICAgICAgICAgIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUoZmliZXIkanNjb21wJDAuc3RhdGVOb2RlLCBzZWxlY3Rvci52YWx1ZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgICAgIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZylcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgKChmaWJlciRqc2NvbXAkMCA9IGdldFRleHRDb250ZW50KGZpYmVyJGpzY29tcCQwKSksXG4gICAgICAgICAgICAgIG51bGwgIT09IGZpYmVyJGpzY29tcCQwICYmXG4gICAgICAgICAgICAgICAgMCA8PSBmaWJlciRqc2NvbXAkMC5pbmRleE9mKHNlbGVjdG9yLnZhbHVlKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgICAgIGlmICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGZpYmVyJGpzY29tcCQwID0gZmliZXIkanNjb21wJDAubWVtb2l6ZWRQcm9wc1tcImRhdGEtdGVzdG5hbWVcIl0pLFxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZmliZXIkanNjb21wJDAgJiZcbiAgICAgICAgICAgICAgICBmaWJlciRqc2NvbXAkMC50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvci52YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VsZWN0b3JUb1N0cmluZyhzZWxlY3Rvcikge1xuICAgICAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8IFwiVW5rbm93blwiKSArIFwiPlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiOmhhcyhcIiArIChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB8fCBcIlwiKSArIFwiKVwiO1xuICAgICAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgICAgICByZXR1cm4gJ1tyb2xlPVwiJyArIHNlbGVjdG9yLnZhbHVlICsgJ1wiXSc7XG4gICAgICAgIGNhc2UgVEVYVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAnXCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCInO1xuICAgICAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgICAgIHJldHVybiAnW2RhdGEtdGVzdG5hbWU9XCInICsgc2VsZWN0b3IudmFsdWUgKyAnXCJdJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBbXTtcbiAgICAgIHJvb3QgPSBbcm9vdCwgMF07XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcm9vdC5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgZmliZXIgPSByb290W2luZGV4KytdLFxuICAgICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgICBzZWxlY3RvckluZGV4ID0gcm9vdFtpbmRleCsrXSxcbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICg1ICE9PSB0YWcgJiYgMjYgIT09IHRhZyAmJiAyNyAhPT0gdGFnKSB8fFxuICAgICAgICAgICFpc0hpZGRlblN1YnRyZWUoZmliZXIpXG4gICAgICAgICkge1xuICAgICAgICAgIGZvciAoOyBudWxsICE9IHNlbGVjdG9yICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKTsgKVxuICAgICAgICAgICAgc2VsZWN0b3JJbmRleCsrLCAoc2VsZWN0b3IgPSBzZWxlY3RvcnNbc2VsZWN0b3JJbmRleF0pO1xuICAgICAgICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSBtYXRjaGluZ0ZpYmVycy5wdXNoKGZpYmVyKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmb3IgKGZpYmVyID0gZmliZXIuY2hpbGQ7IG51bGwgIT09IGZpYmVyOyApXG4gICAgICAgICAgICAgIHJvb3QucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kUGF0aHMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBzZWxlY3RvcnMgPSBbXTtcbiAgICAgIGhvc3RSb290ID0gQXJyYXkuZnJvbShob3N0Um9vdCk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaG9zdFJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIG5vZGUgPSBob3N0Um9vdFtpbmRleCsrXSxcbiAgICAgICAgICB0YWcgPSBub2RlLnRhZztcbiAgICAgICAgaWYgKDUgPT09IHRhZyB8fCAyNiA9PT0gdGFnIHx8IDI3ID09PSB0YWcpXG4gICAgICAgICAgaXNIaWRkZW5TdWJ0cmVlKG5vZGUpIHx8IHNlbGVjdG9ycy5wdXNoKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobm9kZSA9IG5vZGUuY2hpbGQ7IG51bGwgIT09IG5vZGU7IClcbiAgICAgICAgICAgIGhvc3RSb290LnB1c2gobm9kZSksIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RvcnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uQ29tbWl0Um9vdCgpIHtcbiAgICAgIHN1cHBvcnRzVGVzdFNlbGVjdG9ycyAmJlxuICAgICAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkge1xuICAgICAgdmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlRcbiAgICAgICAgICA/IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVFxuICAgICAgICAgIDogdm9pZCAwO1xuICAgICAgaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIHx8XG4gICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlIHx8XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUaGUgY3VycmVudCB0ZXN0aW5nIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIHN1cHBvcnQgYWN0KC4uLilcIlxuICAgICAgICApO1xuICAgICAgcmV0dXJuIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmXG4gICAgICAgIDAgIT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApXG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIC13b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgICAgIHJldHVybiBudWxsICE9PSB0cmFuc2l0aW9uXG4gICAgICAgID8gKHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgfHwgKHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCkpLFxuICAgICAgICAgIHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuYWRkKGZpYmVyKSxcbiAgICAgICAgICAoZmliZXIgPSBjdXJyZW50RW50YW5nbGVkTGFuZSksXG4gICAgICAgICAgMCAhPT0gZmliZXIgPyBmaWJlciA6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpKVxuICAgICAgICA6IHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1ZXN0RGVmZXJyZWRMYW5lKCkge1xuICAgICAgMCA9PT0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID1cbiAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpIHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgICA/IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKClcbiAgICAgICAgICAgIDogNTM2ODcwOTEyKTtcbiAgICAgIHZhciBzdXNwZW5zZUhhbmRsZXIgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyICYmIChzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gMzIpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFwidXNlSW5zZXJ0aW9uRWZmZWN0IG11c3Qgbm90IHNjaGVkdWxlIHVwZGF0ZXMuXCIpO1xuICAgICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzICYmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gITApO1xuICAgICAgaWYgKFxuICAgICAgICAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSkgfHxcbiAgICAgICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gICAgICApXG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApLFxuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCBsYW5lKTtcbiAgICAgIGlmIChcbiAgICAgICAgMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAmJlxuICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNSZW5kZXJpbmcpXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICByb290ID1cbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykpIHx8XG4gICAgICAgICAgICAgICAgXCJVbmtub3duXCI7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMocm9vdCkgfHxcbiAgICAgICAgICAgICAgICAoZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChyb290KSxcbiAgICAgICAgICAgICAgICAoZmliZXIgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlVua25vd25cIiksXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiQ2Fubm90IHVwZGF0ZSBhIGNvbXBvbmVudCAoYCVzYCkgd2hpbGUgcmVuZGVyaW5nIGEgZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXJcIixcbiAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIHJvb3RcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIHx8XG4gICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuXCJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIChkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9ICEwKSk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZSksXG4gICAgICAgICAgd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSxcbiAgICAgICAgICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiZcbiAgICAgICAgICAgICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IGxhbmUpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSAmJlxuICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICExXG4gICAgICAgICAgICAgICkpLFxuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgbGFuZXMsIGZvcmNlU3luYykge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIik7XG4gICAgICB2YXIgc2hvdWxkVGltZVNsaWNlID1cbiAgICAgICAgICAoIWZvcmNlU3luYyAmJlxuICAgICAgICAgICAgMCA9PT0gKGxhbmVzICYgNjApICYmXG4gICAgICAgICAgICAwID09PSAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykpIHx8XG4gICAgICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcyksXG4gICAgICAgIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2VcbiAgICAgICAgICA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKVxuICAgICAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMsICEwKSxcbiAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgJiZcbiAgICAgICAgICAgICFzaG91bGRUaW1lU2xpY2UgJiZcbiAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCAwLCAhMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKVxuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3JjZVN5bmMgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgICAgICFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZm9yY2VTeW5jKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCAhMSk7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gITE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gbGFuZXM7XG4gICAgICAgICAgICBpZiAocm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmIHJlbmRlcldhc0NvbmN1cnJlbnQpXG4gICAgICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSAwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAoZXJyb3JSZXRyeUxhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiAtNTM2ODcwOTEzKSxcbiAgICAgICAgICAgICAgICAoZXJyb3JSZXRyeUxhbmVzID1cbiAgICAgICAgICAgICAgICAgIDAgIT09IGVycm9yUmV0cnlMYW5lc1xuICAgICAgICAgICAgICAgICAgICA/IGVycm9yUmV0cnlMYW5lc1xuICAgICAgICAgICAgICAgICAgICA6IGVycm9yUmV0cnlMYW5lcyAmIDUzNjg3MDkxMlxuICAgICAgICAgICAgICAgICAgICAgID8gNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICAgICAgOiAwKTtcbiAgICAgICAgICAgIGlmICgwICE9PSBlcnJvclJldHJ5TGFuZXMpIHtcbiAgICAgICAgICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gcm9vdDtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICAgIGVycm9yUmV0cnlMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gICAgICAgICAgICAgICAgdmFyIHdhc1Jvb3REZWh5ZHJhdGVkID1cbiAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSHlkcmF0aW9uICYmXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICAgICAgd2FzUm9vdERlaHlkcmF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgIChwcmVwYXJlRnJlc2hTdGFjayhcbiAgICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwXG4gICAgICAgICAgICAgICAgICApLmZsYWdzIHw9IDI1Nik7XG4gICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwID0gcmVuZGVyUm9vdFN5bmMoXG4gICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLFxuICAgICAgICAgICAgICAgICAgZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwLFxuICAgICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvclJldHJ5TGFuZXMkanNjb21wJDAgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciAmJlxuICAgICAgICAgICAgICAgICAgICAhd2FzUm9vdERlaHlkcmF0ZWRcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD1cbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXhpdFN0YXR1cyAmJiBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGV4aXRTdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleGl0U3RhdHVzID0gZXJyb3JSZXRyeUxhbmVzJGpzY29tcCQwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgICAgICAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApO1xuICAgICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIDAsICEwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UgPSByb290O1xuICAgICAgICAgICAgc3dpdGNoIChleGl0U3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgICAgICAgICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIik7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgICAgICAgICAgICBpZiAoKGxhbmVzICYgNDE5NDE3NikgPT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLFxuICAgICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAgICF3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgUm9vdFN1c3BlbmRlZDpcbiAgICAgICAgICAgICAgY2FzZSBSb290Q29tcGxldGVkOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biByb290IGV4aXQgc3RhdHVzLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZS5maW5pc2hlZFdvcmsgPSBmb3JjZVN5bmM7XG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlKVxuICAgICAgICAgICAgICBjb21taXRSb290KFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgIElNTUVESUFURV9DT01NSVQsXG4gICAgICAgICAgICAgICAgLTAsXG4gICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAobGFuZXMgJiA2MjkxNDU2MCkgPT09IGxhbmVzICYmXG4gICAgICAgICAgICAgICAgKChleGl0U3RhdHVzID1cbiAgICAgICAgICAgICAgICAgIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgK1xuICAgICAgICAgICAgICAgICAgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLVxuICAgICAgICAgICAgICAgICAgbm93JDEoKSksXG4gICAgICAgICAgICAgICAgMTAgPCBleGl0U3RhdHVzKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoMCAhPT0gZ2V0TmV4dExhbmVzKHNob3VsZFRpbWVTbGljZSwgMCkpIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgc2hvdWxkVGltZVNsaWNlLnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoXG4gICAgICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5LmJpbmQoXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIFRIUk9UVExFRF9DT01NSVQsXG4gICAgICAgICAgICAgICAgICAgIC0wLFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgZXhpdFN0YXR1c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICBmb3JjZVN5bmMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLFxuICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MsXG4gICAgICAgICAgICAgICAgSU1NRURJQVRFX0NPTU1JVCxcbiAgICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSB3aGlsZSAoMSk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9yc1xuICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9ycylcbiAgICAgICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290V2hlblJlYWR5KFxuICAgICAgcm9vdCxcbiAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBsYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgIGRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICApIHtcbiAgICAgIHZhciBzdWJ0cmVlRmxhZ3MgPSBmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzO1xuICAgICAgaWYgKHN1YnRyZWVGbGFncyAmIDgxOTIgfHwgMTY3ODU0MDggPT09IChzdWJ0cmVlRmxhZ3MgJiAxNjc4NTQwOCkpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoc3RhcnRTdXNwZW5kaW5nQ29tbWl0KCksXG4gICAgICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmluaXNoZWRXb3JrKSxcbiAgICAgICAgICAoZmluaXNoZWRXb3JrID0gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpKSxcbiAgICAgICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmspXG4gICAgICAgICkge1xuICAgICAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IGZpbmlzaGVkV29yayhcbiAgICAgICAgICAgIGNvbW1pdFJvb3QuYmluZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgICAgIFNVU1BFTkRFRF9DT01NSVQsXG4gICAgICAgICAgICAgIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgICAgICFkaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY29tbWl0Um9vdChcbiAgICAgICAgcm9vdCxcbiAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICB2YXIgdGFnID0gbm9kZS50YWc7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoMCA9PT0gdGFnIHx8IDExID09PSB0YWcgfHwgMTUgPT09IHRhZykgJiZcbiAgICAgICAgICBub2RlLmZsYWdzICYgMTYzODQgJiZcbiAgICAgICAgICAoKHRhZyA9IG5vZGUudXBkYXRlUXVldWUpLFxuICAgICAgICAgIG51bGwgIT09IHRhZyAmJiAoKHRhZyA9IHRhZy5zdG9yZXMpLCBudWxsICE9PSB0YWcpKVxuICAgICAgICApXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IHRhZ1tpXSxcbiAgICAgICAgICAgICAgZ2V0U25hcHNob3QgPSBjaGVjay5nZXRTbmFwc2hvdDtcbiAgICAgICAgICAgIGNoZWNrID0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIGNoZWNrKSkgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgdGFnID0gbm9kZS5jaGlsZDtcbiAgICAgICAgaWYgKG5vZGUuc3VidHJlZUZsYWdzICYgMTYzODQgJiYgbnVsbCAhPT0gdGFnKVxuICAgICAgICAgICh0YWcucmV0dXJuID0gbm9kZSksIChub2RlID0gdGFnKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykgYnJlYWs7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IG5vZGUuc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgcmV0dXJuICEwO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgIHJvb3QsXG4gICAgICBzdXNwZW5kZWRMYW5lcyxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgZGlkQXR0ZW1wdEVudGlyZVRyZWVcbiAgICApIHtcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcztcbiAgICAgIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcztcbiAgICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXM7XG4gICAgICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lcztcbiAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlICYmIChyb290Lndhcm1MYW5lcyB8PSBzdXNwZW5kZWRMYW5lcyk7XG4gICAgICBkaWRBdHRlbXB0RW50aXJlVHJlZSA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICAgICAgZm9yICh2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lczsgMCA8IGxhbmVzOyApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMzEgLSBjbHozMihsYW5lcyksXG4gICAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICAgIGRpZEF0dGVtcHRFbnRpcmVUcmVlW2luZGV4XSA9IC0xO1xuICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgIH1cbiAgICAgIDAgIT09IHNwYXduZWRMYW5lICYmXG4gICAgICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBzdXNwZW5kZWRMYW5lcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoU3luY1dvcmsoKSB7XG4gICAgICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0XG4gICAgICAgID8gKGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSwgITEpXG4gICAgICAgIDogITA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpIHtcbiAgICAgIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IE5vdFN1c3BlbmRlZClcbiAgICAgICAgICB2YXIgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpLFxuICAgICAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKGludGVycnVwdGVkV29yayksXG4gICAgICAgICAgICAodGhlbmFibGVTdGF0ZSQxID0gbnVsbCksXG4gICAgICAgICAgICAodGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDApLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IGludGVycnVwdGVkV29yazsgKVxuICAgICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlLCBpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAgICAgKGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm4pO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG4gICAgICB0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQgJiZcbiAgICAgICAgKChyb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQpLCBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpKTtcbiAgICAgIHRpbWVvdXRIYW5kbGUgPSByb290LmNhbmNlbFBlbmRpbmdDb21taXQ7XG4gICAgICBudWxsICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICgocm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbCksIHRpbWVvdXRIYW5kbGUoKSk7XG4gICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHRpbWVvdXRIYW5kbGUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBsYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBsYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcztcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9XG4gICAgICAgICAgMDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9XG4gICAgICAgIG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITE7XG4gICAgICAwICE9PSAobGFuZXMgJiA4KSAmJiAobGFuZXMgfD0gbGFuZXMgJiAzMik7XG4gICAgICB2YXIgYWxsRW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuICAgICAgaWYgKDAgIT09IGFsbEVudGFuZ2xlZExhbmVzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHJvb3QgPSByb290LmVudGFuZ2xlbWVudHMsIGFsbEVudGFuZ2xlZExhbmVzICY9IGxhbmVzO1xuICAgICAgICAgIDAgPCBhbGxFbnRhbmdsZWRMYW5lcztcblxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGFsbEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgICAgIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgICAgIGxhbmVzIHw9IHJvb3RbaW5kZXhdO1xuICAgICAgICAgIGFsbEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICAgICAgICB9XG4gICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICAgICAgcmV0dXJuIHRpbWVvdXRIYW5kbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlKSB7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgICAgaXNSZW5kZXJpbmcgPSAhMTtcbiAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW1tZWRpYXRlKSlcbiAgICAgICAgOiB0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uXG4gICAgICAgICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkluc3RhbmNlKSlcbiAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgICAgIHRocm93blZhbHVlID09PSBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb25cbiAgICAgICAgICAgICAgICA/IFN1c3BlbmRlZE9uSHlkcmF0aW9uXG4gICAgICAgICAgICAgICAgOiBudWxsICE9PSB0aHJvd25WYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUudGhlblxuICAgICAgICAgICAgICAgICAgPyBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2VcbiAgICAgICAgICAgICAgICAgIDogU3VzcGVuZGVkT25FcnJvcik7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gdGhyb3duVmFsdWU7XG4gICAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIGlmIChudWxsID09PSBlcnJvcmVkV29yaylcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkKSxcbiAgICAgICAgICBsb2dVbmNhdWdodEVycm9yKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoZXJyb3JlZFdvcmsubW9kZSAmIDIgJiZcbiAgICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24oZXJyb3JlZFdvcmspLFxuICAgICAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCksXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pXG4gICAgICAgICkge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudEVycm9yZWQoXG4gICAgICAgICAgICAgICAgZXJyb3JlZFdvcmssXG4gICAgICAgICAgICAgICAgdGhyb3duVmFsdWUsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZChcbiAgICAgICAgICAgICAgICBlcnJvcmVkV29yayxcbiAgICAgICAgICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gaGFuZGxlclxuICAgICAgICA/ICEwXG4gICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgID8gbnVsbCA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgPyAhMFxuICAgICAgICAgICAgOiAhMVxuICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApID09PVxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIHx8XG4gICAgICAgICAgICAgIDAgIT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMilcbiAgICAgICAgICAgID8gaGFuZGxlciA9PT0gc2hlbGxCb3VuZGFyeVxuICAgICAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgICAgIHJldHVybiBudWxsID09PSBwcmV2RGlzcGF0Y2hlciA/IENvbnRleHRPbmx5RGlzcGF0Y2hlciA6IHByZXZEaXNwYXRjaGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoQXN5bmNEaXNwYXRjaGVyKCkge1xuICAgICAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IERlZmF1bHRBc3luY0Rpc3BhdGNoZXI7XG4gICAgICByZXR1cm4gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIHx8XG4gICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA0MTk0MTc2KSAhPT1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpIHx8XG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9ICEwKTtcbiAgICAgICgwID09PSAod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzICYgMTM0MjE3NzI3KSAmJlxuICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgJiAxMzQyMTc3MjcpKSB8fFxuICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgfHxcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICExXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZykge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbWVtb2l6ZWRVcGRhdGVycy5zaXplICYmXG4gICAgICAgICAgICAocmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCkpO1xuICAgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgICAgIGxhbmVzID0gITE7XG4gICAgICBtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgICAgIGE6IGRvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gIT09IE5vdFN1c3BlbmRlZCAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgICAgICBudWxsID09PSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50ICYmIChsYW5lcyA9ICEwKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb247XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZyAmJlxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSBSb290SW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIChyZWFzb24gPSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiksXG4gICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQ0KSB7XG4gICAgICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkNCk7XG4gICAgICAgIH1cbiAgICAgIHdoaWxlICgxKTtcbiAgICAgIGxhbmVzICYmIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSxcbiAgICAgICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpKTtcbiAgICAgIHJldHVybiBtZW1vaXplZFVwZGF0ZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcFN5bmMoKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7ICkgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gICAgICBpZiAoXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICAgICkge1xuICAgICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgICAgICAwIDwgbWVtb2l6ZWRVcGRhdGVycy5zaXplICYmXG4gICAgICAgICAgICAocmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCkpO1xuICAgICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGw7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVM7XG4gICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcoXG4gICAgICAgICAgcm9vdCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgICAgYTogZG9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmXG4gICAgICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzc1xuICAgICAgICAgIClcbiAgICAgICAgICAgIGI6IHN3aXRjaCAoXG4gICAgICAgICAgICAgICgobGFuZXMgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIChtZW1vaXplZFVwZGF0ZXJzID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSksXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZE9uRXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKG1lbW9pemVkVXBkYXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFuZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJlxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPVxuICAgICAgICAgICAgICAgICAgICAgIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSk7XG4gICAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLnRoZW4obGFuZXMsIGxhbmVzKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZTpcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9XG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAgICAgIGlzVGhlbmFibGVSZXNvbHZlZChtZW1vaXplZFVwZGF0ZXJzKVxuICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkKSxcbiAgICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayhsYW5lcykpXG4gICAgICAgICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQpLFxuICAgICAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKFxuICAgICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWVcbiAgICAgICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEZpYmVyID0gd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGhvc3RGaWJlci50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BzID0gaG9zdEZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IGhvc3RGaWJlci5zaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsICE9PSBzaWJsaW5nKSB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBob3N0RmliZXIucmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gcmV0dXJuRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhyZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDogKHdvcmtJblByb2dyZXNzID0gbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCB0eXBlIG9mIGZpYmVyIHRyaWdnZXJlZCBhIHN1c3BlbnNleSBjb21taXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMsXG4gICAgICAgICAgICAgICAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBTdXNwZW5kZWRSZWFzb24uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlXG4gICAgICAgICAgICA/IHdvcmtMb29wU3luYygpXG4gICAgICAgICAgICA6IHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQ1KSB7XG4gICAgICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUkNSk7XG4gICAgICAgIH1cbiAgICAgIHdoaWxlICgxKTtcbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpLFxuICAgICAgICAgIFJvb3RJblByb2dyZXNzXG4gICAgICAgICk7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMDtcbiAgICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnQoKSB7XG4gICAgICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgIXNob3VsZFlpZWxkKCk7IClcbiAgICAgICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICAgICAgKHVuaXRPZldvcmsubW9kZSAmIDIpICE9PSBOb01vZGVcbiAgICAgICAgPyAoc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspLFxuICAgICAgICAgIChjdXJyZW50ID0gcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgYmVnaW5Xb3JrLFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICAgICkpLFxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRHVyYXRpb24odW5pdE9mV29yaykpXG4gICAgICAgIDogKGN1cnJlbnQgPSBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICBiZWdpbldvcmssXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzXG4gICAgICAgICAgKSk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaylcbiAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gICAgICB2YXIgbmV4dCA9IHJ1bldpdGhGaWJlckluREVWKHVuaXRPZldvcmssIHJlcGxheUJlZ2luV29yaywgdW5pdE9mV29yayk7XG4gICAgICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgIG51bGwgPT09IG5leHQgPyBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykgOiAod29ya0luUHJvZ3Jlc3MgPSBuZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGF5QmVnaW5Xb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGUsXG4gICAgICAgIGlzUHJvZmlsaW5nTW9kZSA9ICh1bml0T2ZXb3JrLm1vZGUgJiAyKSAhPT0gTm9Nb2RlO1xuICAgICAgaXNQcm9maWxpbmdNb2RlICYmIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgICAgIHN3aXRjaCAodW5pdE9mV29yay50YWcpIHtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGN1cnJlbnQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICAgICAgdW5pdE9mV29yay5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnR5cGUsXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgY3VycmVudCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgIHVuaXRPZldvcmssXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHVuaXRPZldvcmsudHlwZS5yZW5kZXIsXG4gICAgICAgICAgICB1bml0T2ZXb3JrLnJlZixcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayksXG4gICAgICAgICAgICAodW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzID1cbiAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzcyh1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgKGN1cnJlbnQgPSBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpKTtcbiAgICAgIH1cbiAgICAgIGlzUHJvZmlsaW5nTW9kZSAmJlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRocm93QW5kVW53aW5kV29ya0xvb3AoXG4gICAgICByb290LFxuICAgICAgdW5pdE9mV29yayxcbiAgICAgIHRocm93blZhbHVlLFxuICAgICAgc3VzcGVuZGVkUmVhc29uXG4gICAgKSB7XG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NPblVud2luZCh1bml0T2ZXb3JrKTtcbiAgICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgIHZhciByZXR1cm5GaWJlciA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRocm93RXhjZXB0aW9uKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgdW5pdE9mV29yayxcbiAgICAgICAgICAgIHRocm93blZhbHVlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICAgICApO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcikgdGhyb3cgKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSwgZXJyb3IpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgICByb290LFxuICAgICAgICAgIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpXG4gICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXRPZldvcmsuZmxhZ3MgJiAzMjc2OCkge1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcgfHwgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkVycm9yKSByb290ID0gITA7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nIHx8XG4gICAgICAgICAgMCAhPT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKVxuICAgICAgICApXG4gICAgICAgICAgcm9vdCA9ICExO1xuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9IHJvb3QgPSAhMCksXG4gICAgICAgICAgc3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgfHxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25JbW1lZGlhdGUgfHxcbiAgICAgICAgICAgIHN1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlKVxuICAgICAgICApXG4gICAgICAgICAgKHN1c3BlbmRlZFJlYXNvbiA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICAgICAgbnVsbCAhPT0gc3VzcGVuZGVkUmVhc29uICYmXG4gICAgICAgICAgICAgIDEzID09PSBzdXNwZW5kZWRSZWFzb24udGFnICYmXG4gICAgICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24uZmxhZ3MgfD0gMTYzODQpO1xuICAgICAgICB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmssIHJvb3QpO1xuICAgICAgfSBlbHNlIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgICAgIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKDAgIT09IChjb21wbGV0ZWRXb3JrLmZsYWdzICYgMzI3NjgpKSB7XG4gICAgICAgICAgdW53aW5kVW5pdE9mV29yayhcbiAgICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3NcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICB1bml0T2ZXb3JrID0gY29tcGxldGVkV29yay5yZXR1cm47XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgY3VycmVudCA9IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgICAgY29tcGxldGVXb3JrLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgY29tcGxldGVkV29yayxcbiAgICAgICAgICBlbnRhbmdsZWRSZW5kZXJMYW5lc1xuICAgICAgICApO1xuICAgICAgICAoY29tcGxldGVkV29yay5tb2RlICYgMikgIT09IE5vTW9kZSAmJlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gY3VycmVudDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVkV29yayA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcbiAgICAgICAgaWYgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gICAgICB9IHdoaWxlIChudWxsICE9PSBjb21wbGV0ZWRXb3JrKTtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdENvbXBsZXRlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgc2tpcFNpYmxpbmdzKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBuZXh0ID0gdW53aW5kV29yayh1bml0T2ZXb3JrLmFsdGVybmF0ZSwgdW5pdE9mV29yayk7XG4gICAgICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICAgICAgbmV4dC5mbGFncyAmPSAzMjc2NztcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodW5pdE9mV29yay5tb2RlICYgMikgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkSW5jb21wbGV0ZUR1cmF0aW9uKHVuaXRPZldvcmspO1xuICAgICAgICAgIG5leHQgPSB1bml0T2ZXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGZvciAodmFyIGNoaWxkID0gdW5pdE9mV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQ7IClcbiAgICAgICAgICAgIChuZXh0ICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uKSwgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdW5pdE9mV29yay5hY3R1YWxEdXJhdGlvbiA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCA9IHVuaXRPZldvcmsucmV0dXJuO1xuICAgICAgICBudWxsICE9PSBuZXh0ICYmXG4gICAgICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSxcbiAgICAgICAgICAobmV4dC5zdWJ0cmVlRmxhZ3MgPSAwKSxcbiAgICAgICAgICAobmV4dC5kZWxldGlvbnMgPSBudWxsKSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAgICAgKCh1bml0T2ZXb3JrID0gdW5pdE9mV29yay5zaWJsaW5nKSwgbnVsbCAhPT0gdW5pdE9mV29yaylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gdW5pdE9mV29yayk7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290KFxuICAgICAgcm9vdCxcbiAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICBzcGF3bmVkTGFuZSxcbiAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICBjb21wbGV0ZWRSZW5kZXJFbmRUaW1lXG4gICAgKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KDIpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAgICAgY29tbWl0Um9vdEltcGwoXG4gICAgICAgICAgICByb290LFxuICAgICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgICAgICAgICAgIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5LFxuICAgICAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgICAgICB1cGRhdGVkTGFuZXMsXG4gICAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICAgICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXRSb290SW1wbChcbiAgICAgIHJvb3QsXG4gICAgICByZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgIHRyYW5zaXRpb25zLFxuICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCxcbiAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lc1xuICAgICkge1xuICAgICAgZG8gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgd2hpbGUgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcoKTtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KVxuICAgICAgICB0aHJvdyBFcnJvcihcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiKTtcbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHJvb3QuZmluaXNoZWRMYW5lcztcbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCAmJlxuICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdGFydGVkKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSk7XG4gICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrKSByZXR1cm4gbWFya0NvbW1pdFN0b3BwZWQoKSwgbnVsbDtcbiAgICAgIDAgPT09IGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwicm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICk7XG4gICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICByb290LmZpbmlzaGVkTGFuZXMgPSAwO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayA9PT0gcm9vdC5jdXJyZW50KVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkNhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgKTtcbiAgICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDA7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgICAgdmFyIHJlbWFpbmluZ0xhbmVzID0gZmluaXNoZWRXb3JrLmxhbmVzIHwgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXM7XG4gICAgICByZW1haW5pbmdMYW5lcyB8PSBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXM7XG4gICAgICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgICAgICByb290LFxuICAgICAgICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsXG4gICAgICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgICAgICBzcGF3bmVkTGFuZSxcbiAgICAgICAgdXBkYXRlZExhbmVzLFxuICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICAgICApO1xuICAgICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmXG4gICAgICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCkpO1xuICAgICAgKDAgPT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTAyNTYpICYmXG4gICAgICAgIDAgPT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NikpIHx8XG4gICAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzIHx8XG4gICAgICAgICgocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSAhMCksXG4gICAgICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgKHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucyksXG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoITApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KSk7XG4gICAgICBjb21taXRTdGFydFRpbWUgPSBub3coKTtcbiAgICAgIHRyYW5zaXRpb25zID0gMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDE1OTkwKTtcbiAgICAgIDAgIT09IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgMTU5OTApIHx8IHRyYW5zaXRpb25zXG4gICAgICAgID8gKCh0cmFuc2l0aW9ucyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAgICAgKHNwYXduZWRMYW5lID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCkpLFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAodXBkYXRlZExhbmVzID0gZXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dCksXG4gICAgICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayksXG4gICAgICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzKFxuICAgICAgICAgICAgcm9vdCxcbiAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZVxuICAgICAgICAgICksXG4gICAgICAgICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgIChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspLFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZChcbiAgICAgICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpLFxuICAgICAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkICYmXG4gICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpLFxuICAgICAgICAgIHJlcXVlc3RQYWludCgpLFxuICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ID0gdXBkYXRlZExhbmVzKSxcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoc3Bhd25lZExhbmUpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gdHJhbnNpdGlvbnMpKVxuICAgICAgICA6IChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspO1xuICAgICAgKHRyYW5zaXRpb25zID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgID8gKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExKSxcbiAgICAgICAgICAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290KSxcbiAgICAgICAgICAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpKVxuICAgICAgICA6IChyZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSxcbiAgICAgICAgICAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCksXG4gICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsKSk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCA9PT0gcmVtYWluaW5nTGFuZXMgJiYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCk7XG4gICAgICB0cmFuc2l0aW9ucyB8fCBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gICAgICBvbkNvbW1pdFJvb3QkMShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCByZW5kZXJQcmlvcml0eUxldmVsKTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgb25Db21taXRSb290KCk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICBpZiAobnVsbCAhPT0gcmVjb3ZlcmFibGVFcnJvcnMpXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yLCBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgICAgIGZpbmlzaGVkV29yayA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsrK1xuICAgICAgICApXG4gICAgICAgICAgKHJlbWFpbmluZ0xhbmVzID0gcmVjb3ZlcmFibGVFcnJvcnNbZmluaXNoZWRXb3JrXSksXG4gICAgICAgICAgICAodHJhbnNpdGlvbnMgPSBtYWtlRXJyb3JJbmZvKHJlbWFpbmluZ0xhbmVzLnN0YWNrKSksXG4gICAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihcbiAgICAgICAgICAgICAgcmVtYWluaW5nTGFuZXMuc291cmNlLFxuICAgICAgICAgICAgICByZW5kZXJQcmlvcml0eUxldmVsLFxuICAgICAgICAgICAgICByZW1haW5pbmdMYW5lcy52YWx1ZSxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbnNcbiAgICAgICAgICAgICk7XG4gICAgICAwICE9PSAocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgJiAzKSAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgICAgMCAhPT0gKGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSAmIDQxOTQyMTgpICYmXG4gICAgICAwICE9PSAocmVtYWluaW5nTGFuZXMgJiA0MilcbiAgICAgICAgPyAoKG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICEwKSxcbiAgICAgICAgICByb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXNcbiAgICAgICAgICAgID8gbmVzdGVkVXBkYXRlQ291bnQrK1xuICAgICAgICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSkpXG4gICAgICAgIDogKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCk7XG4gICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VFcnJvckluZm8oY29tcG9uZW50U3RhY2spIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrID0geyBjb21wb25lbnRTdGFjazogY29tcG9uZW50U3RhY2sgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb21wb25lbnRTdGFjaywgXCJkaWdlc3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ1lvdSBhcmUgYWNjZXNzaW5nIFwiZGlnZXN0XCIgZnJvbSB0aGUgZXJyb3JJbmZvIG9iamVjdCBwYXNzZWQgdG8gb25SZWNvdmVyYWJsZUVycm9yLiBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHkgb2YgdGhlIEVycm9yIGluc3RhbmNlIGl0c2VsZi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgICAgIDAgPT09IChyb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXMpICYmXG4gICAgICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICAgICAgbnVsbCAhPSByZW1haW5pbmdMYW5lcyAmJlxuICAgICAgICAgICgocm9vdC5wb29sZWRDYWNoZSA9IG51bGwpLCByZWxlYXNlQ2FjaGUocmVtYWluaW5nTGFuZXMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gICAgICBpZiAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyxcbiAgICAgICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDA7XG4gICAgICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKSxcbiAgICAgICAgICBwcmlvcml0eSA9IDMyID4gcmVuZGVyUHJpb3JpdHkgPyAzMiA6IHJlbmRlclByaW9yaXR5O1xuICAgICAgICByZW5kZXJQcmlvcml0eSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByaW9yaXR5KTtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gICAgICAgICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIHZhciByb290JGpzY29tcCQwID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICAgICAgICAgIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gICAgICAgICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG4gICAgICAgICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IDA7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09XG4gICAgICAgICAgICAgIE5vQ29udGV4dFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9ICEwO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9ICExO1xuICAgICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09XG4gICAgICAgICAgICAgICAgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCAmJlxuICAgICAgICAgICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgICAgICAgICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICAgICAgICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgICAgICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihyb290JGpzY29tcCQwLmN1cnJlbnQpO1xuICAgICAgICAgICAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgICAgICAgICAgICAgcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgICAgcm9vdCRqc2NvbXAkMC5jdXJyZW50LFxuICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBudWxsICE9PSBpbmplY3RlZFByb2ZpbGluZ0hvb2tzICYmXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkICYmXG4gICAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO1xuICAgICAgICAgICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QkanNjb21wJDApO1xuICAgICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgICAgICAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoMCwgITEpO1xuICAgICAgICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0c1xuICAgICAgICAgICAgICA/IHJvb3QkanNjb21wJDAgPT09IHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXNcbiAgICAgICAgICAgICAgICA/IG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCsrXG4gICAgICAgICAgICAgICAgOiAoKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDApLFxuICAgICAgICAgICAgICAgICAgKHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290JGpzY29tcCQwKSlcbiAgICAgICAgICAgICAgOiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCk7XG4gICAgICAgICAgICBkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzID0gaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgICAgICAgITE7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290JGpzY29tcCQwKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgfHxcbiAgICAgICAgICAgICAgICAgICgoaGFzTG9nZ2VkRXJyb3IgPSAhMCksXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIlJlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyXG4gICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHJvb3QkanNjb21wJDAuY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHJlbmRlclByaW9yaXR5KSxcbiAgICAgICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gICAgICByb290RmliZXIgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgc291cmNlRmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcm9vdEZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgc291cmNlRmliZXIsXG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgZXJyb3JcbiAgICApIHtcbiAgICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9ICExO1xuICAgICAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IG51bGwgIT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7ICkge1xuICAgICAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKDEgPT09IG5lYXJlc3RNb3VudGVkQW5jZXN0b3IudGFnKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICAgICAgZXJyb3IgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKDIpO1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IGVucXVldWVVcGRhdGUobmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IsIDIpO1xuICAgICAgICAgICAgICBudWxsICE9PSBpbnN0YW5jZSAmJlxuICAgICAgICAgICAgICAgIChpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICAgICAgc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluc3RhbmNlLCAyKSxcbiAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5zdGFuY2UpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5yZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkludGVybmFsIFJlYWN0IGVycm9yOiBBdHRlbXB0ZWQgdG8gY2FwdHVyZSBhIGNvbW1pdCBwaGFzZSBlcnJvciBpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gUG90ZW50aWFsIGNhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuIGFscmVhZHktZmluaXNoZWQgdHJlZSwgb3IgYW4gaW5jb25zaXN0ZW50IHJldHVybiBwb2ludGVyLlxcblxcbkVycm9yIG1lc3NhZ2U6XFxuXFxuJXNcIixcbiAgICAgICAgICBlcnJvclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gICAgICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gICAgICBpZiAobnVsbCA9PT0gcGluZ0NhY2hlKSB7XG4gICAgICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgICAgICB2YXIgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKSksXG4gICAgICAgICAgdm9pZCAwID09PSB0aHJlYWRJRHMgJiZcbiAgICAgICAgICAgICgodGhyZWFkSURzID0gbmV3IFNldCgpKSwgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKSk7XG4gICAgICB0aHJlYWRJRHMuaGFzKGxhbmVzKSB8fFxuICAgICAgICAoKHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICEwKSxcbiAgICAgICAgdGhyZWFkSURzLmFkZChsYW5lcyksXG4gICAgICAgIChwaW5nQ2FjaGUgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcykpLFxuICAgICAgICBpc0RldlRvb2xzUHJlc2VudCAmJiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSxcbiAgICAgICAgd2FrZWFibGUudGhlbihwaW5nQ2FjaGUsIHBpbmdDYWNoZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgICAgIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgICAgIG51bGwgIT09IHBpbmdDYWNoZSAmJiBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgICAgIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xuICAgICAgcm9vdC53YXJtTGFuZXMgJj0gfnBpbmdlZExhbmVzO1xuICAgICAgaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJlxuICAgICAgICBudWxsID09PSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG5XaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCByZXNvbHZlcyBzdXNwZW5kZWQgZGF0YSBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbmFjdCgoKSA9PiB7XFxuICAvKiBmaW5pc2ggbG9hZGluZyBzdXNwZW5kZWQgZGF0YSAqL1xcbn0pO1xcbi8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBpbiB0aGUgYnJvd3Nlci4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3RcIlxuICAgICAgICApO1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHBpbmdlZExhbmVzKSA9PT0gcGluZ2VkTGFuZXMgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MjkxNDU2MCkgPT09XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmJlxuICAgICAgICAgIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpXG4gICAgICAgICAgPyAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIDApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9IDApKTtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gICAgICBib3VuZGFyeUZpYmVyID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICBudWxsICE9PSBib3VuZGFyeUZpYmVyICYmXG4gICAgICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoYm91bmRhcnlGaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICByZXRyeUxhbmUgPSAwO1xuICAgICAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gICAgICB2YXIgcmV0cnlMYW5lID0gMDtcbiAgICAgIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBzdXNwZW5zZVN0YXRlID0gYm91bmRhcnlGaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgXCJQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IHJldHJ5Q2FjaGUgJiYgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICAgICAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYoXG4gICAgICByb290JGpzY29tcCQwLFxuICAgICAgcGFyZW50RmliZXIsXG4gICAgICBpc0luU3RyaWN0TW9kZVxuICAgICkge1xuICAgICAgaWYgKDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU2MjYyNCkpXG4gICAgICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgICAgICAgIHZhciByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgICAgIGZpYmVyID0gcGFyZW50RmliZXIsXG4gICAgICAgICAgICBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXIgPSBpc0luU3RyaWN0TW9kZSB8fCBpc1N0cmljdE1vZGVGaWJlcjtcbiAgICAgICAgICAyMiAhPT0gZmliZXIudGFnXG4gICAgICAgICAgICA/IGZpYmVyLmZsYWdzICYgMzM1NTQ0MzJcbiAgICAgICAgICAgICAgPyBpc1N0cmljdE1vZGVGaWJlciAmJlxuICAgICAgICAgICAgICAgIHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgZmliZXIsXG4gICAgICAgICAgICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcixcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIChmaWJlci5tb2RlICYgNjQpID09PSBOb01vZGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihcbiAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgIGlzU3RyaWN0TW9kZUZpYmVyXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBudWxsID09PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgICAgIChpc1N0cmljdE1vZGVGaWJlciAmJiBmaWJlci5mbGFncyAmIDgxOTJcbiAgICAgICAgICAgICAgICA/IHJ1bldpdGhGaWJlckluREVWKFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIsXG4gICAgICAgICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBmaWJlci5zdWJ0cmVlRmxhZ3MgJiAzMzU1NDQzMiAmJlxuICAgICAgICAgICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoXG4gICAgICAgICAgICAgICAgICAgIGZpYmVyLFxuICAgICAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWLFxuICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICBmaWJlcixcbiAgICAgICAgICAgICAgICAgICAgaXNTdHJpY3RNb2RlRmliZXJcbiAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlcikge1xuICAgICAgdmFyIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzID1cbiAgICAgICAgMiA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiAhMDtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmliZXIpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpYmVyKSxcbiAgICAgICAgICByZWFwcGVhckxheW91dEVmZmVjdHMocm9vdCwgZmliZXIuYWx0ZXJuYXRlLCBmaWJlciwgITEpLFxuICAgICAgICAgIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzICYmXG4gICAgICAgICAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhyb290LCBmaWJlciwgMCwgbnVsbCwgITEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCkge1xuICAgICAgdmFyIGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMDtcbiAgICAgIHJvb3QuY3VycmVudC5tb2RlICYgMjQgfHwgKGRvdWJsZUludm9rZUVmZmVjdHMgPSAhMSk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKFxuICAgICAgICByb290LFxuICAgICAgICByb290LmN1cnJlbnQsXG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIDMgPT09IHRhZyB8fFxuICAgICAgICAgIDEgPT09IHRhZyB8fFxuICAgICAgICAgIDAgPT09IHRhZyB8fFxuICAgICAgICAgIDExID09PSB0YWcgfHxcbiAgICAgICAgICAxNCA9PT0gdGFnIHx8XG4gICAgICAgICAgMTUgPT09IHRhZ1xuICAgICAgICApIHtcbiAgICAgICAgICB0YWcgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIlJlYWN0Q29tcG9uZW50XCI7XG4gICAgICAgICAgaWYgKG51bGwgIT09IGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyh0YWcpKSByZXR1cm47XG4gICAgICAgICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZCh0YWcpO1xuICAgICAgICAgIH0gZWxzZSBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbdGFnXSk7XG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvIHVzZUVmZmVjdCBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpIHtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmXG4gICAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsaW5nRmliZXIpIHtcbiAgICAgICAgICBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgc2NoZWR1bGluZ0ZpYmVyLCBsYW5lcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYWN0UXVldWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZTtcbiAgICAgIHJldHVybiBudWxsICE9PSBhY3RRdWV1ZVxuICAgICAgICA/IChhY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKSwgZmFrZUFjdENhbGxiYWNrTm9kZSlcbiAgICAgICAgOiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpIHtcbiAgICAgIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkgJiZcbiAgICAgICAgbnVsbCA9PT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgJiZcbiAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoZmliZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlIHdyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG5hY3QoKCkgPT4ge1xcbiAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG59KTtcXG4vKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcblRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgaW4gdGhlIGJyb3dzZXIuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0XCIsXG4gICAgICAgICAgICBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiB0eXBlO1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBmYW1pbHkgPyB0eXBlIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09PSByZXNvbHZlRmFtaWx5KSByZXR1cm4gdHlwZTtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gZmFtaWx5XG4gICAgICAgID8gbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZSAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUucmVuZGVyICYmXG4gICAgICAgICAgKChmYW1pbHkgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpKSxcbiAgICAgICAgICB0eXBlLnJlbmRlciAhPT0gZmFtaWx5KVxuICAgICAgICAgID8gKChmYW1pbHkgPSB7ICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLCByZW5kZXI6IGZhbWlseSB9KSxcbiAgICAgICAgICAgIHZvaWQgMCAhPT0gdHlwZS5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAoZmFtaWx5LmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSksXG4gICAgICAgICAgICBmYW1pbHkpXG4gICAgICAgICAgOiB0eXBlXG4gICAgICAgIDogZmFtaWx5LmN1cnJlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICAgICAgaWYgKG51bGwgPT09IHJlc29sdmVGYW1pbHkpIHJldHVybiAhMTtcbiAgICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICExLFxuICAgICAgICAkJHR5cGVvZk5leHRUeXBlID1cbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50XG4gICAgICAgICAgICA/IGVsZW1lbnQuJCR0eXBlb2ZcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50ICYmIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGVsZW1lbnRcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRVxuICAgICAgICAgICAgPyAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMClcbiAgICAgICAgICAgIDogJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmXG4gICAgICAgICAgICAgIChuZWVkc0NvbXBhcmVGYW1pbGllcyA9ICEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEVcbiAgICAgICAgICAgID8gKG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gITApXG4gICAgICAgICAgICA6ICQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAobmVlZHNDb21wYXJlRmFtaWxpZXMgPSAhMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZWRzQ29tcGFyZUZhbWlsaWVzICYmXG4gICAgICAgICgoZmliZXIgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gZmliZXIgJiYgZmliZXIgPT09IHJlc29sdmVGYW1pbHkoZWxlbWVudCkpXG4gICAgICAgID8gITBcbiAgICAgICAgOiAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAgICAgIG51bGwgIT09IHJlc29sdmVGYW1pbHkgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCAmJlxuICAgICAgICAobnVsbCA9PT0gZmFpbGVkQm91bmRhcmllcyAmJiAoZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCkpLFxuICAgICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgZmliZXIsXG4gICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICBzdGFsZUZhbWlsaWVzXG4gICAgKSB7XG4gICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PT0gcmVzb2x2ZUZhbWlseSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC5cIik7XG4gICAgICB2YXIgbmVlZHNSZW5kZXIgPSAhMTtcbiAgICAgIHR5cGUgPSAhMTtcbiAgICAgIG51bGwgIT09IGNhbmRpZGF0ZVR5cGUgJiZcbiAgICAgICAgKChjYW5kaWRhdGVUeXBlID0gcmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKSksXG4gICAgICAgIHZvaWQgMCAhPT0gY2FuZGlkYXRlVHlwZSAmJlxuICAgICAgICAgIChzdGFsZUZhbWlsaWVzLmhhcyhjYW5kaWRhdGVUeXBlKVxuICAgICAgICAgICAgPyAodHlwZSA9ICEwKVxuICAgICAgICAgICAgOiB1cGRhdGVkRmFtaWxpZXMuaGFzKGNhbmRpZGF0ZVR5cGUpICYmXG4gICAgICAgICAgICAgICgxID09PSB0YWcgPyAodHlwZSA9ICEwKSA6IChuZWVkc1JlbmRlciA9ICEwKSkpKTtcbiAgICAgIG51bGwgIT09IGZhaWxlZEJvdW5kYXJpZXMgJiZcbiAgICAgICAgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fFxuICAgICAgICAgIChudWxsICE9PSBhbHRlcm5hdGUgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkpICYmXG4gICAgICAgICh0eXBlID0gITApO1xuICAgICAgdHlwZSAmJiAoZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50ID0gITApO1xuICAgICAgaWYgKHR5cGUgfHwgbmVlZHNSZW5kZXIpXG4gICAgICAgIChhbHRlcm5hdGUgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFsdGVybmF0ZSwgZmliZXIsIDIpO1xuICAgICAgbnVsbCA9PT0gY2hpbGQgfHxcbiAgICAgICAgdHlwZSB8fFxuICAgICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIHVwZGF0ZWRGYW1pbGllcyxcbiAgICAgICAgICBzdGFsZUZhbWlsaWVzXG4gICAgICAgICk7XG4gICAgICBudWxsICE9PSBzaWJsaW5nICYmXG4gICAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoXG4gICAgICAgICAgc2libGluZyxcbiAgICAgICAgICB1cGRhdGVkRmFtaWxpZXMsXG4gICAgICAgICAgc3RhbGVGYW1pbGllc1xuICAgICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgIHRoaXMuc2libGluZyA9XG4gICAgICAgIHRoaXMuY2hpbGQgPVxuICAgICAgICB0aGlzLnJldHVybiA9XG4gICAgICAgIHRoaXMuc3RhdGVOb2RlID1cbiAgICAgICAgdGhpcy50eXBlID1cbiAgICAgICAgdGhpcy5lbGVtZW50VHlwZSA9XG4gICAgICAgICAgbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgdGhpcy5yZWZDbGVhbnVwID0gdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgIHRoaXMubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICAgIHRoaXMudXBkYXRlUXVldWUgPVxuICAgICAgICB0aGlzLm1lbW9pemVkUHJvcHMgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5zdWJ0cmVlRmxhZ3MgPSB0aGlzLmZsYWdzID0gMDtcbiAgICAgIHRoaXMuZGVsZXRpb25zID0gbnVsbDtcbiAgICAgIHRoaXMuY2hpbGRMYW5lcyA9IHRoaXMubGFuZXMgPSAwO1xuICAgICAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IC0wO1xuICAgICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMS4xO1xuICAgICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gLTA7XG4gICAgICB0aGlzLl9kZWJ1Z093bmVyID0gdGhpcy5fZGVidWdJbmZvID0gbnVsbDtcbiAgICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gITE7XG4gICAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG4gICAgICBoYXNCYWRNYXBQb2x5ZmlsbCB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgfHxcbiAgICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gICAgICBDb21wb25lbnQgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEoIUNvbXBvbmVudCB8fCAhQ29tcG9uZW50LmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgICAgIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoXG4gICAgICAgICAgICBjdXJyZW50LnRhZyxcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgICAgICAgY3VycmVudC5tb2RlXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50LnN0YXRlTm9kZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lciksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudCksXG4gICAgICAgICAgKGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3MpKVxuICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAtMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xLjEpKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gY3VycmVudC5mbGFncyAmIDMxNDU3MjgwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICAgICAgcGVuZGluZ1Byb3BzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPVxuICAgICAgICBudWxsID09PSBwZW5kaW5nUHJvcHNcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgbGFuZXM6IHBlbmRpbmdQcm9wcy5sYW5lcyxcbiAgICAgICAgICAgICAgZmlyc3RDb250ZXh0OiBwZW5kaW5nUHJvcHMuZmlyc3RDb250ZXh0LFxuICAgICAgICAgICAgICBfZGVidWdUaGVuYWJsZVN0YXRlOiBwZW5kaW5nUHJvcHMuX2RlYnVnVGhlbmFibGVTdGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm8gPSBjdXJyZW50Ll9kZWJ1Z0luZm87XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAzMTQ1NzI4MjtcbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGwpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSAwKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDApKVxuICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWUpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlKSxcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgICAgICAgICBudWxsID09PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICBsYW5lczogcmVuZGVyTGFuZXMubGFuZXMsXG4gICAgICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHJlbmRlckxhbmVzLmZpcnN0Q29udGV4dCxcbiAgICAgICAgICAgICAgICAgIF9kZWJ1Z1RoZW5hYmxlU3RhdGU6IHJlbmRlckxhbmVzLl9kZWJ1Z1RoZW5hYmxlU3RhdGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbiksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb24pKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHBlbmRpbmdQcm9wcyxcbiAgICAgIG93bmVyLFxuICAgICAgbW9kZSxcbiAgICAgIGxhbmVzXG4gICAgKSB7XG4gICAgICB2YXIgZmliZXJUYWcgPSAwLFxuICAgICAgICByZXNvbHZlZFR5cGUgPSB0eXBlO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHNob3VsZENvbnN0cnVjdCh0eXBlKSAmJiAoZmliZXJUYWcgPSAxKSxcbiAgICAgICAgICAocmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSkpO1xuICAgICAgZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN1cHBvcnRzUmVzb3VyY2VzICYmIHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICAgID8gKChmaWJlclRhZyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgKGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGZpYmVyVGFnKVxuICAgICAgICAgICAgICA/IDI2XG4gICAgICAgICAgICAgIDogaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKVxuICAgICAgICAgICAgICAgID8gMjdcbiAgICAgICAgICAgICAgICA6IDUpKVxuICAgICAgICAgIDogc3VwcG9ydHNSZXNvdXJjZXNcbiAgICAgICAgICAgID8gKChmaWJlclRhZyA9IGdldEhvc3RDb250ZXh0KCkpLFxuICAgICAgICAgICAgICAoZmliZXJUYWcgPSBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHBlbmRpbmdQcm9wcywgZmliZXJUYWcpXG4gICAgICAgICAgICAgICAgPyAyNlxuICAgICAgICAgICAgICAgIDogNSkpXG4gICAgICAgICAgICA6IChmaWJlclRhZyA9IHN1cHBvcnRzU2luZ2xldG9uc1xuICAgICAgICAgICAgICAgID8gaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKVxuICAgICAgICAgICAgICAgICAgPyAyN1xuICAgICAgICAgICAgICAgICAgOiA1XG4gICAgICAgICAgICAgICAgOiA1KTtcbiAgICAgIGVsc2VcbiAgICAgICAgYTogc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBwZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgICAgZmliZXJUYWcgPSA4O1xuICAgICAgICAgICAgbW9kZSB8PSAyNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICh0eXBlID0gcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgICAgKG93bmVyID0gbW9kZSksXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlLmlkICYmXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0eXBlLmlkXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDEyLCB0eXBlLCBrZXksIG93bmVyIHwgMikpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIChrZXkuc3RhdGVOb2RlID0geyBlZmZlY3REdXJhdGlvbjogMCwgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwIH0pLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGtleSA9IGNyZWF0ZUZpYmVyKDEzLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkpLFxuICAgICAgICAgICAgICAoa2V5LmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChrZXkgPSBjcmVhdGVGaWJlcigxOSwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAgICAgKGtleS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSksXG4gICAgICAgICAgICAgIChrZXkubGFuZXMgPSBsYW5lcyksXG4gICAgICAgICAgICAgIGtleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiYgbnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSA5O1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDExO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IDE0O1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gMTY7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRUeXBlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG4gICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJlc29sdmVkVHlwZSArPVxuICAgICAgICAgICAgICAgIFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICAgICAgPyAocGVuZGluZ1Byb3BzID0gXCJudWxsXCIpXG4gICAgICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcbiAgICAgICAgICAgICAgICA/IChwZW5kaW5nUHJvcHMgPSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgOiB2b2lkIDAgIT09IHR5cGUgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG4gICAgICAgICAgICAgICAgICA/ICgocGVuZGluZ1Byb3BzID1cbiAgICAgICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAgICAgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgXCIgLz5cIiksXG4gICAgICAgICAgICAgICAgICAgIChyZXNvbHZlZFR5cGUgPVxuICAgICAgICAgICAgICAgICAgICAgIFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpKVxuICAgICAgICAgICAgICAgICAgOiAocGVuZGluZ1Byb3BzID0gdHlwZW9mIHR5cGUpO1xuICAgICAgICAgICAgZmliZXJUYWcgPSBvd25lclxuICAgICAgICAgICAgICA/IFwibnVtYmVyXCIgPT09IHR5cGVvZiBvd25lci50YWdcbiAgICAgICAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpXG4gICAgICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3duZXIubmFtZVxuICAgICAgICAgICAgICAgICAgPyBvd25lci5uYW1lXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgZmliZXJUYWcgJiZcbiAgICAgICAgICAgICAgKHJlc29sdmVkVHlwZSArPVxuICAgICAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgZmliZXJUYWcgKyBcImAuXCIpO1xuICAgICAgICAgICAgZmliZXJUYWcgPSAyOTtcbiAgICAgICAgICAgIHBlbmRpbmdQcm9wcyA9IEVycm9yKFxuICAgICAgICAgICAgICBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgK1xuICAgICAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgKyBcIi5cIiArIHJlc29sdmVkVHlwZSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICBrZXkgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICAgICAga2V5LmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgIGtleS50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICAgICAga2V5LmxhbmVzID0gbGFuZXM7XG4gICAgICBrZXkuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgICAgIG1vZGUgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICAgIGVsZW1lbnQudHlwZSxcbiAgICAgICAgZWxlbWVudC5rZXksXG4gICAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICAgIGVsZW1lbnQuX293bmVyLFxuICAgICAgICBtb2RlLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIG1vZGUuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICAgICAgZWxlbWVudHMgPSBjcmVhdGVGaWJlcig3LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgICAgIGVsZW1lbnRzLmxhbmVzID0gbGFuZXM7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgICAgIHBlbmRpbmdQcm9wcyA9IGNyZWF0ZUZpYmVyKDIyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gICAgICBwZW5kaW5nUHJvcHMuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgICAgIHBlbmRpbmdQcm9wcy5sYW5lcyA9IGxhbmVzO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgICAgICBfdmlzaWJpbGl0eTogMSxcbiAgICAgICAgX3BlbmRpbmdWaXNpYmlsaXR5OiAxLFxuICAgICAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgICAgICBfdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgIF9jdXJyZW50OiBudWxsLFxuICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZSxcbiAgICAgICAgICAgIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGZpYmVyKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgICAgIFwiQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIGlmICgwID09PSAoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMikpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgfD0gMiksXG4gICAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsID09PSBmaWJlcilcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICBcIkNhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoMCAhPT0gKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgICAgICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IC0zKSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGVuZGluZ1Byb3BzLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICAgICAgcmV0dXJuIHBlbmRpbmdQcm9wcztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICAgICAgY29udGVudCA9IGNyZWF0ZUZpYmVyKDYsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICAgICAgY29udGVudC5sYW5lcyA9IGxhbmVzO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gICAgICBtb2RlID0gY3JlYXRlRmliZXIoXG4gICAgICAgIDQsXG4gICAgICAgIG51bGwgIT09IHBvcnRhbC5jaGlsZHJlbiA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdLFxuICAgICAgICBwb3J0YWwua2V5LFxuICAgICAgICBtb2RlXG4gICAgICApO1xuICAgICAgbW9kZS5sYW5lcyA9IGxhbmVzO1xuICAgICAgbW9kZS5zdGF0ZU5vZGUgPSB7XG4gICAgICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICAgIH07XG4gICAgICByZXR1cm4gbW9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRmliZXJSb290Tm9kZShcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIHRoaXMudGFnID0gMTtcbiAgICAgIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gICAgICB0aGlzLmZpbmlzaGVkV29yayA9XG4gICAgICAgIHRoaXMucGluZ0NhY2hlID1cbiAgICAgICAgdGhpcy5jdXJyZW50ID1cbiAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gICAgICB0aGlzLmNhbGxiYWNrTm9kZSA9XG4gICAgICAgIHRoaXMubmV4dCA9XG4gICAgICAgIHRoaXMucGVuZGluZ0NvbnRleHQgPVxuICAgICAgICB0aGlzLmNvbnRleHQgPVxuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdDb21taXQgPVxuICAgICAgICAgIG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICAgICAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKC0xKTtcbiAgICAgIHRoaXMuZW50YW5nbGVkTGFuZXMgPVxuICAgICAgICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPVxuICAgICAgICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID1cbiAgICAgICAgdGhpcy5maW5pc2hlZExhbmVzID1cbiAgICAgICAgdGhpcy5leHBpcmVkTGFuZXMgPVxuICAgICAgICB0aGlzLndhcm1MYW5lcyA9XG4gICAgICAgIHRoaXMucGluZ2VkTGFuZXMgPVxuICAgICAgICB0aGlzLnN1c3BlbmRlZExhbmVzID1cbiAgICAgICAgdGhpcy5wZW5kaW5nTGFuZXMgPVxuICAgICAgICAgIDA7XG4gICAgICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKDApO1xuICAgICAgdGhpcy5oaWRkZW5VcGRhdGVzID0gY3JlYXRlTGFuZU1hcChudWxsKTtcbiAgICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXg7XG4gICAgICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgICAgIHRoaXMub25DYXVnaHRFcnJvciA9IG9uQ2F1Z2h0RXJyb3I7XG4gICAgICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcbiAgICAgIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgICAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gMDtcbiAgICAgIHRoaXMuZm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuICAgICAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IHRoaXMuZWZmZWN0RHVyYXRpb24gPSAtMDtcbiAgICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICAgIGNvbnRhaW5lckluZm8gPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcbiAgICAgIGZvciAodGFnID0gMDsgMzEgPiB0YWc7IHRhZysrKSBjb250YWluZXJJbmZvLnB1c2gobmV3IFNldCgpKTtcbiAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gXCJoeWRyYXRlUm9vdCgpXCIgOiBcImNyZWF0ZVJvb3QoKVwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoXG4gICAgICBjb250YWluZXJJbmZvLFxuICAgICAgdGFnLFxuICAgICAgaHlkcmF0ZSxcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICBvblVuY2F1Z2h0RXJyb3IsXG4gICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgdHJhbnNpdGlvbkNhbGxiYWNrcyxcbiAgICAgIGZvcm1TdGF0ZVxuICAgICkge1xuICAgICAgY29udGFpbmVySW5mbyA9IG5ldyBGaWJlclJvb3ROb2RlKFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgIGh5ZHJhdGUsXG4gICAgICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgICAgICBmb3JtU3RhdGVcbiAgICAgICk7XG4gICAgICB0YWcgPSAxO1xuICAgICAgITAgPT09IGlzU3RyaWN0TW9kZSAmJiAodGFnIHw9IDI0KTtcbiAgICAgIGlzRGV2VG9vbHNQcmVzZW50ICYmICh0YWcgfD0gMik7XG4gICAgICBpc1N0cmljdE1vZGUgPSBjcmVhdGVGaWJlcigzLCBudWxsLCBudWxsLCB0YWcpO1xuICAgICAgY29udGFpbmVySW5mby5jdXJyZW50ID0gaXNTdHJpY3RNb2RlO1xuICAgICAgaXNTdHJpY3RNb2RlLnN0YXRlTm9kZSA9IGNvbnRhaW5lckluZm87XG4gICAgICB0YWcgPSBjcmVhdGVDYWNoZSgpO1xuICAgICAgcmV0YWluQ2FjaGUodGFnKTtcbiAgICAgIGNvbnRhaW5lckluZm8ucG9vbGVkQ2FjaGUgPSB0YWc7XG4gICAgICByZXRhaW5DYWNoZSh0YWcpO1xuICAgICAgaXNTdHJpY3RNb2RlLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgICAgICBjYWNoZTogdGFnXG4gICAgICB9O1xuICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGlzU3RyaWN0TW9kZSk7XG4gICAgICByZXR1cm4gY29udGFpbmVySW5mbztcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgICAgIGlmICghcGFyZW50Q29tcG9uZW50KSByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcGFyZW50Q29tcG9uZW50ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICAgICAgcmV0dXJuIHBhcmVudENvbXBvbmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyU3luYyhcbiAgICAgIGVsZW1lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICBjYWxsYmFja1xuICAgICkge1xuICAgICAgMCA9PT0gY29udGFpbmVyLnRhZyAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgICBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgMixcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gICAgICByb290RmliZXIsXG4gICAgICBsYW5lLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGluamVjdGVkSG9vayAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdFxuICAgICAgKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIGNvbnRhaW5lciwgZWxlbWVudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yIHx8XG4gICAgICAgICAgICAoKGhhc0xvZ2dlZEVycm9yID0gITApLFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzXCIsXG4gICAgICAgICAgICAgIGVyclxuICAgICAgICAgICAgKSk7XG4gICAgICAgIH1cbiAgICAgIG51bGwgIT09IGluamVjdGVkUHJvZmlsaW5nSG9va3MgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkICYmXG4gICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICAgIHBhcmVudENvbXBvbmVudCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBudWxsID09PSBjb250YWluZXIuY29udGV4dFxuICAgICAgICA/IChjb250YWluZXIuY29udGV4dCA9IHBhcmVudENvbXBvbmVudClcbiAgICAgICAgOiAoY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gcGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlzUmVuZGVyaW5nICYmXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgJiZcbiAgICAgICAgKChkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLlwiLFxuICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgXCJVbmtub3duXCJcbiAgICAgICAgKSk7XG4gICAgICBjb250YWluZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICBjb250YWluZXIucGF5bG9hZCA9IHsgZWxlbWVudDogZWxlbWVudCB9O1xuICAgICAgY2FsbGJhY2sgPSB2b2lkIDAgPT09IGNhbGxiYWNrID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrICYmXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy5cIixcbiAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgKSxcbiAgICAgICAgKGNvbnRhaW5lci5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICBlbGVtZW50ID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIGNvbnRhaW5lciwgbGFuZSk7XG4gICAgICBudWxsICE9PSBlbGVtZW50ICYmXG4gICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSxcbiAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhlbGVtZW50LCByb290RmliZXIsIGxhbmUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICAgICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGZpYmVyICYmIG51bGwgIT09IGZpYmVyLmRlaHlkcmF0ZWQpIHtcbiAgICAgICAgdmFyIGEgPSBmaWJlci5yZXRyeUxhbmU7XG4gICAgICAgIGZpYmVyLnJldHJ5TGFuZSA9IDAgIT09IGEgJiYgYSA8IHJldHJ5TGFuZSA/IGEgOiByZXRyeUxhbmU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgICAgIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAgICAgKGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlKSAmJiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCkge1xuICAgICAgZm9yICh2YXIgbWFwID0gbmV3IE1hcCgpLCBsYW5lID0gMSwgaW5kZXggPSAwOyAzMSA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGdldExhYmVsRm9yTGFuZShsYW5lKTtcbiAgICAgICAgbWFwLnNldChsYW5lLCBsYWJlbCk7XG4gICAgICAgIGxhbmUgKj0gMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHZhciBleHBvcnRzID0ge307XG4gICAgKFwidXNlIHN0cmljdFwiKTtcbiAgICB2YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIiksXG4gICAgICBTY2hlZHVsZXIgPSByZXF1aXJlKFwic2NoZWR1bGVyXCIpLFxuICAgICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgICAgIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgICAgIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksXG4gICAgICBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LmRlYnVnX3RyYWNlX21vZGVcIik7XG4gICAgdmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QudHJhY2luZ19tYXJrZXJcIik7XG4gICAgdmFyIFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb19jYWNoZV9zZW50aW5lbFwiKSxcbiAgICAgIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcixcbiAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICAgICAgUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuICAgICAgZGlzYWJsZWREZXB0aCA9IDAsXG4gICAgICBwcmV2TG9nLFxuICAgICAgcHJldkluZm8sXG4gICAgICBwcmV2V2FybixcbiAgICAgIHByZXZFcnJvcixcbiAgICAgIHByZXZHcm91cCxcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCxcbiAgICAgIHByZXZHcm91cEVuZDtcbiAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICB2YXIgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgcmVlbnRyeSA9ICExO1xuICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFdlYWtNYXAgPyBXZWFrTWFwIDogTWFwXG4gICAgKSgpO1xuICAgIHZhciBjdXJyZW50ID0gbnVsbCxcbiAgICAgIGlzUmVuZGVyaW5nID0gITEsXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gICAgICByZW5kZXJlclZlcnNpb24gPSAkJCRjb25maWcucmVuZGVyZXJWZXJzaW9uLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZSA9ICQkJGNvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgICAgZXh0cmFEZXZUb29sc0NvbmZpZyA9ICQkJGNvbmZpZy5leHRyYURldlRvb2xzQ29uZmlnLFxuICAgICAgZ2V0UHVibGljSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBnZXRSb290SG9zdENvbnRleHQgPSAkJCRjb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9ICQkJGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9ICQkJGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0LFxuICAgICAgY3JlYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBzY2hlZHVsZVRpbWVvdXQgPSAkJCRjb25maWcuc2NoZWR1bGVUaW1lb3V0LFxuICAgICAgY2FuY2VsVGltZW91dCA9ICQkJGNvbmZpZy5jYW5jZWxUaW1lb3V0LFxuICAgICAgbm9UaW1lb3V0ID0gJCQkY29uZmlnLm5vVGltZW91dCxcbiAgICAgIGlzUHJpbWFyeVJlbmRlcmVyID0gJCQkY29uZmlnLmlzUHJpbWFyeVJlbmRlcmVyO1xuICAgICQkJGNvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xuICAgIHZhciBzdXBwb3J0c011dGF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzTXV0YXRpb24sXG4gICAgICBzdXBwb3J0c1BlcnNpc3RlbmNlID0gJCQkY29uZmlnLnN1cHBvcnRzUGVyc2lzdGVuY2UsXG4gICAgICBzdXBwb3J0c0h5ZHJhdGlvbiA9ICQkJGNvbmZpZy5zdXBwb3J0c0h5ZHJhdGlvbixcbiAgICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiAgICAkJCRjb25maWcuYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyO1xuICAgICQkJGNvbmZpZy5hZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgICB2YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkY29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcbiAgICAkJCRjb25maWcucHJlcGFyZVNjb3BlVXBkYXRlO1xuICAgICQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21TY29wZTtcbiAgICB2YXIgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSxcbiAgICAgIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHksXG4gICAgICByZXNvbHZlVXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcucmVzb2x2ZVVwZGF0ZVByaW9yaXR5O1xuICAgICQkJGNvbmZpZy5yZXNvbHZlRXZlbnRUeXBlO1xuICAgICQkJGNvbmZpZy5yZXNvbHZlRXZlbnRUaW1lU3RhbXA7XG4gICAgdmFyIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24gPSAkJCRjb25maWcuc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbixcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5kZXRhY2hEZWxldGVkSW5zdGFuY2U7XG4gICAgJCQkY29uZmlnLnJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjaztcbiAgICB2YXIgbWF5U3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlTdXNwZW5kQ29tbWl0LFxuICAgICAgcHJlbG9hZEluc3RhbmNlID0gJCQkY29uZmlnLnByZWxvYWRJbnN0YW5jZSxcbiAgICAgIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCA9ICQkJGNvbmZpZy5zdGFydFN1c3BlbmRpbmdDb21taXQsXG4gICAgICBzdXNwZW5kSW5zdGFuY2UgPSAkJCRjb25maWcuc3VzcGVuZEluc3RhbmNlLFxuICAgICAgd2FpdEZvckNvbW1pdFRvQmVSZWFkeSA9ICQkJGNvbmZpZy53YWl0Rm9yQ29tbWl0VG9CZVJlYWR5LFxuICAgICAgTm90UGVuZGluZ1RyYW5zaXRpb24gPSAkJCRjb25maWcuTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSAkJCRjb25maWcuSG9zdFRyYW5zaXRpb25Db250ZXh0LFxuICAgICAgcmVzZXRGb3JtSW5zdGFuY2UgPSAkJCRjb25maWcucmVzZXRGb3JtSW5zdGFuY2UsXG4gICAgICBiaW5kVG9Db25zb2xlID0gJCQkY29uZmlnLmJpbmRUb0NvbnNvbGUsXG4gICAgICBzdXBwb3J0c01pY3JvdGFza3MgPSAkJCRjb25maWcuc3VwcG9ydHNNaWNyb3Rhc2tzLFxuICAgICAgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRjb25maWcuc2NoZWR1bGVNaWNyb3Rhc2ssXG4gICAgICBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgPSAkJCRjb25maWcuc3VwcG9ydHNUZXN0U2VsZWN0b3JzLFxuICAgICAgZmluZEZpYmVyUm9vdCA9ICQkJGNvbmZpZy5maW5kRmliZXJSb290LFxuICAgICAgZ2V0Qm91bmRpbmdSZWN0ID0gJCQkY29uZmlnLmdldEJvdW5kaW5nUmVjdCxcbiAgICAgIGdldFRleHRDb250ZW50ID0gJCQkY29uZmlnLmdldFRleHRDb250ZW50LFxuICAgICAgaXNIaWRkZW5TdWJ0cmVlID0gJCQkY29uZmlnLmlzSGlkZGVuU3VidHJlZSxcbiAgICAgIG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUgPSAkJCRjb25maWcubWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSxcbiAgICAgIHNldEZvY3VzSWZGb2N1c2FibGUgPSAkJCRjb25maWcuc2V0Rm9jdXNJZkZvY3VzYWJsZSxcbiAgICAgIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRjb25maWcuc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcixcbiAgICAgIGFwcGVuZENoaWxkID0gJCQkY29uZmlnLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRUZXh0VXBkYXRlLFxuICAgICAgY29tbWl0TW91bnQgPSAkJCRjb25maWcuY29tbWl0TW91bnQsXG4gICAgICBjb21taXRVcGRhdGUgPSAkJCRjb25maWcuY29tbWl0VXBkYXRlLFxuICAgICAgaW5zZXJ0QmVmb3JlID0gJCQkY29uZmlnLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gJCQkY29uZmlnLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGQsXG4gICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5yZXNldFRleHRDb250ZW50LFxuICAgICAgaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLmhpZGVJbnN0YW5jZSxcbiAgICAgIGhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgIHVuaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZUluc3RhbmNlLFxuICAgICAgdW5oaWRlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZVRleHRJbnN0YW5jZSxcbiAgICAgIGNsZWFyQ29udGFpbmVyID0gJCQkY29uZmlnLmNsZWFyQ29udGFpbmVyLFxuICAgICAgY2xvbmVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUluc3RhbmNlLFxuICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZSxcbiAgICAgIGNsb25lSGlkZGVuVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuVGV4dEluc3RhbmNlLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nLFxuICAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2ssXG4gICAgICBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMgPVxuICAgICAgICAkJCRjb25maWcuZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzLFxuICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkgPSAkJCRjb25maWcucmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnksXG4gICAgICBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIsXG4gICAgICBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nID0gJCQkY29uZmlnLmlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcixcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZSA9XG4gICAgICAgICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlID1cbiAgICAgICAgJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZENvbnRhaW5lcixcbiAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5LFxuICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9XG4gICAgICAgICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyLFxuICAgICAgc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMgPVxuICAgICAgICAkJCRjb25maWcuc2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMsXG4gICAgICBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzID1cbiAgICAgICAgJCQkY29uZmlnLmRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MsXG4gICAgICBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MgPSAkJCRjb25maWcuZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzLFxuICAgICAgZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyA9XG4gICAgICAgICQkJGNvbmZpZy5kZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzLFxuICAgICAgdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlLFxuICAgICAgc3VwcG9ydHNSZXNvdXJjZXMgPSAkJCRjb25maWcuc3VwcG9ydHNSZXNvdXJjZXMsXG4gICAgICBpc0hvc3RIb2lzdGFibGVUeXBlID0gJCQkY29uZmlnLmlzSG9zdEhvaXN0YWJsZVR5cGUsXG4gICAgICBnZXRIb2lzdGFibGVSb290ID0gJCQkY29uZmlnLmdldEhvaXN0YWJsZVJvb3QsXG4gICAgICBnZXRSZXNvdXJjZSA9ICQkJGNvbmZpZy5nZXRSZXNvdXJjZSxcbiAgICAgIGFjcXVpcmVSZXNvdXJjZSA9ICQkJGNvbmZpZy5hY3F1aXJlUmVzb3VyY2UsXG4gICAgICByZWxlYXNlUmVzb3VyY2UgPSAkJCRjb25maWcucmVsZWFzZVJlc291cmNlLFxuICAgICAgaHlkcmF0ZUhvaXN0YWJsZSA9ICQkJGNvbmZpZy5oeWRyYXRlSG9pc3RhYmxlLFxuICAgICAgbW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcubW91bnRIb2lzdGFibGUsXG4gICAgICB1bm1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLnVubW91bnRIb2lzdGFibGUsXG4gICAgICBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVIb2lzdGFibGVJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMgPSAkJCRjb25maWcucHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyxcbiAgICAgIG1heVJlc291cmNlU3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlSZXNvdXJjZVN1c3BlbmRDb21taXQsXG4gICAgICBwcmVsb2FkUmVzb3VyY2UgPSAkJCRjb25maWcucHJlbG9hZFJlc291cmNlLFxuICAgICAgc3VzcGVuZFJlc291cmNlID0gJCQkY29uZmlnLnN1c3BlbmRSZXNvdXJjZSxcbiAgICAgIHN1cHBvcnRzU2luZ2xldG9ucyA9ICQkJGNvbmZpZy5zdXBwb3J0c1NpbmdsZXRvbnMsXG4gICAgICByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcucmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgY2xlYXJTaW5nbGV0b24gPSAkJCRjb25maWcuY2xlYXJTaW5nbGV0b24sXG4gICAgICBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcuYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlLFxuICAgICAgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSxcbiAgICAgIGlzSG9zdFNpbmdsZXRvblR5cGUgPSAkJCRjb25maWcuaXNIb3N0U2luZ2xldG9uVHlwZSxcbiAgICAgIHZhbHVlU3RhY2sgPSBbXTtcbiAgICB2YXIgZmliZXJTdGFjayA9IFtdO1xuICAgIHZhciBpbmRleCRqc2NvbXAkMCA9IC0xLFxuICAgICAgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xuICAgIHZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjayxcbiAgICAgIGxvZyQxID0gTWF0aC5sb2csXG4gICAgICBMTjIgPSBNYXRoLkxOMixcbiAgICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCxcbiAgICAgIG5leHRSZXRyeUxhbmUgPSA0MTk0MzA0LFxuICAgICAgc2NoZWR1bGVDYWxsYmFjayQzID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrLFxuICAgICAgc2hvdWxkWWllbGQgPSBTY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQsXG4gICAgICByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgICAgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICAgICAgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksXG4gICAgICBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICAgIE5vcm1hbFByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5LFxuICAgICAgbG9nID0gU2NoZWR1bGVyLmxvZyxcbiAgICAgIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlLFxuICAgICAgcmVuZGVyZXJJRCA9IG51bGwsXG4gICAgICBpbmplY3RlZEhvb2sgPSBudWxsLFxuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IG51bGwsXG4gICAgICBoYXNMb2dnZWRFcnJvciA9ICExLFxuICAgICAgaXNEZXZUb29sc1ByZXNlbnQgPSBcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLFxuICAgICAgb2JqZWN0SXMgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBPYmplY3QuaXMgPyBPYmplY3QuaXMgOiBpcyxcbiAgICAgIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKSxcbiAgICAgIGZvcmtTdGFjayA9IFtdLFxuICAgICAgZm9ya1N0YWNrSW5kZXggPSAwLFxuICAgICAgdHJlZUZvcmtQcm92aWRlciA9IG51bGwsXG4gICAgICB0cmVlRm9ya0NvdW50ID0gMCxcbiAgICAgIGlkU3RhY2sgPSBbXSxcbiAgICAgIGlkU3RhY2tJbmRleCA9IDAsXG4gICAgICB0cmVlQ29udGV4dFByb3ZpZGVyID0gbnVsbCxcbiAgICAgIHRyZWVDb250ZXh0SWQgPSAxLFxuICAgICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IFwiXCIsXG4gICAgICBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICAgICAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIG5lZWRzRXNjYXBpbmcgPSAvW1wiJyY8PlxcblxcdF18Xlxcc3xcXHMkLyxcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbCxcbiAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsLFxuICAgICAgaXNIeWRyYXRpbmcgPSAhMSxcbiAgICAgIGRpZFN1c3BlbmRPckVycm9yREVWID0gITEsXG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGwsXG4gICAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsLFxuICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExLFxuICAgICAgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gPSBFcnJvcihcbiAgICAgICAgXCJIeWRyYXRpb24gTWlzbWF0Y2ggRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBOb01vZGUgPSAwLFxuICAgICAgY29uY3VycmVudFF1ZXVlcyA9IFtdLFxuICAgICAgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCxcbiAgICAgIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICAgICAgY29tbWl0U3RhcnRUaW1lID0gLTAsXG4gICAgICBwcm9maWxlclN0YXJ0VGltZSA9IC0xLjEsXG4gICAgICBwcm9maWxlckVmZmVjdER1cmF0aW9uID0gLTAsXG4gICAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSAhMSxcbiAgICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9ICExLFxuICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID0gITEsXG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSAhMSxcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICExLFxuICAgICAgaXNGbHVzaGluZ1dvcmsgPSAhMSxcbiAgICAgIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMCxcbiAgICAgIGZha2VBY3RDYWxsYmFja05vZGUkMSA9IHt9LFxuICAgICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGwsXG4gICAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMCxcbiAgICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGwsXG4gICAgICBVcGRhdGVTdGF0ZSA9IDAsXG4gICAgICBSZXBsYWNlU3RhdGUgPSAxLFxuICAgICAgRm9yY2VVcGRhdGUgPSAyLFxuICAgICAgQ2FwdHVyZVVwZGF0ZSA9IDMsXG4gICAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgIHZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gITE7XG4gICAgdmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gICAgdmFyIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSAhMSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICAgICAgICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbiAgICAgIH0sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSxcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW10sXG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdLFxuICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpIHx8XG4gICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAhMCAhPT0gaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiA4ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICAhMCAhPT1cbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAmJlxuICAgICAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlciksXG4gICAgICAgIGZpYmVyLm1vZGUgJiA4ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgJiZcbiAgICAgICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKSxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICEwICE9PSBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgJiZcbiAgICAgICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpLFxuICAgICAgICBmaWJlci5tb2RlICYgOCAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcikpO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCAmJlxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW10pKTtcbiAgICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggJiZcbiAgICAgICAgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKFxuICAgICAgICAgIGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoXG4gICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdKSk7XG4gICAgICB2YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgMCA8IHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChcbiAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8IFwiQ29tcG9uZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICB9KSxcbiAgICAgICAgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAwIDwgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoICYmXG4gICAgICAgIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKFxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgXCJDb21wb25lbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgIH0pLFxuICAgICAgICAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXSkpO1xuICAgICAgaWYgKDAgPCBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSkge1xuICAgICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcIixcbiAgICAgICAgICBzb3J0ZWROYW1lc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgMCA8IFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoXG4gICAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlVzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplICYmXG4gICAgICAgICgoc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhcbiAgICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzXG4gICAgICAgICkpLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSAmJlxuICAgICAgICAoKHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbiogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFxuICAgICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lc1xuICAgICAgICApKSxcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4qIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgICAwIDwgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgJiZcbiAgICAgICAgKChzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcykpLFxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbiogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4qIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuIFRvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzXCIsXG4gICAgICAgICAgc29ydGVkTmFtZXNcbiAgICAgICAgKSk7XG4gICAgfTtcbiAgICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpLFxuICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChcbiAgICAgIGZpYmVyLFxuICAgICAgaW5zdGFuY2VcbiAgICApIHtcbiAgICAgIHZhciBzdHJpY3RSb290ID0gbnVsbDtcbiAgICAgIGZvciAodmFyIG5vZGUgPSBmaWJlcjsgbnVsbCAhPT0gbm9kZTsgKVxuICAgICAgICBub2RlLm1vZGUgJiA4ICYmIChzdHJpY3RSb290ID0gbm9kZSksIChub2RlID0gbm9kZS5yZXR1cm4pO1xuICAgICAgbnVsbCA9PT0gc3RyaWN0Um9vdFxuICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkV4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICApXG4gICAgICAgIDogIWRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpICYmXG4gICAgICAgICAgKChub2RlID0gcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmdldChzdHJpY3RSb290KSksXG4gICAgICAgICAgbnVsbCAhPSBmaWJlci50eXBlLmNvbnRleHRUeXBlcyB8fFxuICAgICAgICAgICAgbnVsbCAhPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzIHx8XG4gICAgICAgICAgICAobnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KSkgJiZcbiAgICAgICAgICAodm9pZCAwID09PSBub2RlICYmXG4gICAgICAgICAgICAoKG5vZGUgPSBbXSksIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5zZXQoc3RyaWN0Um9vdCwgbm9kZSkpLFxuICAgICAgICAgIG5vZGUucHVzaChmaWJlcikpO1xuICAgIH07XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlckFycmF5KSB7XG4gICAgICAgIGlmICgwICE9PSBmaWJlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXSxcbiAgICAgICAgICAgIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVihmaXJzdEZpYmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIkxlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLlxcblxcblRoZSBvbGQgQVBJIHdpbGwgYmUgc3VwcG9ydGVkIGluIGFsbCAxNi54IHJlbGVhc2VzLCBidXQgYXBwbGljYXRpb25zIHVzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi5cXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXNcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0XCIsXG4gICAgICAgICAgICAgIHNvcnRlZE5hbWVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICAgIH07XG4gICAgdmFyIFN1c3BlbnNlRXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IhIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIG9mIGB1c2VgIHRvIGludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIuIFlvdSBtdXN0IGVpdGhlciByZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlIGB0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxcblxcblRvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yIGNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYFwiXG4gICAgICApLFxuICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gRXJyb3IoXG4gICAgICAgIFwiU3VzcGVuc2UgRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byB1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCJcbiAgICAgICksXG4gICAgICBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7XG4gICAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBIGxpc3RlbmVyIHdhcyB1bmV4cGVjdGVkbHkgYXR0YWNoZWQgdG8gYSBcIm5vb3BcIiB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGwsXG4gICAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9ICExLFxuICAgICAgY2FsbENvbXBvbmVudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAgICAgICAgIHZhciB3YXNSZW5kZXJpbmcgPSBpc1JlbmRlcmluZztcbiAgICAgICAgICBpc1JlbmRlcmluZyA9ICEwO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsQ29tcG9uZW50SW5ERVYgPVxuICAgICAgICBjYWxsQ29tcG9uZW50W1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbENvbXBvbmVudCksXG4gICAgICBjYWxsUmVuZGVyID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICB2YXIgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgICAgICAgaXNSZW5kZXJpbmcgPSAhMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsUmVuZGVySW5ERVYgPSBjYWxsUmVuZGVyW1wicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJdLmJpbmQoY2FsbFJlbmRlciksXG4gICAgICBjYWxsQ29tcG9uZW50RGlkTW91bnQgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmssIGluc3RhbmNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRNb3VudEluREVWID0gY2FsbENvbXBvbmVudERpZE1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZE1vdW50KSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgIHByZXZTdGF0ZSxcbiAgICAgICAgICBzbmFwc2hvdFxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRVcGRhdGVJbkRFViA9IGNhbGxDb21wb25lbnREaWRVcGRhdGVbXG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCJcbiAgICAgIF0uYmluZChjYWxsQ29tcG9uZW50RGlkVXBkYXRlKSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGluc3RhbmNlLCBlcnJvckluZm8pIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3JJbmZvLnZhbHVlLCB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnREaWRDYXRjaEluREVWID0gY2FsbENvbXBvbmVudERpZENhdGNoW1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudERpZENhdGNoKSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWID0gY2FsbENvbXBvbmVudFdpbGxVbm1vdW50W1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXG4gICAgICBdLmJpbmQoY2FsbENvbXBvbmVudFdpbGxVbm1vdW50KSxcbiAgICAgIGNhbGxDcmVhdGUgPSB7XG4gICAgICAgIFwicmVhY3Qtc3RhY2stYm90dG9tLWZyYW1lXCI6IGZ1bmN0aW9uIChlZmZlY3QpIHtcbiAgICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcbiAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgICBjcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgICAgICByZXR1cm4gKGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxDcmVhdGVJbkRFViA9IGNhbGxDcmVhdGVbXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIl0uYmluZChjYWxsQ3JlYXRlKSxcbiAgICAgIGNhbGxEZXN0cm95ID0ge1xuICAgICAgICBcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiOiBmdW5jdGlvbiAoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIGRlc3Ryb3lcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbGxEZXN0cm95SW5ERVYgPVxuICAgICAgICBjYWxsRGVzdHJveVtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxEZXN0cm95KSxcbiAgICAgIGNhbGxMYXp5SW5pdCA9IHtcbiAgICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGxhenkpIHtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenkuX2luaXQ7XG4gICAgICAgICAgcmV0dXJuIGluaXQobGF6eS5fcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYWxsTGF6eUluaXRJbkRFViA9XG4gICAgICAgIGNhbGxMYXp5SW5pdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKGNhbGxMYXp5SW5pdCksXG4gICAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsLFxuICAgICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDAsXG4gICAgICBjdXJyZW50RGVidWdJbmZvID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dE1hcHM7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSAoZGlkV2FybkFib3V0TWFwcyA9ICExKTtcbiAgICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gICAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuICAgIHZhciBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nID0ge307XG4gICAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAocmV0dXJuRmliZXIsIHdvcmtJblByb2dyZXNzLCBjaGlsZCkge1xuICAgICAgaWYgKFxuICAgICAgICBudWxsICE9PSBjaGlsZCAmJlxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY2hpbGQgJiZcbiAgICAgICAgY2hpbGQuX3N0b3JlICYmXG4gICAgICAgICgoIWNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgJiYgbnVsbCA9PSBjaGlsZC5rZXkpIHx8XG4gICAgICAgICAgMiA9PT0gY2hpbGQuX3N0b3JlLnZhbGlkYXRlZClcbiAgICAgICkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIGNoaWxkLl9zdG9yZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IDE7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlciksXG4gICAgICAgICAgY29tcG9uZW50S2V5ID0gY29tcG9uZW50TmFtZSB8fCBcIm51bGxcIjtcbiAgICAgICAgaWYgKCFvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSkge1xuICAgICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldID0gITA7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZC5fb3duZXI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICAgICAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IFwiXCI7XG4gICAgICAgICAgcmV0dXJuRmliZXIgJiZcbiAgICAgICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci50YWcgJiZcbiAgICAgICAgICAgIChjb21wb25lbnRLZXkgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSkgJiZcbiAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBjb21wb25lbnRLZXkgKyBcImAuXCIpO1xuICAgICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gfHxcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lICYmXG4gICAgICAgICAgICAgIChjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID1cbiAgICAgICAgICAgICAgICBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICtcbiAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lICtcbiAgICAgICAgICAgICAgICBcIj4uXCIpKTtcbiAgICAgICAgICB2YXIgY2hpbGRPd25lckFwcGVuZGl4ID0gXCJcIjtcbiAgICAgICAgICBudWxsICE9IGNoaWxkICYmXG4gICAgICAgICAgICByZXR1cm5GaWJlciAhPT0gY2hpbGQgJiZcbiAgICAgICAgICAgICgoY29tcG9uZW50TmFtZSA9IG51bGwpLFxuICAgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGNoaWxkLnRhZ1xuICAgICAgICAgICAgICA/IChjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjaGlsZCkpXG4gICAgICAgICAgICAgIDogXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGNoaWxkLm5hbWUgJiYgKGNvbXBvbmVudE5hbWUgPSBjaGlsZC5uYW1lKSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgJiZcbiAgICAgICAgICAgICAgKGNoaWxkT3duZXJBcHBlbmRpeCA9XG4gICAgICAgICAgICAgICAgXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjb21wb25lbnROYW1lICsgXCIuXCIpKTtcbiAgICAgICAgICBydW5XaXRoRmliZXJJbkRFVih3b3JrSW5Qcm9ncmVzcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4lcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLFxuICAgICAgICAgICAgICBjaGlsZE93bmVyQXBwZW5kaXhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMCksXG4gICAgICBtb3VudENoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCExKSxcbiAgICAgIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gICAgICBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIHNoZWxsQm91bmRhcnkgPSBudWxsLFxuICAgICAgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxLFxuICAgICAgRm9yY2VTdXNwZW5zZUZhbGxiYWNrID0gMixcbiAgICAgIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCksXG4gICAgICBOb0ZsYWdzID0gMCxcbiAgICAgIEhhc0VmZmVjdCA9IDEsXG4gICAgICBJbnNlcnRpb24gPSAyLFxuICAgICAgTGF5b3V0ID0gNCxcbiAgICAgIFBhc3NpdmUgPSA4LFxuICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q7XG4gICAgdmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2ggPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJlbmRlckxhbmVzID0gMCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsLFxuICAgICAgY3VycmVudEhvb2sgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbCxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExLFxuICAgICAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSAhMSxcbiAgICAgIGxvY2FsSWRDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsLFxuICAgICAgZ2xvYmFsQ2xpZW50SWRDb3VudGVyID0gMCxcbiAgICAgIFJFX1JFTkRFUl9MSU1JVCA9IDI1LFxuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsLFxuICAgICAgaG9va1R5cGVzRGV2ID0gbnVsbCxcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTEsXG4gICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9ICExO1xuICAgIHZhciBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgbGFzdEVmZmVjdDogbnVsbCwgZXZlbnRzOiBudWxsLCBzdG9yZXM6IG51bGwsIG1lbW9DYWNoZTogbnVsbCB9O1xuICAgIH07XG4gICAgdmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgICAgIHVzZTogdXNlLFxuICAgICAgdXNlQ2FsbGJhY2s6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICAgICAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gICAgICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG4gICAgfTtcbiAgICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gICAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUFjdGlvblN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VPcHRpbWlzdGljID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICAgIHZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsLFxuICAgICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGwsXG4gICAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGwsXG4gICAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbCxcbiAgICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgbW91bnRFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24sIGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlT3B0aW1pc3RpY1wiO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW1wZXJhdGl2ZUhhbmRsZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIG1vdW50RWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgICB9LFxuICAgICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlVHJhbnNpdGlvblwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICApIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb24sXG4gICAgICBpbml0aWFsU3RhdGVcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaFxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IHVzZSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDb250ZXh0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUluc2VydGlvbkVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVN0YXRlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlYnVnVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPVxuICAgICAgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiB1c2UsXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKDQsIEluc2VydGlvbiwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUxheW91dEVmZmVjdFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIH0sXG4gICAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVmZXJyZWRWYWx1ZVwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChcbiAgICAgIHBhc3N0aHJvdWdoLFxuICAgICAgcmVkdWNlclxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgICB9LFxuICAgICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FsbGJhY2tcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICBtb3VudEVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VNZW1vXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZHVjZXJcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWJ1Z1ZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgfSxcbiAgICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VEZWZlcnJlZFZhbHVlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ2FjaGVSZWZyZXNoXCI7XG4gICAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICAgIH0sXG4gICAgICB1c2VNZW1vQ2FjaGU6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgICAgfVxuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9XG4gICAgICB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUZvcm1TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIChcbiAgICAgIGFjdGlvbixcbiAgICAgIGluaXRpYWxTdGF0ZVxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUFjdGlvblN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaFxuICAgICkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU9wdGltaXN0aWNcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWxsYmFja1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNvbnRleHRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgICB9LFxuICAgICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB1cGRhdGVFZmZlY3RJbXBsKDIwNDgsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbXBlcmF0aXZlSGFuZGxlXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSW5zZXJ0aW9uRWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTGF5b3V0RWZmZWN0XCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZU1lbW9cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlUmVkdWNlclwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1c2VSZWY6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVJlZlwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTdGF0ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VUcmFuc2l0aW9uXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0sXG4gICAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICAgICAgKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgICAgZ2V0U25hcHNob3QsXG4gICAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlSWRcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VDYWNoZVJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhY2hlUmVmcmVzaFwiO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlTWVtb0NhY2hlOiBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VGb3JtU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQWN0aW9uU3RhdGVcIjtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgfSxcbiAgICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgICAgfSxcbiAgICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUNhbGxiYWNrXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlQ29udGV4dFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH0sXG4gICAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUVmZmVjdFwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0sXG4gICAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUltcGVyYXRpdmVIYW5kbGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VJbnNlcnRpb25FZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VMYXlvdXRFZmZlY3RcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbCg0LCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9LFxuICAgICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlTWVtb1wiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWR1Y2VyXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlUmVmOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VSZWZcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH0sXG4gICAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3RhdGVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRGVidWdWYWx1ZVwiO1xuICAgICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB9LFxuICAgICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZURlZmVycmVkVmFsdWVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZVRyYW5zaXRpb25cIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgICB9LFxuICAgICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICBnZXRTbmFwc2hvdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3RcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoXG4gICAgICAgICAgc3Vic2NyaWJlLFxuICAgICAgICAgIGdldFNuYXBzaG90LFxuICAgICAgICAgIGdldFNlcnZlclNuYXBzaG90XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBcInVzZUlkXCI7XG4gICAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGU7XG4gICAgICB9LFxuICAgICAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VDYWNoZVJlZnJlc2hcIjtcbiAgICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgICAgfSxcbiAgICAgIHVzZU1lbW9DYWNoZTogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID1cbiAgICAgIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKFxuICAgICAgYWN0aW9uXG4gICAgKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IFwidXNlRm9ybVN0YXRlXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiAoXG4gICAgICBhY3Rpb25cbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VBY3Rpb25TdGF0ZVwiO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoXG4gICAgICBwYXNzdGhyb3VnaCxcbiAgICAgIHJlZHVjZXJcbiAgICApIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gXCJ1c2VPcHRpbWlzdGljXCI7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgICB2YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzJDEgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5BYm91dENoaWxkQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcbiAgICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbiAgICB2YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICAgICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgb3duZXIgPSBjdXJyZW50O1xuICAgICAgICAgIGlmIChudWxsICE9PSBvd25lciAmJiBpc1JlbmRlcmluZyAmJiAxID09PSBvd25lci50YWcpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciB8fFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiByZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkIG5ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzIHJlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLlwiLFxuICAgICAgICAgICAgICAgIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXIpIHx8IFwiQSBjb21wb25lbnRcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAoY29tcG9uZW50ID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscylcbiAgICAgICAgICAgID8gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihjb21wb25lbnQpID09PSBjb21wb25lbnRcbiAgICAgICAgICAgIDogITE7XG4gICAgICAgIH0sXG4gICAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgaW5zdCA9IGluc3QuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoaW5zdCksXG4gICAgICAgICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICAod2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSwgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKSk7XG4gICAgICAgICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAgICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGluc3QsIGxhbmUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgICAgICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmXG4gICAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayksICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaykpO1xuICAgICAgICAgIHBheWxvYWQgPSBlbnF1ZXVlVXBkYXRlKGluc3QsIHVwZGF0ZSwgbGFuZSk7XG4gICAgICAgICAgbnVsbCAhPT0gcGF5bG9hZCAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihwYXlsb2FkLCBpbnN0LCBsYW5lKSxcbiAgICAgICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocGF5bG9hZCwgaW5zdCwgbGFuZSkpO1xuICAgICAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChpbnN0LCBsYW5lKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShpbnN0KSxcbiAgICAgICAgICAgIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgbnVsbCAhPT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICh3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spLCAodXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2spKTtcbiAgICAgICAgICBjYWxsYmFjayA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICAgICAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihjYWxsYmFjaywgaW5zdCwgbGFuZSksXG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSk7XG4gICAgICAgICAgbnVsbCAhPT0gaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAmJlxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PVxuICAgICAgICAgICAgICB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQgJiZcbiAgICAgICAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGluc3QsIGxhbmUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVwb3J0R2xvYmFsRXJyb3IgPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXBvcnRFcnJvclxuICAgICAgICAgID8gcmVwb3J0RXJyb3JcbiAgICAgICAgICA6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHdpbmRvdyAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdpbmRvdy5FcnJvckV2ZW50XG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudCA9IG5ldyB3aW5kb3cuRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogITAsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICA/IFN0cmluZyhlcnJvci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHByb2Nlc3MgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcm9jZXNzLmVtaXRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICBjb21wb25lbnROYW1lID0gbnVsbCxcbiAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbCxcbiAgICAgIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IEVycm9yKFxuICAgICAgICBcIlRoaXMgaXMgbm90IGEgcmVhbCBlcnJvci4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgUmVhY3QncyBzZWxlY3RpdmUgaHlkcmF0aW9uIGZlYXR1cmUuIElmIHRoaXMgbGVha3MgaW50byB1c2Vyc3BhY2UsIGl0J3MgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICApLFxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVzID0ge307XG4gICAgdmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9ICExO1xuICAgIHZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyA9IHt9O1xuICAgIHZhciBTVVNQRU5ERURfTUFSS0VSID0ge1xuICAgICAgICBkZWh5ZHJhdGVkOiBudWxsLFxuICAgICAgICB0cmVlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcmV0cnlMYW5lOiAwXG4gICAgICB9LFxuICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSAhMSxcbiAgICAgIHZhbHVlQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlckN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbiAgICB2YXIgcmVuZGVyZXIyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xuICAgIHZhciByZW5kZXJlclNpZ2lsID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCxcbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGwsXG4gICAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gITEsXG4gICAgICBBYm9ydENvbnRyb2xsZXJMb2NhbCA9XG4gICAgICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgICA/IEFib3J0Q29udHJvbGxlclxuICAgICAgICAgIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICAgICAgc2lnbmFsID0gKHRoaXMuc2lnbmFsID0ge1xuICAgICAgICAgICAgICAgICAgYWJvcnRlZDogITEsXG4gICAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hYm9ydGVkID0gITA7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICBzY2hlZHVsZUNhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICAgIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgICAgQ2FjaGVDb250ZXh0ID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgICBDb25zdW1lcjogbnVsbCxcbiAgICAgICAgUHJvdmlkZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gICAgICAgIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICAgICAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXI6IG51bGwsXG4gICAgICAgIF9jdXJyZW50UmVuZGVyZXIyOiBudWxsXG4gICAgICB9LFxuICAgICAgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiAmJlxuICAgICAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcbiAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gITEsXG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gITEsXG4gICAgICBuZWVkc0Zvcm1SZXNldCA9ICExLFxuICAgICAgUG9zc2libHlXZWFrU2V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha1NldCA/IFdlYWtTZXQgOiBTZXQsXG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbCxcbiAgICAgIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGwsXG4gICAgICBpblByb2dyZXNzUm9vdCA9IG51bGwsXG4gICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSAhMSxcbiAgICAgIGhvc3RQYXJlbnQgPSBudWxsLFxuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITEsXG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IG51bGwsXG4gICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gODE5MixcbiAgICAgIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgICAgIGdldENhY2hlRm9yVHlwZTogZnVuY3Rpb24gKHJlc291cmNlVHlwZSkge1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCksXG4gICAgICAgICAgICBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuICAgICAgICAgIHZvaWQgMCA9PT0gY2FjaGVGb3JUeXBlICYmXG4gICAgICAgICAgICAoKGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpKSxcbiAgICAgICAgICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKSk7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlRm9yVHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENPTVBPTkVOVF9UWVBFID0gMCxcbiAgICAgIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDEsXG4gICAgICBST0xFX1RZUEUgPSAyLFxuICAgICAgVEVTVF9OQU1FX1RZUEUgPSAzLFxuICAgICAgVEVYVF9UWVBFID0gNDtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmIFN5bWJvbC5mb3IpIHtcbiAgICAgIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICAgICAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5jb21wb25lbnRcIik7XG4gICAgICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoXCJzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzXCIpO1xuICAgICAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3Iucm9sZVwiKTtcbiAgICAgIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKFwic2VsZWN0b3IudGVzdF9pZFwiKTtcbiAgICAgIFRFWFRfVFlQRSA9IHN5bWJvbEZvcihcInNlbGVjdG9yLnRleHRcIik7XG4gICAgfVxuICAgIHZhciBjb21taXRIb29rcyA9IFtdLFxuICAgICAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gICAgICBOb0NvbnRleHQgPSAwLFxuICAgICAgUmVuZGVyQ29udGV4dCA9IDIsXG4gICAgICBDb21taXRDb250ZXh0ID0gNCxcbiAgICAgIFJvb3RJblByb2dyZXNzID0gMCxcbiAgICAgIFJvb3RGYXRhbEVycm9yZWQgPSAxLFxuICAgICAgUm9vdEVycm9yZWQgPSAyLFxuICAgICAgUm9vdFN1c3BlbmRlZCA9IDMsXG4gICAgICBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNCxcbiAgICAgIFJvb3RDb21wbGV0ZWQgPSA1LFxuICAgICAgUm9vdERpZE5vdENvbXBsZXRlID0gNixcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwLFxuICAgICAgTm90U3VzcGVuZGVkID0gMCxcbiAgICAgIFN1c3BlbmRlZE9uRXJyb3IgPSAxLFxuICAgICAgU3VzcGVuZGVkT25EYXRhID0gMixcbiAgICAgIFN1c3BlbmRlZE9uSW1tZWRpYXRlID0gMyxcbiAgICAgIFN1c3BlbmRlZE9uSW5zdGFuY2UgPSA0LFxuICAgICAgU3VzcGVuZGVkT25JbnN0YW5jZUFuZFJlYWR5VG9Db250aW51ZSA9IDUsXG4gICAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UgPSA2LFxuICAgICAgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlID0gNyxcbiAgICAgIFN1c3BlbmRlZE9uSHlkcmF0aW9uID0gOCxcbiAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkLFxuICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSAhMSxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITEsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMSxcbiAgICAgIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gMCxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcyxcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGwsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITEsXG4gICAgICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMCxcbiAgICAgIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwLFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5LFxuICAgICAgUkVOREVSX1RJTUVPVVRfTVMgPSA1MDAsXG4gICAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbCxcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEsXG4gICAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGwsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDAsXG4gICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbCxcbiAgICAgIE5FU1RFRF9VUERBVEVfTElNSVQgPSA1MCxcbiAgICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGwsXG4gICAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSAhMSxcbiAgICAgIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwLFxuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMCxcbiAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsLFxuICAgICAgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gITEsXG4gICAgICBJTU1FRElBVEVfQ09NTUlUID0gMCxcbiAgICAgIFNVU1BFTkRFRF9DT01NSVQgPSAxLFxuICAgICAgVEhST1RUTEVEX0NPTU1JVCA9IDIsXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbnVsbCxcbiAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gITE7XG4gICAgdmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgICB2YXIgZmFrZUFjdENhbGxiYWNrTm9kZSA9IHt9LFxuICAgICAgcmVzb2x2ZUZhbWlseSA9IG51bGwsXG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSAhMTtcbiAgICB0cnkge1xuICAgICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFzQmFkTWFwUG9seWZpbGwgPSAhMDtcbiAgICB9XG4gICAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSAhMTtcbiAgICB2YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcbiAgICB2YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsLFxuICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGwsXG4gICAgICBvdmVycmlkZVByb3BzID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbCxcbiAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbCxcbiAgICAgIHNjaGVkdWxlVXBkYXRlID0gbnVsbCxcbiAgICAgIHNldEVycm9ySGFuZGxlciA9IG51bGwsXG4gICAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuICAgIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIGlkID0gZmluZEhvb2soZmliZXIsIGlkKTtcbiAgICAgIG51bGwgIT09IGlkICYmXG4gICAgICAgICgocGF0aCA9IGNvcHlXaXRoU2V0SW1wbChpZC5tZW1vaXplZFN0YXRlLCBwYXRoLCAwLCB2YWx1ZSkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKHBhdGggPSBjb3B5V2l0aERlbGV0ZUltcGwoaWQubWVtb2l6ZWRTdGF0ZSwgcGF0aCwgMCkpLFxuICAgICAgICAoaWQubWVtb2l6ZWRTdGF0ZSA9IHBhdGgpLFxuICAgICAgICAoaWQuYmFzZVN0YXRlID0gcGF0aCksXG4gICAgICAgIChmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKSksXG4gICAgICAgIChwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKSk7XG4gICAgfTtcbiAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBpZCA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG4gICAgICBudWxsICE9PSBpZCAmJlxuICAgICAgICAoKG9sZFBhdGggPSBjb3B5V2l0aFJlbmFtZShpZC5tZW1vaXplZFN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKSksXG4gICAgICAgIChpZC5tZW1vaXplZFN0YXRlID0gb2xkUGF0aCksXG4gICAgICAgIChpZC5iYXNlU3RhdGUgPSBvbGRQYXRoKSxcbiAgICAgICAgKGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpKSxcbiAgICAgICAgKG9sZFBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpKSxcbiAgICAgICAgbnVsbCAhPT0gb2xkUGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIob2xkUGF0aCwgZmliZXIsIDIpKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldEltcGwoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgMCwgdmFsdWUpO1xuICAgICAgZmliZXIuYWx0ZXJuYXRlICYmIChmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzKTtcbiAgICAgIHBhdGggPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgbnVsbCAhPT0gcGF0aCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF0aCwgZmliZXIsIDIpO1xuICAgIH07XG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlSW1wbChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCAwKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBwYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IHBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShcbiAgICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgb2xkUGF0aCxcbiAgICAgICAgbmV3UGF0aFxuICAgICAgKTtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZSAmJiAoZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcyk7XG4gICAgICBvbGRQYXRoID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgIG51bGwgIT09IG9sZFBhdGggJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKG9sZFBhdGgsIGZpYmVyLCAyKTtcbiAgICB9O1xuICAgIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMik7XG4gICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMik7XG4gICAgfTtcbiAgICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gICAgfTtcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gICAgfTtcbiAgICBleHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBpZiAoMTMgPT09IGZpYmVyLnRhZykge1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgNjcxMDg4NjQpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXhwb3J0cy5hdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpLFxuICAgICAgICAgIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuICAgICAgICBudWxsICE9PSByb290ICYmIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmliZXIgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIHZhciBsYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGZpYmVyLnBlbmRpbmdMYW5lcyk7XG4gICAgICAgICAgICBpZiAoMCAhPT0gbGFuZXMpIHtcbiAgICAgICAgICAgICAgZmliZXIucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgIGZvciAoZmliZXIuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gMSA8PCAoMzEgLSBjbHozMihsYW5lcykpO1xuICAgICAgICAgICAgICAgIGZpYmVyLmVudGFuZ2xlbWVudHNbMV0gfD0gbGFuZTtcbiAgICAgICAgICAgICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoZmliZXIpO1xuICAgICAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PVxuICAgICAgICAgICAgICAgIE5vQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9XG4gICAgICAgICAgICAgICAgICBub3ckMSgpICsgUkVOREVSX1RJTUVPVVRfTVMpLFxuICAgICAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIChsYW5lcyA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgMikpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbGFuZXMgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGxhbmVzLCBmaWJlciwgMiksXG4gICAgICAgICAgICBmbHVzaFN5bmNXb3JrKCksXG4gICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgMik7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhKSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IENPTVBPTkVOVF9UWVBFLCB2YWx1ZTogY29tcG9uZW50IH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGNvbnRhaW5lckluZm8sXG4gICAgICB0YWcsXG4gICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICBpc1N0cmljdE1vZGUsXG4gICAgICBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLFxuICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzXG4gICAgKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KFxuICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICB0YWcsXG4gICAgICAgICExLFxuICAgICAgICBudWxsLFxuICAgICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JzKSB7XG4gICAgICByZXR1cm4geyAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLCB2YWx1ZTogc2VsZWN0b3JzIH07XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciA9IGZ1bmN0aW9uIChcbiAgICAgIGluaXRpYWxDaGlsZHJlbixcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgIHRhZyxcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyxcbiAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsXG4gICAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgb25DYXVnaHRFcnJvcixcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICBmb3JtU3RhdGVcbiAgICApIHtcbiAgICAgIGluaXRpYWxDaGlsZHJlbiA9IGNyZWF0ZUZpYmVyUm9vdChcbiAgICAgICAgY29udGFpbmVySW5mbyxcbiAgICAgICAgdGFnLFxuICAgICAgICAhMCxcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuLFxuICAgICAgICBoeWRyYXRpb25DYWxsYmFja3MsXG4gICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgaWRlbnRpZmllclByZWZpeCxcbiAgICAgICAgb25VbmNhdWdodEVycm9yLFxuICAgICAgICBvbkNhdWdodEVycm9yLFxuICAgICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgICAgIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gICAgICAgIGZvcm1TdGF0ZVxuICAgICAgKTtcbiAgICAgIGluaXRpYWxDaGlsZHJlbi5jb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7XG4gICAgICBjb250YWluZXJJbmZvID0gaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQ7XG4gICAgICB0YWcgPSByZXF1ZXN0VXBkYXRlTGFuZShjb250YWluZXJJbmZvKTtcbiAgICAgIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IGNyZWF0ZVVwZGF0ZSh0YWcpO1xuICAgICAgaHlkcmF0aW9uQ2FsbGJhY2tzLmNhbGxiYWNrID1cbiAgICAgICAgdm9pZCAwICE9PSBjYWxsYmFjayAmJiBudWxsICE9PSBjYWxsYmFjayA/IGNhbGxiYWNrIDogbnVsbDtcbiAgICAgIGVucXVldWVVcGRhdGUoY29udGFpbmVySW5mbywgaHlkcmF0aW9uQ2FsbGJhY2tzLCB0YWcpO1xuICAgICAgaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQubGFuZXMgPSB0YWc7XG4gICAgICBtYXJrUm9vdFVwZGF0ZWQkMShpbml0aWFsQ2hpbGRyZW4sIHRhZyk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQoaW5pdGlhbENoaWxkcmVuKTtcbiAgICAgIHJldHVybiBpbml0aWFsQ2hpbGRyZW47XG4gICAgfTtcbiAgICBleHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIHZhciBrZXkgPVxuICAgICAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICExO1xuICAgICAgfSBjYXRjaCAoZSQ2KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgICAgIChjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIGtleVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuICAgICAgICAgICAga2V5LmNvbnN0cnVjdG9yLm5hbWUgfHxcbiAgICAgICAgICAgIFwiT2JqZWN0XCJcbiAgICAgICAgKSxcbiAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKGtleSkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgICAgICBrZXk6IG51bGwgPT0ga2V5ID8gbnVsbCA6IFwiXCIgKyBrZXksXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gICAgICB9O1xuICAgIH07XG4gICAgZXhwb3J0cy5jcmVhdGVSb2xlU2VsZWN0b3IgPSBmdW5jdGlvbiAocm9sZSkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFJPTEVfVFlQRSwgdmFsdWU6IHJvbGUgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGVzdE5hbWVTZWxlY3RvciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcmV0dXJuIHsgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLCB2YWx1ZTogaWQgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgIHJldHVybiB7ICQkdHlwZW9mOiBURVhUX1RZUEUsIHZhbHVlOiB0ZXh0IH07XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPbkNhdWdodEVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgICA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICAgIDogXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIixcbiAgICAgICAgcmVjcmVhdGVNZXNzYWdlID1cbiAgICAgICAgICBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIHVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICtcbiAgICAgICAgICAoKGVycm9yQm91bmRhcnlOYW1lIHx8IFwiQW5vbnltb3VzXCIpICsgXCIuXCIpLFxuICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCAhPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiBcIlwiO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5lbnZpcm9ubWVudE5hbWVcbiAgICAgICAgICA/IGJpbmRUb0NvbnNvbGUoXG4gICAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFwiJW9cXG5cXG4lc1xcblxcbiVzXFxuXCIsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgcmVjcmVhdGVNZXNzYWdlXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGVycm9yLmVudmlyb25tZW50TmFtZVxuICAgICAgICAgICAgKSgpXG4gICAgICAgICAgOiBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIiVvXFxuXFxuJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZU1lc3NhZ2UsXG4gICAgICAgICAgICAgIHJlY3JlYXRlTWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2s7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmYXVsdE9uVW5jYXVnaHRFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgZXJyb3JJbmZvKSB7XG4gICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICBlcnJvciA9IGNvbXBvbmVudE5hbWVcbiAgICAgICAgPyBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIlxuICAgICAgICA6IFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy5cIjtcbiAgICAgIHZhciBwcmV2R2V0Q3VycmVudFN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9XG4gICAgICAgICAgbnVsbCAhPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiBcIlwiO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50U3RhY2s7XG4gICAgICB9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiJXNcXG5cXG4lc1xcblwiLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIFwiQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuVmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy5cIlxuICAgICAgICApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZGVmZXJyZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgzMiksIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIGZuKClcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZGlzY3JldGVVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgICBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgyKSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgICAgIGZuKGEsIGIsIGMsIGQpXG4gICAgICAgICk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSksXG4gICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmZpbmRBbGxOb2RlcyA9IGZpbmRBbGxOb2RlcztcbiAgICBleHBvcnRzLmZpbmRCb3VuZGluZ1JlY3RzID0gZnVuY3Rpb24gKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICBzZWxlY3RvcnMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgICBob3N0Um9vdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspXG4gICAgICAgIGhvc3RSb290LnB1c2goZ2V0Qm91bmRpbmdSZWN0KHNlbGVjdG9yc1tpXSkpO1xuICAgICAgZm9yIChzZWxlY3RvcnMgPSBob3N0Um9vdC5sZW5ndGggLSAxOyAwIDwgc2VsZWN0b3JzOyBzZWxlY3RvcnMtLSkge1xuICAgICAgICBpID0gaG9zdFJvb3Rbc2VsZWN0b3JzXTtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgdGFyZ2V0TGVmdCA9IGkueCxcbiAgICAgICAgICAgIHRhcmdldFJpZ2h0ID0gdGFyZ2V0TGVmdCArIGkud2lkdGgsXG4gICAgICAgICAgICB0YXJnZXRUb3AgPSBpLnksXG4gICAgICAgICAgICB0YXJnZXRCb3R0b20gPSB0YXJnZXRUb3AgKyBpLmhlaWdodCxcbiAgICAgICAgICAgIGogPSBzZWxlY3RvcnMgLSAxO1xuICAgICAgICAgIDAgPD0gajtcbiAgICAgICAgICBqLS1cbiAgICAgICAgKVxuICAgICAgICAgIGlmIChzZWxlY3RvcnMgIT09IGopIHtcbiAgICAgICAgICAgIHZhciBvdGhlclJlY3QgPSBob3N0Um9vdFtqXSxcbiAgICAgICAgICAgICAgb3RoZXJMZWZ0ID0gb3RoZXJSZWN0LngsXG4gICAgICAgICAgICAgIG90aGVyUmlnaHQgPSBvdGhlckxlZnQgKyBvdGhlclJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgIG90aGVyVG9wID0gb3RoZXJSZWN0LnksXG4gICAgICAgICAgICAgIG90aGVyQm90dG9tID0gb3RoZXJUb3AgKyBvdGhlclJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJlxuICAgICAgICAgICAgICB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiZcbiAgICAgICAgICAgICAgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJlxuICAgICAgICAgICAgICB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b21cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBob3N0Um9vdC5zcGxpY2Uoc2VsZWN0b3JzLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgIT09IG90aGVyTGVmdCB8fFxuICAgICAgICAgICAgICAgIGkud2lkdGggIT09IG90aGVyUmVjdC53aWR0aCB8fFxuICAgICAgICAgICAgICAgIG90aGVyQm90dG9tIDwgdGFyZ2V0VG9wIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb3AgPiB0YXJnZXRCb3R0b21cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG90aGVyVG9wID4gdGFyZ2V0VG9wICYmXG4gICAgICAgICAgICAgICAgKChvdGhlclJlY3QuaGVpZ2h0ICs9IG90aGVyVG9wIC0gdGFyZ2V0VG9wKSxcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LnkgPSB0YXJnZXRUb3ApKTtcbiAgICAgICAgICAgICAgb3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20gJiZcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LmhlaWdodCA9IHRhcmdldEJvdHRvbSAtIG90aGVyVG9wKTtcbiAgICAgICAgICAgICAgaG9zdFJvb3Quc3BsaWNlKHNlbGVjdG9ycywgMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICB0YXJnZXRUb3AgIT09IG90aGVyVG9wIHx8XG4gICAgICAgICAgICAgICAgaS5oZWlnaHQgIT09IG90aGVyUmVjdC5oZWlnaHQgfHxcbiAgICAgICAgICAgICAgICBvdGhlclJpZ2h0IDwgdGFyZ2V0TGVmdCB8fFxuICAgICAgICAgICAgICAgIG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvdGhlckxlZnQgPiB0YXJnZXRMZWZ0ICYmXG4gICAgICAgICAgICAgICAgKChvdGhlclJlY3Qud2lkdGggKz0gb3RoZXJMZWZ0IC0gdGFyZ2V0TGVmdCksXG4gICAgICAgICAgICAgICAgKG90aGVyUmVjdC54ID0gdGFyZ2V0TGVmdCkpO1xuICAgICAgICAgICAgICBvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQgJiZcbiAgICAgICAgICAgICAgICAob3RoZXJSZWN0LndpZHRoID0gdGFyZ2V0UmlnaHQgLSBvdGhlckxlZnQpO1xuICAgICAgICAgICAgICBob3N0Um9vdC5zcGxpY2Uoc2VsZWN0b3JzLCAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3RSb290O1xuICAgIH07XG4gICAgZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgdmFyIGZpYmVyID0gY29tcG9uZW50Ll9yZWFjdEludGVybmFscztcbiAgICAgIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb21wb25lbnQucmVuZGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiKTtcbiAgICAgICAgY29tcG9uZW50ID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKFwiLFwiKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgICAgXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGNvbXBvbmVudFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tcG9uZW50ID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGNvbXBvbmVudCA/IG51bGwgOiBnZXRQdWJsaWNJbnN0YW5jZShjb21wb25lbnQuc3RhdGVOb2RlKTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpO1xuICAgICAgZmliZXIgPVxuICAgICAgICBudWxsICE9PSBmaWJlciA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoZmliZXIpIDogbnVsbDtcbiAgICAgIHJldHVybiBudWxsID09PSBmaWJlciA/IG51bGwgOiBnZXRQdWJsaWNJbnN0YW5jZShmaWJlci5zdGF0ZU5vZGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZmliZXIgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzO1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZmliZXIpIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudC5yZW5kZXIpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIpO1xuICAgICAgICBjb21wb25lbnQgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oXCIsXCIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsgY29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb21wb25lbnQgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgICBpZiAobnVsbCA9PT0gY29tcG9uZW50KSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChjb21wb25lbnQubW9kZSAmIDgpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCBcIkNvbXBvbmVudFwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSB8fFxuICAgICAgICAgICgoZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSAhMCksXG4gICAgICAgICAgcnVuV2l0aEZpYmVySW5ERVYoY29tcG9uZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaWJlci5tb2RlICYgOFxuICAgICAgICAgICAgICA/IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZVwiLFxuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIiVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uIEluc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGVcIixcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWUsXG4gICAgICAgICAgICAgICAgICBtZXRob2ROYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbXBvbmVudC5zdGF0ZU5vZGUpO1xuICAgIH07XG4gICAgZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cztcbiAgICBleHBvcnRzLmZsdXNoU3luY0Zyb21SZWNvbmNpbGVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSAxO1xuICAgICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICAgICAgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKChzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoMiksIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksIGZuKSlcbiAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uKSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0KSxcbiAgICAgICAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQgJiZcbiAgICAgICAgICAgIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKDAsICExKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMuZmx1c2hTeW5jV29yayA9IGZsdXNoU3luY1dvcms7XG4gICAgZXhwb3J0cy5mb2N1c1dpdGhpbiA9IGZ1bmN0aW9uIChob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gICAgICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycylcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuXCIpO1xuICAgICAgaG9zdFJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICAgICAgc2VsZWN0b3JzID0gZmluZFBhdGhzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgc2VsZWN0b3JzID0gQXJyYXkuZnJvbShzZWxlY3RvcnMpO1xuICAgICAgZm9yIChob3N0Um9vdCA9IDA7IGhvc3RSb290IDwgc2VsZWN0b3JzLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBmaWJlciA9IHNlbGVjdG9yc1tob3N0Um9vdCsrXSxcbiAgICAgICAgICB0YWcgPSBmaWJlci50YWc7XG4gICAgICAgIGlmICghaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICg1ID09PSB0YWcgfHwgMjYgPT09IHRhZyB8fCAyNyA9PT0gdGFnKSAmJlxuICAgICAgICAgICAgc2V0Rm9jdXNJZkZvY3VzYWJsZShmaWJlci5zdGF0ZU5vZGUpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgIHNlbGVjdG9ycy5wdXNoKGZpYmVyKSwgKGZpYmVyID0gZmliZXIuc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICB2YXIgbWF4U2VsZWN0b3JJbmRleCA9IDAsXG4gICAgICAgIG1hdGNoZWROYW1lcyA9IFtdO1xuICAgICAgaG9zdFJvb3QgPSBbZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KSwgMF07XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgaG9zdFJvb3QubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGZpYmVyID0gaG9zdFJvb3RbaW5kZXgrK10sXG4gICAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICAgIHNlbGVjdG9ySW5kZXggPSBob3N0Um9vdFtpbmRleCsrXSxcbiAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgICAgaWYgKCg1ICE9PSB0YWcgJiYgMjYgIT09IHRhZyAmJiAyNyAhPT0gdGFnKSB8fCAhaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAobWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpICYmXG4gICAgICAgICAgICAgIChtYXRjaGVkTmFtZXMucHVzaChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSksXG4gICAgICAgICAgICAgIHNlbGVjdG9ySW5kZXgrKyxcbiAgICAgICAgICAgICAgc2VsZWN0b3JJbmRleCA+IG1heFNlbGVjdG9ySW5kZXggJiZcbiAgICAgICAgICAgICAgICAobWF4U2VsZWN0b3JJbmRleCA9IHNlbGVjdG9ySW5kZXgpKSxcbiAgICAgICAgICAgIHNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoZmliZXIgPSBmaWJlci5jaGlsZDsgbnVsbCAhPT0gZmliZXI7IClcbiAgICAgICAgICAgICAgaG9zdFJvb3QucHVzaChmaWJlciwgc2VsZWN0b3JJbmRleCksIChmaWJlciA9IGZpYmVyLnNpYmxpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKG1heFNlbGVjdG9ySW5kZXggPCBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgaG9zdFJvb3QgPSBbXTtcbiAgICAgICAgICBtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgICBtYXhTZWxlY3RvckluZGV4KytcbiAgICAgICAgKVxuICAgICAgICAgIGhvc3RSb290LnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbbWF4U2VsZWN0b3JJbmRleF0pKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBcImZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4gIFwiICtcbiAgICAgICAgICAobWF0Y2hlZE5hbWVzLmpvaW4oXCIgPiBcIikgK1xuICAgICAgICAgICAgXCJcXG5cXG5ObyBtYXRjaGluZyBjb21wb25lbnQgd2FzIGZvdW5kIGZvcjpcXG4gIFwiKSArXG4gICAgICAgICAgaG9zdFJvb3Quam9pbihcIiA+IFwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBleHBvcnRzLmdldFB1YmxpY1Jvb3RJbnN0YW5jZSA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXIuY2hpbGQpIHJldHVybiBudWxsO1xuICAgICAgc3dpdGNoIChjb250YWluZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbnRlcm5hbHMgPSB7XG4gICAgICAgIGJ1bmRsZVR5cGU6IDEsXG4gICAgICAgIHZlcnNpb246IHJlbmRlcmVyVmVyc2lvbixcbiAgICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogcmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSxcbiAgICAgICAgcmVjb25jaWxlclZlcnNpb246IFwiMTkuMC4wXCJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSBleHRyYURldlRvb2xzQ29uZmlnICYmXG4gICAgICAgIChpbnRlcm5hbHMucmVuZGVyZXJDb25maWcgPSBleHRyYURldlRvb2xzQ29uZmlnKTtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZSA9IG92ZXJyaWRlSG9va1N0YXRlO1xuICAgICAgaW50ZXJuYWxzLm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGg7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wcyA9IG92ZXJyaWRlUHJvcHM7XG4gICAgICBpbnRlcm5hbHMub3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDtcbiAgICAgIGludGVybmFscy5vdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoO1xuICAgICAgaW50ZXJuYWxzLnNjaGVkdWxlVXBkYXRlID0gc2NoZWR1bGVVcGRhdGU7XG4gICAgICBpbnRlcm5hbHMuc2V0RXJyb3JIYW5kbGVyID0gc2V0RXJyb3JIYW5kbGVyO1xuICAgICAgaW50ZXJuYWxzLnNldFN1c3BlbnNlSGFuZGxlciA9IHNldFN1c3BlbnNlSGFuZGxlcjtcbiAgICAgIGludGVybmFscy5zY2hlZHVsZVJlZnJlc2ggPSBzY2hlZHVsZVJlZnJlc2g7XG4gICAgICBpbnRlcm5hbHMuc2NoZWR1bGVSb290ID0gc2NoZWR1bGVSb290O1xuICAgICAgaW50ZXJuYWxzLnNldFJlZnJlc2hIYW5kbGVyID0gc2V0UmVmcmVzaEhhbmRsZXI7XG4gICAgICBpbnRlcm5hbHMuZ2V0Q3VycmVudEZpYmVyID0gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHM7XG4gICAgICBpbnRlcm5hbHMuZ2V0TGFuZUxhYmVsTWFwID0gZ2V0TGFuZUxhYmVsTWFwO1xuICAgICAgaW50ZXJuYWxzLmluamVjdFByb2ZpbGluZ0hvb2tzID0gaW5qZWN0UHJvZmlsaW5nSG9va3M7XG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscyk7XG4gICAgfTtcbiAgICBleHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQ7XG4gICAgfTtcbiAgICBleHBvcnRzLm9ic2VydmVWaXNpYmxlUmVjdHMgPSBmdW5jdGlvbiAoXG4gICAgICBob3N0Um9vdCxcbiAgICAgIHNlbGVjdG9ycyxcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgZnVuY3Rpb24gY29tbWl0SG9vaygpIHtcbiAgICAgICAgdmFyIG5leHRJbnN0YW5jZVJvb3RzID0gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpO1xuICAgICAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgIDAgPiBuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXh0SW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAwID4gaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgJiYgb2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKVxuICAgICAgICB0aHJvdyBFcnJvcihcIlRlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci5cIik7XG4gICAgICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICAgIGNhbGxiYWNrID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICB2YXIgZGlzY29ubmVjdCA9IGNhbGxiYWNrLmRpc2Nvbm5lY3QsXG4gICAgICAgIG9ic2VydmUgPSBjYWxsYmFjay5vYnNlcnZlLFxuICAgICAgICB1bm9ic2VydmUgPSBjYWxsYmFjay51bm9ic2VydmU7XG4gICAgICBjb21taXRIb29rcy5wdXNoKGNvbW1pdEhvb2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IGNvbW1pdEhvb2tzLmluZGV4T2YoY29tbWl0SG9vayk7XG4gICAgICAgICAgMCA8PSBpbmRleCAmJiBjb21taXRIb29rcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4cG9ydHMuc2hvdWxkRXJyb3IgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBzaG91bGRFcnJvckltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zaG91bGRTdXNwZW5kID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5zdGFydEhvc3RUcmFuc2l0aW9uID0gZnVuY3Rpb24gKFxuICAgICAgZm9ybUZpYmVyLFxuICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgYWN0aW9uLFxuICAgICAgZm9ybURhdGFcbiAgICApIHtcbiAgICAgIGlmICg1ICE9PSBmb3JtRmliZXIudGFnKVxuICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICBcIkV4cGVjdGVkIHRoZSBmb3JtIGluc3RhbmNlIHRvIGJlIGEgSG9zdENvbXBvbmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIlxuICAgICAgICApO1xuICAgICAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbihcbiAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgcGVuZGluZ1N0YXRlLFxuICAgICAgICBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgICAgbnVsbCA9PT0gYWN0aW9uXG4gICAgICAgICAgPyBub29wXG4gICAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIG51bGwgPT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgJiZcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJyZXF1ZXN0Rm9ybVJlc2V0IHdhcyBjYWxsZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyBmaXgsIG1vdmUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgdmFyIHJlc2V0U3RhdGVRdWV1ZSA9XG4gICAgICAgICAgICAgICAgZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5uZXh0LnF1ZXVlO1xuICAgICAgICAgICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgICAgICAgICAgZm9ybUZpYmVyLFxuICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVRdWV1ZSxcbiAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmb3JtRmliZXIpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oZm9ybURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXBkYXRlQ29udGFpbmVyID0gZnVuY3Rpb24gKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50LFxuICAgICAgICBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBsYW5lLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudENvbXBvbmVudCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgICByZXR1cm4gbGFuZTtcbiAgICB9O1xuICAgIGV4cG9ydHMudXBkYXRlQ29udGFpbmVyU3luYyA9IHVwZGF0ZUNvbnRhaW5lclN5bmM7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0pLFxuICAobW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzKSxcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSkpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRjb25maWciLCJmaW5kSG9vayIsImZpYmVyIiwiaWQiLCJtZW1vaXplZFN0YXRlIiwibmV4dCIsImNvcHlXaXRoU2V0SW1wbCIsIm9iaiIsInBhdGgiLCJpbmRleCIsInZhbHVlIiwibGVuZ3RoIiwia2V5IiwidXBkYXRlZCIsImlzQXJyYXlJbXBsIiwic2xpY2UiLCJhc3NpZ24iLCJjb3B5V2l0aFJlbmFtZSIsIm9sZFBhdGgiLCJuZXdQYXRoIiwiY29uc29sZSIsIndhcm4iLCJpIiwiY29weVdpdGhSZW5hbWVJbXBsIiwib2xkS2V5Iiwic3BsaWNlIiwiY29weVdpdGhEZWxldGVJbXBsIiwic2hvdWxkU3VzcGVuZEltcGwiLCJzaG91bGRFcnJvckltcGwiLCJjcmVhdGVGaWJlciIsInRhZyIsInBlbmRpbmdQcm9wcyIsIm1vZGUiLCJGaWJlck5vZGUiLCJzY2hlZHVsZVJvb3QiLCJyb290IiwiZWxlbWVudCIsImNvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJ1cGRhdGVDb250YWluZXJTeW5jIiwiZmx1c2hTeW5jV29yayIsInNjaGVkdWxlUmVmcmVzaCIsInVwZGF0ZSIsInJlc29sdmVGYW1pbHkiLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJjdXJyZW50Iiwic2V0UmVmcmVzaEhhbmRsZXIiLCJoYW5kbGVyIiwid2FybkludmFsaWRIb29rQWNjZXNzIiwiZXJyb3IiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJub29wIiwid2FybkZvck1pc3NpbmdLZXkiLCJzZXRUb1NvcnRlZFN0cmluZyIsInNldCIsImFycmF5IiwiZm9yRWFjaCIsInB1c2giLCJzb3J0Iiwiam9pbiIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwidHlwZSIsIiQkdHlwZW9mIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsImRpc3BsYXlOYW1lIiwibmFtZSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0NPTlNVTUVSX1RZUEUiLCJfY29udGV4dCIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJpbm5lclR5cGUiLCJyZW5kZXIiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJfcGF5bG9hZCIsIl9pbml0IiwieCIsImdldENvbXBvbmVudE5hbWVGcm9tRmliZXIiLCJfZGVidWdJbmZvIiwicmV0dXJuIiwiZGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwibG9nIiwicHJldkluZm8iLCJpbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJncm91cCIsInByZXZHcm91cENvbGxhcHNlZCIsImdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInByZWZpeCIsIkVycm9yIiwibWF0Y2giLCJzdGFjayIsInRyaW0iLCJzdWZmaXgiLCJpbmRleE9mIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwicmVlbnRyeSIsImZyYW1lIiwiY29tcG9uZW50RnJhbWVDYWNoZSIsImdldCIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJIIiwiUnVuSW5Sb290RnJhbWUiLCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJwcm90b3R5cGUiLCJSZWZsZWN0IiwiY29udHJvbCIsImNhbGwiLCJ4JDAiLCJ4JDEiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsImRlc2NyaWJlRmliZXIiLCJnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QiLCJ3b3JrSW5Qcm9ncmVzcyIsImRlYnVnSW5mbyIsImVudHJ5IiwiSlNDb21waWxlcl90ZW1wX2NvbnN0IiwiZW52IiwiSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0IiwibWVzc2FnZSIsImdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYiLCJydW5XaXRoRmliZXJJbkRFViIsImNhbGxiYWNrIiwiYXJnMCIsImFyZzEiLCJhcmcyIiwiYXJnMyIsImFyZzQiLCJwcmV2aW91c0ZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwiaXNSZW5kZXJpbmciLCJnZXROZWFyZXN0TW91bnRlZEZpYmVyIiwibm9kZSIsIm5lYXJlc3RNb3VudGVkIiwiYWx0ZXJuYXRlIiwiZmxhZ3MiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJjaGlsZCIsInNpYmxpbmciLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJzdGF0ZU5vZGUiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwiLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJpbmRleCRqc2NvbXAkMCIsImZpYmVyU3RhY2siLCJ2YWx1ZVN0YWNrIiwiY2x6MzJGYWxsYmFjayIsImxvZyQxIiwiTE4yIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJwZW5kaW5nU3luY0xhbmVzIiwiZ2V0TmV4dExhbmVzIiwid2lwTGFuZXMiLCJwZW5kaW5nTGFuZXMiLCJuZXh0TGFuZXMiLCJzdXNwZW5kZWRMYW5lcyIsInBpbmdlZExhbmVzIiwid2FybUxhbmVzIiwiZmluaXNoZWRMYW5lcyIsIm5vbklkbGVQZW5kaW5nTGFuZXMiLCJjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nIiwicmVuZGVyTGFuZXMiLCJjb21wdXRlRXhwaXJhdGlvblRpbWUiLCJjdXJyZW50VGltZSIsImNsYWltTmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFRyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0UmV0cnlMYW5lIiwibmV4dFJldHJ5TGFuZSIsImNyZWF0ZUxhbmVNYXAiLCJpbml0aWFsIiwibGFuZU1hcCIsIm1hcmtSb290VXBkYXRlZCQxIiwidXBkYXRlTGFuZSIsIm1hcmtSb290RmluaXNoZWQiLCJyZW1haW5pbmdMYW5lcyIsInNwYXduZWRMYW5lIiwidXBkYXRlZExhbmVzIiwic3VzcGVuZGVkUmV0cnlMYW5lcyIsInByZXZpb3VzbHlQZW5kaW5nTGFuZXMiLCJleHBpcmVkTGFuZXMiLCJlbnRhbmdsZWRMYW5lcyIsImVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIiwic2hlbGxTdXNwZW5kQ291bnRlciIsImVudGFuZ2xlbWVudHMiLCJleHBpcmF0aW9uVGltZXMiLCJoaWRkZW5VcGRhdGVzIiwiY2x6MzIiLCJoaWRkZW5VcGRhdGVzRm9yTGFuZSIsIm1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lIiwic3Bhd25lZExhbmVJbmRleCIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwiYWRkRmliZXJUb0xhbmVzTWFwIiwiaXNEZXZUb29sc1ByZXNlbnQiLCJwZW5kaW5nVXBkYXRlcnNMYW5lTWFwIiwiYWRkIiwibW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkIiwibWVtb2l6ZWRVcGRhdGVycyIsInNpemUiLCJoYXMiLCJjbGVhciIsImxhbmVzVG9FdmVudFByaW9yaXR5IiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiaG9vayIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwicmVuZGVyZXJJRCIsImluamVjdCIsImluamVjdGVkSG9vayIsImVyciIsImNoZWNrRENFIiwib25Db21taXRSb290JDEiLCJldmVudFByaW9yaXR5Iiwib25Db21taXRGaWJlclJvb3QiLCJkaWRFcnJvciIsInNjaGVkdWxlclByaW9yaXR5IiwiSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5JDEiLCJJZGxlUHJpb3JpdHkiLCJoYXNMb2dnZWRFcnJvciIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwidW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUiLCJzZXRTdHJpY3RNb2RlIiwiaW5qZWN0UHJvZmlsaW5nSG9va3MiLCJwcm9maWxpbmdIb29rcyIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJtYXJrQ29tbWl0U3RvcHBlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQiLCJtYXJrUmVuZGVyU3RhcnRlZCIsIm1hcmtSZW5kZXJTdG9wcGVkIiwibWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkIiwiaXMiLCJ5IiwiY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIiLCJzb3VyY2UiLCJleGlzdGluZyIsIkNhcHR1cmVkU3RhY2tzIiwicHVzaFRyZWVGb3JrIiwidG90YWxDaGlsZHJlbiIsIndhcm5JZk5vdEh5ZHJhdGluZyIsImZvcmtTdGFjayIsImZvcmtTdGFja0luZGV4IiwidHJlZUZvcmtDb3VudCIsInRyZWVGb3JrUHJvdmlkZXIiLCJwdXNoVHJlZUlkIiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0SWQiLCJ0cmVlQ29udGV4dE92ZXJmbG93IiwidHJlZUNvbnRleHRQcm92aWRlciIsImJhc2VJZFdpdGhMZWFkaW5nQml0IiwiYmFzZUxlbmd0aCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwidG9TdHJpbmciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicG9wVHJlZUNvbnRleHQiLCJpc0h5ZHJhdGluZyIsInJlcXVpcmVkQ29udGV4dCIsImMiLCJwdXNoSG9zdENvbnRhaW5lciIsIm5leHRSb290SW5zdGFuY2UiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwiY29udGV4dFN0YWNrQ3Vyc29yIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwiaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciIsIm5leHRDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBvcEhvc3RDb250ZXh0IiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJIb3N0VHJhbnNpdGlvbkNvbnRleHQiLCJfY3VycmVudFZhbHVlIiwiTm90UGVuZGluZ1RyYW5zaXRpb24iLCJfY3VycmVudFZhbHVlMiIsImZpbmROb3RhYmxlTm9kZSIsImluZGVudCIsInNlcnZlclByb3BzIiwic2VydmVyVGFpbCIsImNoaWxkcmVuIiwiZGlzdGFuY2VGcm9tTGVhZiIsImluZGVudGF0aW9uIiwicmVwZWF0IiwiYWRkZWQiLCJyZW1vdmVkIiwiZGVzY3JpYmVGaWJlclR5cGUiLCJkZXNjcmliZVRleHROb2RlIiwiY29udGVudCIsIm1heExlbmd0aCIsIm5lZWRzRXNjYXBpbmciLCJ0ZXN0IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlc2NyaWJlVGV4dERpZmYiLCJjbGllbnRUZXh0IiwiZmlyc3REaWZmIiwiY2hhckNvZGVBdCIsIm9iamVjdE5hbWUiLCJvYmplY3QiLCJtIiwicDAiLCJkZXNjcmliZVZhbHVlIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwicHJvcE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsImpzb25Qcm9wTmFtZSIsIlN0cmluZyIsImRlc2NyaWJlUHJvcFZhbHVlIiwiZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQiLCJyb3dQcmVmaXgiLCJyZW1haW5pbmdSb3dMZW5ndGgiLCJwcm9wZXJ0aWVzIiwicHJvcFZhbHVlIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRQcm9wVmFsdWUiLCJfcHJvcE5hbWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJNYXAiLCJwcm9wTmFtZSRqc2NvbXAkMCIsInRvTG93ZXJDYXNlIiwiX3Byb3BOYW1lMiIsIm1heExlbmd0aCRqc2NvbXAkMCIsInNlcnZlclByb3BOYW1lIiwiZGVsZXRlIiwia2V5cyIsImRlc2NyaWJlU2libGluZ0ZpYmVyIiwiZGVzY3JpYmVOb2RlIiwic2tpcFRvTm9kZSIsInNlcnZlckNvbXBvbmVudE5hbWUiLCJkZXNjcmliZURpZmYiLCJyb290Tm9kZSIsImJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUiLCJoeWRyYXRpb25EaWZmUm9vdERFViIsInNpYmxpbmdzIiwid2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UiLCJyZWplY3RlZENhbmRpZGF0ZSIsImRpZFN1c3BlbmRPckVycm9yREVWIiwiZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyIsInRocm93T25IeWRyYXRpb25NaXNtYXRjaCIsImRpZmYiLCJkaWZmUm9vdCIsInF1ZXVlSHlkcmF0aW9uRXJyb3IiLCJIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJob3N0Q29udGV4dCIsInN1cHBvcnRzSHlkcmF0aW9uIiwiaHlkcmF0ZUluc3RhbmNlIiwibWVtb2l6ZWRQcm9wcyIsInBvcFRvTmV4dEhvc3RQYXJlbnQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsInJvb3RPclNpbmdsZXRvbkNvbnRleHQiLCJwb3BIeWRyYXRpb25TdGF0ZSIsInNob3VsZENsZWFyIiwic3VwcG9ydHNTaW5nbGV0b25zIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImRlaHlkcmF0ZWQiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwiaHlkcmF0aW9uRXJyb3JzIiwiZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncyIsImZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMiLCJlbmRJbmRleCIsImNvbmN1cnJlbnRRdWV1ZXNJbmRleCIsImNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJxdWV1ZSIsInBlbmRpbmciLCJtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsImVucXVldWVVcGRhdGUkMSIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZSIsImdldFJvb3RGb3JVcGRhdGVkRmliZXIiLCJlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUiLCJzb3VyY2VGaWJlciIsImlzSGlkZGVuIiwiY2hpbGRMYW5lcyIsIl92aXNpYmlsaXR5IiwibmVzdGVkVXBkYXRlQ291bnQiLCJORVNURURfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Iiwicm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsIk5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJwdXNoTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwicHJldkVmZmVjdER1cmF0aW9uIiwicHJvZmlsZXJFZmZlY3REdXJhdGlvbiIsInBvcE5lc3RlZEVmZmVjdER1cmF0aW9ucyIsImVsYXBzZWRUaW1lIiwiYnViYmxlTmVzdGVkRWZmZWN0RHVyYXRpb25zIiwic3RhcnRQcm9maWxlclRpbWVyIiwicHJvZmlsZXJTdGFydFRpbWUiLCJub3ciLCJhY3R1YWxTdGFydFRpbWUiLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZER1cmF0aW9uIiwiYWN0dWFsRHVyYXRpb24iLCJzZWxmQmFzZUR1cmF0aW9uIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmRJbmNvbXBsZXRlRHVyYXRpb24iLCJyZWNvcmRFZmZlY3REdXJhdGlvbiIsInN0YXJ0RWZmZWN0VGltZXIiLCJ0cmFuc2ZlckFjdHVhbER1cmF0aW9uIiwiZW5zdXJlUm9vdElzU2NoZWR1bGVkIiwibGFzdFNjaGVkdWxlZFJvb3QiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsiLCJhY3RRdWV1ZSIsImRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCIsInNjaGVkdWxlSW1tZWRpYXRlVGFzayIsInByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayIsImRpZFNjaGVkdWxlTWljcm90YXNrIiwiZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwiLCJzeW5jVHJhbnNpdGlvbkxhbmVzIiwib25seUxlZ2FjeSIsImlzRmx1c2hpbmdXb3JrIiwiZGlkUGVyZm9ybVNvbWVXb3JrIiwicGVyZm9ybVN5bmNXb3JrT25Sb290Iiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSIsInNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24iLCJub3ckMSIsInByZXYiLCJzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrIiwiZXhwaXJhdGlvblRpbWUiLCJjYWxsYmFja05vZGUiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiIsIlN1c3BlbmRlZE9uRGF0YSIsImNhbmNlbFBlbmRpbmdDb21taXQiLCJjYW5jZWxDYWxsYmFjayIsImNhbGxiYWNrUHJpb3JpdHkiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlJDEiLCJwZXJmb3JtV29ya09uUm9vdFZpYVNjaGVkdWxlclRhc2siLCJiaW5kIiwic2NoZWR1bGVDYWxsYmFjayQzIiwiZGlkVGltZW91dCIsIm5lc3RlZFVwZGF0ZVNjaGVkdWxlZCIsImN1cnJlbnRVcGRhdGVJc05lc3RlZCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAiLCJwZXJmb3JtV29ya09uUm9vdCIsImNhbmNlbENhbGxiYWNrJDEiLCJjYiIsInN1cHBvcnRzTWljcm90YXNrcyIsInNjaGVkdWxlTWljcm90YXNrIiwiZXhlY3V0aW9uQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJDb21taXRDb250ZXh0IiwiTm9Db250ZXh0IiwicmVxdWVzdFRyYW5zaXRpb25MYW5lIiwiZW50YW5nbGVBc3luY0FjdGlvbiIsInRyYW5zaXRpb24iLCJ0aGVuYWJsZSIsImN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMiLCJlbnRhbmdsZWRMaXN0ZW5lcnMiLCJjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50IiwiY3VycmVudEVudGFuZ2xlZExhbmUiLCJjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwicmVzb2x2ZSIsInBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUiLCJsaXN0ZW5lcnMiLCJjaGFpblRoZW5hYmxlVmFsdWUiLCJyZXN1bHQiLCJ0aGVuYWJsZVdpdGhPdmVycmlkZSIsInJlYXNvbiIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsInVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwiZmlyc3RCYXNlVXBkYXRlIiwibGFzdEJhc2VVcGRhdGUiLCJzaGFyZWQiLCJoaWRkZW5DYWxsYmFja3MiLCJjYWxsYmFja3MiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3JlYXRlVXBkYXRlIiwiVXBkYXRlU3RhdGUiLCJwYXlsb2FkIiwiZW5xdWV1ZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjb21wb25lbnROYW1lIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUiLCJjYXB0dXJlZFVwZGF0ZSIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsImNsb25lIiwic3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsImRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsImluc3RhbmNlJGpzY29tcCQwIiwiaGFzRm9yY2VVcGRhdGUiLCJwZW5kaW5nUXVldWUiLCJsYXN0UGVuZGluZ1VwZGF0ZSIsImZpcnN0UGVuZGluZ1VwZGF0ZSIsIm5ld1N0YXRlIiwiaXNIaWRkZW5VcGRhdGUiLCJwYXJ0aWFsU3RhdGUiLCJuZXh0UHJvcHMiLCJpbnN0YW5jZSIsIlJlcGxhY2VTdGF0ZSIsImlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJuZXh0U3RhdGUiLCJDYXB0dXJlVXBkYXRlIiwiRm9yY2VVcGRhdGUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJjb21taXRIaWRkZW5DYWxsYmFja3MiLCJjb21taXRDYWxsYmFja3MiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsIm9iamVjdElzIiwia2V5c0EiLCJrZXlzQiIsImN1cnJlbnRLZXkiLCJjcmVhdGVUaGVuYWJsZVN0YXRlIiwiZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlIiwidGhlbmFibGVzIiwiaXNUaGVuYWJsZVJlc29sdmVkIiwibm9vcCQxIiwidHJhY2tVc2VkVGhlbmFibGUiLCJ0aGVuYWJsZVN0YXRlIiwiZGlkVXNlUHJvbWlzZSIsInRyYWNrZWRUaGVuYWJsZXMiLCJjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaCIsImZ1bGZpbGxlZFZhbHVlIiwiZnVsZmlsbGVkVGhlbmFibGUiLCJyZWplY3RlZFRoZW5hYmxlIiwic3VzcGVuZGVkVGhlbmFibGUiLCJuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViIsIlN1c3BlbnNlRXhjZXB0aW9uIiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJyZWplY3RlZFJlYXNvbiIsInB1c2hEZWJ1Z0luZm8iLCJwcmV2aW91c0RlYnVnSW5mbyIsImN1cnJlbnREZWJ1Z0luZm8iLCJjb25jYXQiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJyZXR1cm5GaWJlciIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJlcnJvcmVkS2V5IiwidW53cmFwVGhlbmFibGUiLCJ0aGVuYWJsZUluZGV4Q291bnRlciQxIiwidGhlbmFibGVTdGF0ZSQxIiwiY29lcmNlUmVmIiwicmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwibmV3Q2hpbGQiLCJSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiaW52YWxpZENoaWxkIiwicGFyZW50TmFtZSIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5PblN5bWJvbFR5cGUiLCJvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nIiwiY3JlYXRlQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0aW9ucyIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJ1c2VGaWJlciIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJ0ZXh0Q29udGVudCIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJfZGVidWdPd25lciIsInVwZGF0ZUVsZW1lbnQiLCJlbGVtZW50VHlwZSIsInVwZGF0ZUZyYWdtZW50IiwiaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nIiwiY2FsbExhenlJbml0SW5ERVYiLCJfb3duZXIiLCJ1cGRhdGVQb3J0YWwiLCJwb3J0YWwiLCJjb250YWluZXJJbmZvIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJmcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfcHJldkRlYnVnSW5mbyIsInJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24iLCJ1cGRhdGVTbG90Iiwib2xkRmliZXIiLCJ1cGRhdGVGcm9tTWFwIiwibmV3SWR4IiwiX3ByZXZEZWJ1Z0luZm83Iiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsIlNldCIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsInN0ZXAiLCJkb25lIiwicmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsIiwicHJldkRlYnVnSW5mbyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJlbnRyaWVzIiwiZGlkV2FybkFib3V0TWFwcyIsImZpcnN0Q2hpbGRGaWJlciIsInB1c2hIaWRkZW5Db250ZXh0IiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzIiwiZW50YW5nbGVkUmVuZGVyTGFuZXMiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IiLCJjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yIiwiYmFzZUxhbmVzIiwicmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayIsInBvcEhpZGRlbkNvbnRleHQiLCJwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIiLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwiU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2siLCJzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciIsInNoZWxsQm91bmRhcnkiLCJwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyIiwicmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrIiwicG9wU3VzcGVuc2VIYW5kbGVyIiwiZmluZEZpcnN0U3VzcGVuZGVkIiwicm93Iiwic3RhdGUiLCJpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIiwiaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2siLCJyZXZlYWxPcmRlciIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsInVwZGF0ZUhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSIsImRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCIsInRhYmxlIiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsIndhcm5PblVzZUZvcm1TdGF0ZUluRGV2IiwiZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlIiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsImlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzIiwicmVuZGVyV2l0aEhvb2tzIiwiQ29tcG9uZW50Iiwic2Vjb25kQXJnIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsInNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWIiwiTm9Nb2RlIiwiY2FsbENvbXBvbmVudEluREVWIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzIiwicmVuZGVyV2l0aEhvb2tzQWdhaW4iLCJmaW5pc2hSZW5kZXJpbmdIb29rcyIsImRlcGVuZGVuY2llcyIsImZpcnN0Q29udGV4dCIsIl9kZWJ1Z1RoZW5hYmxlU3RhdGUiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsImN1cnJlbnRIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSIsInRoZW5hYmxlSW5kZXhDb3VudGVyIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImNoZWNrSWZDb250ZXh0Q2hhbmdlZCIsImRpZFdhcm5BYm91dFVzZVdyYXBwZWRJblRyeUNhdGNoIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJsYXN0RWZmZWN0IiwiZXZlbnRzIiwic3RvcmVzIiwibWVtb0NhY2hlIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwiVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCIsImRpc3BhdGNoZXIiLCJtYXliZVRoZW5hYmxlIiwidXNlU3RhdGUiLCJ1c2VUaGVuYWJsZSIsImNoZWNrRGlkUmVuZGVySWRIb29rIiwiZGlkUmVuZGVySWRIb29rIiwibG9jYWxJZENvdW50ZXIiLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzT25VbndpbmQiLCJtb3VudFdvcmtJblByb2dyZXNzSG9vayIsImJhc2VRdWV1ZSIsInVwZGF0ZVdvcmtJblByb2dyZXNzSG9vayIsIm5leHRDdXJyZW50SG9vayIsIm5leHRXb3JrSW5Qcm9ncmVzc0hvb2siLCJ1c2UiLCJ1c2FibGUiLCJyZWFkQ29udGV4dCIsInVzZU1lbW9DYWNoZSIsImRhdGEiLCJtYXAiLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiQXJyYXkiLCJSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMIiwiYmFzaWNTdGF0ZVJlZHVjZXIiLCJhY3Rpb24iLCJtb3VudFJlZHVjZXIiLCJyZWR1Y2VyIiwiaW5pdGlhbEFyZyIsImluaXQiLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoUmVkdWNlckFjdGlvbiIsInVwZGF0ZVJlZHVjZXIiLCJ1cGRhdGVSZWR1Y2VySW1wbCIsImJhc2VGaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsInJldmVydExhbmUiLCJoYXNFYWdlclN0YXRlIiwiZWFnZXJTdGF0ZSIsInJlcmVuZGVyUmVkdWNlciIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50U3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwibW91bnRFZmZlY3QiLCJzdWJzY3JpYmVUb1N0b3JlIiwicHVzaEVmZmVjdCIsIkhhc0VmZmVjdCIsIlBhc3NpdmUiLCJ1cGRhdGVTdG9yZUluc3RhbmNlIiwiZGVzdHJveSIsInVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlIiwiaXNIeWRyYXRpbmckanNjb21wJDAiLCJjYWNoZWRTbmFwc2hvdCIsImNyZWF0ZSIsInVwZGF0ZUVmZmVjdEltcGwiLCJyZW5kZXJlZFNuYXBzaG90IiwiaW5zdCIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJsYXRlc3RHZXRTbmFwc2hvdCIsIm5leHRWYWx1ZSIsInNjaGVkdWxlVXBkYXRlT25GaWJlciIsIm1vdW50U3RhdGVJbXBsIiwiaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIiLCJtb3VudFN0YXRlIiwiZGlzcGF0Y2hTZXRTdGF0ZSIsIm1vdW50T3B0aW1pc3RpYyIsInBhc3N0aHJvdWdoIiwiZGlzcGF0Y2hPcHRpbWlzdGljU2V0U3RhdGUiLCJ1cGRhdGVPcHRpbWlzdGljIiwidXBkYXRlT3B0aW1pc3RpY0ltcGwiLCJyZXJlbmRlck9wdGltaXN0aWMiLCJkaXNwYXRjaEFjdGlvblN0YXRlIiwiYWN0aW9uUXVldWUiLCJzZXRQZW5kaW5nU3RhdGUiLCJzZXRTdGF0ZSIsImlzUmVuZGVyUGhhc2VVcGRhdGUiLCJhY3Rpb25Ob2RlIiwiaXNUcmFuc2l0aW9uIiwibGlzdGVuZXIiLCJUIiwicnVuQWN0aW9uU3RhdGVBY3Rpb24iLCJwcmV2U3RhdGUiLCJwcmV2VHJhbnNpdGlvbiIsImN1cnJlbnRUcmFuc2l0aW9uIiwiX3VwZGF0ZWRGaWJlcnMiLCJyZXR1cm5WYWx1ZSIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoIiwiUyIsImhhbmRsZUFjdGlvblJldHVyblZhbHVlIiwib25BY3Rpb25FcnJvciIsImVycm9yJDIiLCJvbkFjdGlvblN1Y2Nlc3MiLCJub3RpZnlBY3Rpb25MaXN0ZW5lcnMiLCJsYXN0IiwiYWN0aW9uU3RhdGVSZWR1Y2VyIiwib2xkU3RhdGUiLCJtb3VudEFjdGlvblN0YXRlIiwiaW5pdGlhbFN0YXRlUHJvcCIsInNzckZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImlzTWF0Y2hpbmciLCJtYXJrZXJJbnN0YW5jZSIsImNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIiLCJpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nIiwidXBkYXRlQWN0aW9uU3RhdGUiLCJzdGF0ZUhvb2siLCJ1cGRhdGVBY3Rpb25TdGF0ZUltcGwiLCJjdXJyZW50U3RhdGVIb29rIiwiYWN0aW9uUXVldWVIb29rIiwiYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QiLCJyZXJlbmRlckFjdGlvblN0YXRlIiwibW91bnRSZWYiLCJpbml0aWFsVmFsdWUiLCJtb3VudEVmZmVjdEltcGwiLCJmaWJlckZsYWdzIiwiaG9va0ZsYWdzIiwibW91bnRMYXlvdXRFZmZlY3QiLCJMYXlvdXQiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2xlYW51cCIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsIm1vdW50RGVmZXJyZWRWYWx1ZSIsIm1vdW50RGVmZXJyZWRWYWx1ZUltcGwiLCJ1cGRhdGVEZWZlcnJlZFZhbHVlIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJyZXF1ZXN0RGVmZXJyZWRMYW5lIiwicHJldlZhbHVlIiwic3RhcnRUcmFuc2l0aW9uIiwicGVuZGluZ1N0YXRlIiwiZmluaXNoZWRTdGF0ZSIsInByZXZpb3VzUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJ0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUiLCJkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsImVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsIiwiZm9ybUZpYmVyIiwiZXhpc3RpbmdTdGF0ZUhvb2siLCJpbml0aWFsUmVzZXRTdGF0ZSIsIm1vdW50VHJhbnNpdGlvbiIsInVwZGF0ZVRyYW5zaXRpb24iLCJib29sZWFuT3JUaGVuYWJsZSIsInN0YXJ0IiwicmVyZW5kZXJUcmFuc2l0aW9uIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJtb3VudElkIiwiaWRlbnRpZmllclByZWZpeCIsInRyZWVJZCIsImlkV2l0aExlYWRpbmdCaXQiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJtb3VudFJlZnJlc2giLCJyZWZyZXNoQ2FjaGUiLCJzZWVkS2V5IiwicHJvdmlkZXIiLCJjcmVhdGVDYWNoZSIsImNhY2hlIiwiSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AwIiwiZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIiwiSlNDb21waWxlcl9PcHRpbWl6ZUFyZ3VtZW50c0FycmF5X3AxIiwicHJldkRpc3BhdGNoZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsImN1cnJlbnRTdGF0ZSIsInRocm93SWZEdXJpbmdSZW5kZXIiLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImN0b3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsInJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzIiwiYmFzZVByb3BzIiwiZGVmYXVsdFByb3BzIiwibG9nVW5jYXVnaHRFcnJvciIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnlOYW1lIiwidGhyb3duRXJyb3JzIiwib25VbmNhdWdodEVycm9yIiwiY29tcG9uZW50U3RhY2siLCJlIiwic2V0VGltZW91dCIsImxvZ0NhdWdodEVycm9yIiwiYm91bmRhcnkiLCJvbkNhdWdodEVycm9yIiwiZXJyb3JCb3VuZGFyeSIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIm1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCIsImNhbGxDb21wb25lbnREaWRDYXRjaEluREVWIiwidGhyb3dFeGNlcHRpb24iLCJyb290UmVuZGVyTGFuZXMiLCJyZXN0b3JlUGVuZGluZ1VwZGF0ZXJzIiwicHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMiLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIlJvb3RJblByb2dyZXNzIiwiUm9vdFN1c3BlbmRlZCIsIm5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInRyYW5zaXRpb25zIiwibWFya2VySW5zdGFuY2VzIiwicmV0cnlRdWV1ZSIsImNhdXNlIiwiUm9vdFN1c3BlbmRlZFdpdGhEZWxheSIsIlJvb3RFcnJvcmVkIiwid29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwibW91bnRDaGlsZEZpYmVycyIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwidXBkYXRlRm9yd2FyZFJlZiIsInByb3BzV2l0aG91dFJlZiIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJzaG91bGRDb25zdHJ1Y3QiLCJjb21wYXJlIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsImNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwicHJldlByb3BzIiwidXBkYXRlRnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQiLCJuZXh0SXNEZXRhY2hlZCIsIl9wZW5kaW5nVmlzaWJpbGl0eSIsIm1hcmtSZWYiLCJkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudCIsImNhY2hlUG9vbCIsInB1c2hUcmFuc2l0aW9uIiwibmV4dEJhc2VMYW5lcyIsInBlZWtDYWNoZUZyb21Qb29sIiwiQ2FjaGVDb250ZXh0IiwicG9vbCIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJyZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyIsImNvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlcyIsInJlcGxheUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJjdXJyZW50JGpzY29tcCQwIiwiX2luc3RhbmNlIiwidXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsImNvbnRleHRUeXBlIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiX3JlYWN0SW50ZXJuYWxzIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiY29tcG9uZW50V2lsbE1vdW50IiwiX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyIsIlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJuZXdBcGlOYW1lIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJkaWRXYXJuQWJvdXRDaGlsZENvbnRleHRUeXBlcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlcyQxIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsImRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsInJlZnMiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJvbGRDb250ZXh0IiwiY2FsbFJlbmRlckluREVWIiwiZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyIsIm1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nIiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsIm1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwiZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUiLCJwcmltYXJ5VHJlZURpZERlZmVyIiwid29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUiLCJ1cGRhdGVTdXNwZW5zZUNvbXBvbmVudCIsInNob3dGYWxsYmFjayIsImRpZFN1c3BlbmQiLCJKU0NvbXBpbGVyX3RlbXAiLCJGb3JjZVN1c3BlbnNlRmFsbGJhY2siLCJuZXh0SW5zdGFuY2UiLCJKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAiLCJjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSIsInRyZWVDb250ZXh0Iiwib3ZlcmZsb3ciLCJyZXRyeUxhbmUiLCJmYWxsYmFjayIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsIlNVU1BFTkRFRF9NQVJLRVIiLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwicmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmciLCJnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMiLCJkaWdlc3QiLCJTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24iLCJyZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5IiwicmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJzdWJ0cmVlRmxhZ3MiLCJwcmltYXJ5Q2hpbGRyZW4iLCJvZmZzY3JlZW5Qcm9wcyIsImNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbiIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsInByb3BhZ2F0aW9uUm9vdCIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkIiwiY2hpbGRTbG90IiwiaXNBbkFycmF5IiwiaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlIiwiaXNCYWNrd2FyZHMiLCJ0YWlsIiwibGFzdENvbnRlbnRSb3ciLCJ0YWlsTW9kZSIsInJlbmRlclN0YXRlIiwicmVuZGVyaW5nIiwicmVuZGVyaW5nU3RhcnRUaW1lIiwidXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50IiwiZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIiLCJkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyIsIl9pIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJwdXNoUHJvdmlkZXIiLCJlZmZlY3REdXJhdGlvbiIsInBhc3NpdmVFZmZlY3REdXJhdGlvbiIsImRpZFN1c3BlbmRCZWZvcmUiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJwcmV2U2libGluZyIsInJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZXMiLCJpc0RlaHlkcmF0ZWQiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciIsInN1cHBvcnRzUmVzb3VyY2VzIiwiZ2V0UmVzb3VyY2UiLCJjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSIsInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSIsImRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsInZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwidmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIiwicG9vbGVkQ2FjaGUiLCJyZXRhaW5DYWNoZSIsInBvb2xlZENhY2hlTGFuZXMiLCJyZXNldENvbnRleHREZXBlbmRlbmNpZXMiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsInByb3ZpZGVyRmliZXIiLCJ2YWx1ZUN1cnNvciIsInJlbmRlcmVyQ3Vyc29yREVWIiwiX2N1cnJlbnRSZW5kZXJlciIsInJlbmRlcmVyU2lnaWwiLCJyZW5kZXJlcjJDdXJzb3JERVYiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiY3VycmVudFZhbHVlIiwiY29udGV4dHMiLCJmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUiLCJsaXN0IiwibmV4dEZpYmVyIiwiZGVwZW5kZW5jeSIsImlzSW5zaWRlUHJvcGFnYXRpb25CYWlsb3V0IiwiY3VycmVudFBhcmVudCIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJtZW1vaXplZFZhbHVlIiwicmVhZENvbnRleHRGb3JDb25zdW1lciIsImNvbnN1bWVyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlckxvY2FsIiwicmVmQ291bnQiLCJzaWduYWwiLCJhYm9ydGVkIiwicmVsZWFzZUNhY2hlIiwic2NoZWR1bGVDYWxsYmFjayQxIiwiTm9ybWFsUHJpb3JpdHkiLCJhYm9ydCIsImNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciIsInJlc3VtZWRDYWNoZSIsIm9mZnNjcmVlbldvcmtJblByb2dyZXNzIiwicHJldkNhY2hlUG9vbCIsImNhY2hlRnJvbVBvb2wiLCJtYXJrVXBkYXRlIiwiZG9lc1JlcXVpcmVDbG9uZSIsImNvbXBsZXRlZFdvcmsiLCJhcHBlbmRBbGxDaGlsZHJlbiIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsInN1cHBvcnRzTXV0YXRpb24iLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwiX25vZGUiLCJjbG9uZUhpZGRlbkluc3RhbmNlIiwiY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UiLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsInBlbmRpbmdDaGlsZHJlbiIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwiY3VycmVudEluc3RhbmNlIiwiX29sZFByb3BzIiwiY3VycmVudEhvc3RDb250ZXh0IiwiY2xvbmVJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkIiwibWF5U3VzcGVuZENvbW1pdCIsInByZWxvYWRJbnN0YW5jZSIsInNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4iLCJTdXNwZW5zZXlDb21taXRFeGNlcHRpb24iLCJwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJyZXNvdXJjZSIsIm1heVJlc291cmNlU3VzcGVuZENvbW1pdCIsInByZWxvYWRSZXNvdXJjZSIsInNjaGVkdWxlUmV0cnlFZmZlY3QiLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJsYXN0VGFpbE5vZGUiLCJfbGFzdFRhaWxOb2RlIiwiYnViYmxlUHJvcGVydGllcyIsImRpZEJhaWxvdXQiLCJuZXdDaGlsZExhbmVzIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwidHJlZUJhc2VEdXJhdGlvbiIsImNvbXBsZXRlV29yayIsInBlbmRpbmdDb250ZXh0IiwicXVldWVSZWNvdmVyYWJsZUVycm9ycyIsIm5leHRSZXNvdXJjZSIsImNyZWF0ZUluc3RhbmNlIiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRXb3JrSW5Qcm9ncmVzcyIsIndvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUiLCJ1bndpbmRXb3JrIiwidW53aW5kSW50ZXJydXB0ZWRXb3JrIiwiaW50ZXJydXB0ZWRXb3JrIiwic2hvdWxkUHJvZmlsZSIsImNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzIiwiZmluaXNoZWRXb3JrIiwiY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCIsImNvbW1pdEhvb2tMYXlvdXRVbm1vdW50RWZmZWN0cyIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJmaXJzdEVmZmVjdCIsIk5vRmxhZ3MiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQiLCJJbnNlcnRpb24iLCJpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjYWxsQ3JlYXRlSW5ERVYiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQiLCJhZGRlbmR1bSIsIm4iLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvciIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQiLCJjYWxsRGVzdHJveUluREVWIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCIsImNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdENsYXNzQ2FsbGJhY2tzIiwiY2FsbEdldFNuYXBzaG90QmVmb3JlVXBkYXRlcyIsImNvbW1pdENsYXNzU25hcHNob3QiLCJyZXNvbHZlZFByZXZQcm9wcyIsInNuYXBzaG90IiwiZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudEluREVWIiwiY29tbWl0QXR0YWNoUmVmIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJzYWZlbHlBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJlcnJvciQzIiwiY29tbWl0UHJvZmlsZXIiLCJjb21taXRTdGFydFRpbWUiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUiLCJvbkNvbW1pdCIsIm9uUmVuZGVyIiwiY29tbWl0UHJvZmlsZXJQb3N0Q29tbWl0SW1wbCIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZTIiLCJvblBvc3RDb21taXQiLCJjb21taXRIb3N0TW91bnQiLCJjb21taXRNb3VudCIsImNvbW1pdEhvc3RVcGRhdGUiLCJjb21taXRVcGRhdGUiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJiZWZvcmUiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImNvbW1pdFBsYWNlbWVudCIsInBhcmVudEZpYmVyIiwicmVzZXRUZXh0Q29udGVudCIsImNvbW1pdEhvc3RQb3J0YWxDb250YWluZXJDaGlsZHJlbiIsInJlcGxhY2VDb250YWluZXJDaGlsZHJlbiIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImZpcnN0Q2hpbGQiLCJwcmVwYXJlRm9yQ29tbWl0IiwibmV4dEVmZmVjdCIsImNsZWFyQ29udGFpbmVyIiwic2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImZpbmlzaGVkUm9vdCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzIiwiY2FsbENvbXBvbmVudERpZE1vdW50SW5ERVYiLCJjYWxsQ29tcG9uZW50RGlkVXBkYXRlSW5ERVYiLCJjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzIiwiZGV0YWNoRmliZXJBZnRlckVmZmVjdHMiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzIiwiY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlciIsImRlbGV0ZWRGaWJlciIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwicmVsZWFzZVJlc291cmNlIiwidW5tb3VudEhvaXN0YWJsZSIsInByZXZIb3N0UGFyZW50IiwiaG9zdFBhcmVudCIsInByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJob3N0UGFyZW50SXNDb250YWluZXIiLCJyZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJyZW1vdmVDaGlsZCIsImNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsImdldFJldHJ5Q2FjaGUiLCJyZXRyeUNhY2hlIiwiUG9zc2libHlXZWFrU2V0IiwiX3JldHJ5Q2FjaGUiLCJhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzIiwid2FrZWFibGVzIiwid2FrZWFibGUiLCJyZXRyeSIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiaW5Qcm9ncmVzc0xhbmVzIiwiaW5Qcm9ncmVzc1Jvb3QiLCJjb21taXRNdXRhdGlvbkVmZmVjdHMiLCJjb21taXR0ZWRMYW5lcyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzIiwicm9vdCRqc2NvbXAkMCIsImNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyIsImhvaXN0YWJsZVJvb3QiLCJjdXJyZW50SG9pc3RhYmxlUm9vdCIsImh5ZHJhdGVIb2lzdGFibGUiLCJtb3VudEhvaXN0YWJsZSIsImFjcXVpcmVSZXNvdXJjZSIsImNsZWFyU2luZ2xldG9uIiwiYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlIiwibmVlZHNGb3JtUmVzZXQiLCJjb21taXRUZXh0VXBkYXRlIiwicHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyIsImdldEhvaXN0YWJsZVJvb3QiLCJjb21taXRIeWRyYXRlZENvbnRhaW5lciIsInJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyIsImdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUiLCJ3YXNIaWRkZW4iLCJfY3VycmVudCIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzIiwiaGlkZUluc3RhbmNlIiwidW5oaWRlSW5zdGFuY2UiLCJoaWRlVGV4dEluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwicmVzZXRGb3JtSW5zdGFuY2UiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsInJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMiLCJjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzIiwicHJldmlvdXNDYWNoZSIsImNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0IiwicmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXR0ZWRUcmFuc2l0aW9ucyIsImNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJyZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsIl9pbnN0YW5jZTIiLCJmaW5pc2hlZFJvb3QkanNjb21wJDAiLCJyZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQiLCJzdXNwZW5zZXlDb21taXRGbGFnIiwiYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIiLCJzdXNwZW5kUmVzb3VyY2UiLCJzdXNwZW5kSW5zdGFuY2UiLCJwcmV2aW91c0hvaXN0YWJsZVJvb3QiLCJkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwiY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyIsImRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0IiwiZGVsZXRlZFN1YnRyZWVSb290IiwiZmluZEZpYmVyUm9vdEZvckhvc3RSb290IiwiaG9zdFJvb3QiLCJtYXliZUZpYmVyIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImZpbmRGaWJlclJvb3QiLCJtYXRjaFNlbGVjdG9yIiwiZmliZXIkanNjb21wJDAiLCJzZWxlY3RvciIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwidGFnJGpzY29tcCQwIiwic2VsZWN0b3JJbmRleCIsInNlbGVjdG9yJGpzY29tcCQwIiwiaXNIaWRkZW5TdWJ0cmVlIiwiUk9MRV9UWVBFIiwibWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSIsIlRFWFRfVFlQRSIsImdldFRleHRDb250ZW50IiwiVEVTVF9OQU1FX1RZUEUiLCJzZWxlY3RvclRvU3RyaW5nIiwiZmluZFBhdGhzIiwic2VsZWN0b3JzIiwibWF0Y2hpbmdGaWJlcnMiLCJmaW5kQWxsTm9kZXMiLCJzdXBwb3J0c1Rlc3RTZWxlY3RvcnMiLCJmcm9tIiwib25Db21taXRSb290IiwiY29tbWl0SG9va3MiLCJjb21taXRIb29rIiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJzdXNwZW5zZUhhbmRsZXIiLCJpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMiLCJkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzIiwicHJlcGFyZUZyZXNoU3RhY2siLCJtYXJrUm9vdFN1c3BlbmRlZCIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyIiwid2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWIiwid29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMiLCJmb3JjZVN5bmMiLCJzaG91bGRUaW1lU2xpY2UiLCJleGl0U3RhdHVzIiwicmVuZGVyUm9vdENvbmN1cnJlbnQiLCJyZW5kZXJSb290U3luYyIsInJlbmRlcldhc0NvbmN1cnJlbnQiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyIsIlJvb3REaWROb3RDb21wbGV0ZSIsIndvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyIsImlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyIsImVycm9yUmV0cnlMYW5lcyIsImVycm9yUmV0cnlMYW5lcyRqc2NvbXAkMCIsIndhc1Jvb3REZWh5ZHJhdGVkIiwid29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyIiwid29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMiLCJSb290RmF0YWxFcnJvcmVkIiwiUm9vdENvbXBsZXRlZCIsImNvbW1pdFJvb3QiLCJ3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIiwid29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSIsIklNTUVESUFURV9DT01NSVQiLCJGQUxMQkFDS19USFJPVFRMRV9NUyIsInRpbWVvdXRIYW5kbGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJjb21taXRSb290V2hlblJlYWR5IiwiVEhST1RUTEVEX0NPTU1JVCIsImVycm9ycyIsImFwcGx5IiwicmVjb3ZlcmFibGVFcnJvcnMiLCJkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTa2lwU3VzcGVuZGVkU2libGluZ3MiLCJzdXNwZW5kZWRDb21taXRSZWFzb24iLCJjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUiLCJjb21wbGV0ZWRSZW5kZXJFbmRUaW1lIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIlNVU1BFTkRFRF9DT01NSVQiLCJjaGVjayIsImRpZEF0dGVtcHRFbnRpcmVUcmVlIiwid29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMiLCJyZXNldFdvcmtJblByb2dyZXNzU3RhY2siLCJOb3RTdXNwZW5kZWQiLCJub1RpbWVvdXQiLCJjYW5jZWxUaW1lb3V0Iiwid29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSIsImFsbEVudGFuZ2xlZExhbmVzIiwiZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyIsImhhbmRsZVRocm93IiwidGhyb3duVmFsdWUiLCJTdXNwZW5kZWRPbkltbWVkaWF0ZSIsIlN1c3BlbmRlZE9uSW5zdGFuY2UiLCJTdXNwZW5kZWRPbkh5ZHJhdGlvbiIsIlN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSIsIlN1c3BlbmRlZE9uRXJyb3IiLCJlcnJvcmVkV29yayIsIm1hcmtDb21wb25lbnRFcnJvcmVkIiwiU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlIiwibWFya0NvbXBvbmVudFN1c3BlbmRlZCIsInB1c2hEaXNwYXRjaGVyIiwicHVzaEFzeW5jRGlzcGF0Y2hlciIsInByZXZBc3luY0Rpc3BhdGNoZXIiLCJBIiwiRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciIsInNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJ1bml0T2ZXb3JrIiwidGhyb3dBbmRVbndpbmRXb3JrTG9vcCIsIndvcmtMb29wU3luYyIsInRocm93blZhbHVlJDQiLCJwZXJmb3JtVW5pdE9mV29yayIsIlJFTkRFUl9USU1FT1VUX01TIiwicmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayIsIlN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUiLCJob3N0RmliZXIiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJ0aHJvd25WYWx1ZSQ1IiwibWFya1JlbmRlcllpZWxkZWQiLCJzaG91bGRZaWVsZCIsInJlcGxheUJlZ2luV29yayIsImlzUHJvZmlsaW5nTW9kZSIsInN1c3BlbmRlZFJlYXNvbiIsInVud2luZFVuaXRPZldvcmsiLCJza2lwU2libGluZ3MiLCJwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSIsImNvbW1pdFJvb3RJbXBsIiwicmVuZGVyUHJpb3JpdHlMZXZlbCIsInJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwibWFya0NvbW1pdFN0YXJ0ZWQiLCJyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsInNjaGVkdWxlQ2FsbGJhY2siLCJyZXNldEFmdGVyQ29tbWl0IiwibWFya0xheW91dEVmZmVjdHNTdGFydGVkIiwibWFya0xheW91dEVmZmVjdHNTdG9wcGVkIiwicmVxdWVzdFBhaW50IiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMiLCJyZWxlYXNlUm9vdFBvb2xlZENhY2hlIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwibWFrZUVycm9ySW5mbyIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdHkiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCIsIm9uUG9zdENvbW1pdEZpYmVyUm9vdCIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwicGluZ0NhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwidGhyZWFkSURzIiwicGluZ1N1c3BlbmRlZFJvb3QiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwic3VzcGVuc2VTdGF0ZSIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJpc0luU3RyaWN0TW9kZSIsImlzU3RyaWN0TW9kZUZpYmVyIiwiZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIiLCJzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyIsImFyZ3VtZW50cyIsImRvdWJsZUludm9rZUVmZmVjdHMiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Iiwic2NoZWR1bGluZ0ZpYmVyIiwicHJpb3JpdHlMZXZlbCIsImZha2VBY3RDYWxsYmFja05vZGUiLCJmYW1pbHkiLCJwcmV2VHlwZSIsIm5lZWRzQ29tcGFyZUZhbWlsaWVzIiwiJCR0eXBlb2ZOZXh0VHlwZSIsIldlYWtTZXQiLCJmYWlsZWRCb3VuZGFyaWVzIiwiY2FuZGlkYXRlVHlwZSIsIm5lZWRzUmVuZGVyIiwiaGFzQmFkTWFwUG9seWZpbGwiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImlzUmVhY3RDb21wb25lbnQiLCJvd25lciIsImZpYmVyVGFnIiwicmVzb2x2ZWRUeXBlIiwiaXNIb3N0SG9pc3RhYmxlVHlwZSIsImlzSG9zdFNpbmdsZXRvblR5cGUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJlbGVtZW50cyIsInByaW1hcnlDaGlsZEluc3RhbmNlIiwiX3BlbmRpbmdNYXJrZXJzIiwiX3RyYW5zaXRpb25zIiwiZGV0YWNoIiwiYXR0YWNoIiwiRmliZXJSb290Tm9kZSIsImh5ZHJhdGUiLCJpbmNvbXBsZXRlVHJhbnNpdGlvbnMiLCJfZGVidWdSb290VHlwZSIsImNyZWF0ZUZpYmVyUm9vdCIsImluaXRpYWxDaGlsZHJlbiIsImh5ZHJhdGlvbkNhbGxiYWNrcyIsImlzU3RyaWN0TW9kZSIsInRyYW5zaXRpb25DYWxsYmFja3MiLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsInVwZGF0ZUNvbnRhaW5lckltcGwiLCJvblNjaGVkdWxlRmliZXJSb290IiwibWFya1JlbmRlclNjaGVkdWxlZCIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJtYXJrUmV0cnlMYW5lSW1wbCIsIm1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkIiwiZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMiLCJnZXRMYW5lTGFiZWxNYXAiLCJsYWJlbCIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlN5bWJvbCIsImZvciIsIml0ZXJhdG9yIiwiX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwiX19yZWFjdERpc2FibGVkTG9nIiwiV2Vha01hcCIsImlzQXJyYXkiLCJyZW5kZXJlclZlcnNpb24iLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiZXh0cmFEZXZUb29sc0NvbmZpZyIsIndhcm5zSWZOb3RBY3RpbmciLCJiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIiLCJhZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsInByZXBhcmVTY29wZVVwZGF0ZSIsImdldEluc3RhbmNlRnJvbVNjb3BlIiwicmVzb2x2ZUV2ZW50VHlwZSIsInJlc29sdmVFdmVudFRpbWVTdGFtcCIsInJlcXVlc3RQb3N0UGFpbnRDYWxsYmFjayIsImJpbmRUb0NvbnNvbGUiLCJnZXRCb3VuZGluZ1JlY3QiLCJzZXRGb2N1c0lmRm9jdXNhYmxlIiwic2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciIsImZyZWV6ZSIsIk1hdGgiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsInVuc3RhYmxlX25vdyIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwicGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCIsInN0cmljdFJvb3QiLCJmaWJlckFycmF5IiwiZmlyc3RGaWJlciIsInVuaXF1ZU5hbWVzIiwiY2FsbENvbXBvbmVudCIsIndhc1JlbmRlcmluZyIsImNhbGxSZW5kZXIiLCJjYWxsQ29tcG9uZW50RGlkTW91bnQiLCJjYWxsQ29tcG9uZW50RGlkVXBkYXRlIiwiY2FsbENvbXBvbmVudERpZENhdGNoIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50IiwiY2FsbENyZWF0ZSIsImVmZmVjdCIsImNhbGxEZXN0cm95IiwiY2FsbExhenlJbml0IiwibGF6eSIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIl9zdG9yZSIsInZhbGlkYXRlZCIsImNvbXBvbmVudEtleSIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyQXBwZW5kaXgiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRGVmZXJyZWRWYWx1ZSIsInVzZVRyYW5zaXRpb24iLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidXNlQ2FjaGVSZWZyZXNoIiwidXNlRm9ybVN0YXRlIiwidXNlQWN0aW9uU3RhdGUiLCJ1c2VPcHRpbWlzdGljIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQiLCJyZXBvcnRHbG9iYWxFcnJvciIsInJlcG9ydEVycm9yIiwid2luZG93IiwiRXJyb3JFdmVudCIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwicHJvY2VzcyIsImVtaXQiLCJBYm9ydENvbnRyb2xsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsIl90aHJlYWRDb3VudCIsInByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsImNhY2hlRm9yVHlwZSIsImdldE93bmVyIiwic3ltYm9sRm9yIiwiSW5maW5pdHkiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJvdmVycmlkZUhvb2tTdGF0ZSIsIm92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCIsIm92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCIsIm92ZXJyaWRlUHJvcHMiLCJvdmVycmlkZVByb3BzRGVsZXRlUGF0aCIsIm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoIiwic2NoZWR1bGVVcGRhdGUiLCJzZXRFcnJvckhhbmRsZXIiLCJzZXRTdXNwZW5zZUhhbmRsZXIiLCJuZXdTaG91bGRFcnJvckltcGwiLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uIiwiYmF0Y2hlZFVwZGF0ZXMiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUNvbnRhaW5lciIsImNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUiLCJjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwiY3JlYXRlUG9ydGFsIiwiZSQ2IiwidG9TdHJpbmdUYWciLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImNyZWF0ZVRleHRTZWxlY3RvciIsInRleHQiLCJkZWZhdWx0T25DYXVnaHRFcnJvciIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwicmVjcmVhdGVNZXNzYWdlIiwicHJldkdldEN1cnJlbnRTdGFjayIsImVudmlyb25tZW50TmFtZSIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJkZWZhdWx0T25VbmNhdWdodEVycm9yIiwiZGVmZXJyZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZpbmRCb3VuZGluZ1JlY3RzIiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIiLCJmb2N1c1dpdGhpbiIsImdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiIsIm1heFNlbGVjdG9ySW5kZXgiLCJtYXRjaGVkTmFtZXMiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJpbmplY3RJbnRvRGV2VG9vbHMiLCJidW5kbGVUeXBlIiwidmVyc2lvbiIsImN1cnJlbnREaXNwYXRjaGVyUmVmIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJyZWNvbmNpbGVyVmVyc2lvbiIsInJlbmRlcmVyQ29uZmlnIiwiZ2V0Q3VycmVudEZpYmVyIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwib2JzZXJ2ZVZpc2libGVSZWN0cyIsIm9wdGlvbnMiLCJuZXh0SW5zdGFuY2VSb290cyIsImluc3RhbmNlUm9vdHMiLCJ0YXJnZXQiLCJ1bm9ic2VydmUiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInNob3VsZEVycm9yIiwic2hvdWxkU3VzcGVuZCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRGF0YSIsInJlc2V0U3RhdGVRdWV1ZSIsInVwZGF0ZUNvbnRhaW5lciIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/constants.js":
/*!****************************************************!*\
  !*** ./node_modules/react-reconciler/constants.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLGtMQUEyRTtBQUM3RSIsInNvdXJjZXMiOlsiL1VzZXJzL25ha2FtdXJhL2dpdC8zZC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-reconciler/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-reconciler/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsOEpBQWlFO0FBQ25FIiwic291cmNlcyI6WyIvVXNlcnMvbmFrYW11cmEvZ2l0LzNkL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-reconciler/index.js\n");

/***/ })

};
;